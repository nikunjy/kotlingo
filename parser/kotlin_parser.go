// Code generated from KotlinParser.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser // KotlinParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 173, 3456,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 3, 2, 5, 2, 350, 10, 2, 3, 2, 7, 2, 353, 10, 2, 12, 2, 14, 2, 356,
	11, 2, 3, 2, 7, 2, 359, 10, 2, 12, 2, 14, 2, 362, 11, 2, 3, 2, 3, 2, 3,
	2, 7, 2, 367, 10, 2, 12, 2, 14, 2, 370, 11, 2, 3, 2, 3, 2, 3, 3, 5, 3,
	375, 10, 3, 3, 3, 7, 3, 378, 10, 3, 12, 3, 14, 3, 381, 11, 3, 3, 3, 7,
	3, 384, 10, 3, 12, 3, 14, 3, 387, 11, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	7, 3, 394, 10, 3, 12, 3, 14, 3, 397, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 6,
	4, 403, 10, 4, 13, 4, 14, 4, 404, 3, 5, 3, 5, 3, 5, 7, 5, 410, 10, 5, 12,
	5, 14, 5, 413, 11, 5, 3, 5, 3, 5, 7, 5, 417, 10, 5, 12, 5, 14, 5, 420,
	11, 5, 3, 5, 3, 5, 6, 5, 424, 10, 5, 13, 5, 14, 5, 425, 3, 5, 3, 5, 3,
	5, 5, 5, 431, 10, 5, 3, 5, 7, 5, 434, 10, 5, 12, 5, 14, 5, 437, 11, 5,
	3, 6, 3, 6, 3, 6, 5, 6, 442, 10, 6, 5, 6, 444, 10, 6, 3, 7, 7, 7, 447,
	10, 7, 12, 7, 14, 7, 450, 11, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 457,
	10, 8, 3, 8, 5, 8, 460, 10, 8, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10, 5, 10, 467,
	10, 10, 3, 11, 5, 11, 470, 10, 11, 3, 11, 3, 11, 7, 11, 474, 10, 11, 12,
	11, 14, 11, 477, 11, 11, 3, 11, 3, 11, 7, 11, 481, 10, 11, 12, 11, 14,
	11, 484, 11, 11, 3, 11, 5, 11, 487, 10, 11, 3, 11, 7, 11, 490, 10, 11,
	12, 11, 14, 11, 493, 11, 11, 3, 11, 3, 11, 7, 11, 497, 10, 11, 12, 11,
	14, 11, 500, 11, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5,
	12, 509, 10, 12, 3, 13, 5, 13, 512, 10, 13, 3, 13, 3, 13, 3, 13, 7, 13,
	517, 10, 13, 12, 13, 14, 13, 520, 11, 13, 5, 13, 522, 10, 13, 3, 13, 5,
	13, 525, 10, 13, 3, 13, 7, 13, 528, 10, 13, 12, 13, 14, 13, 531, 11, 13,
	3, 13, 3, 13, 7, 13, 535, 10, 13, 12, 13, 14, 13, 538, 11, 13, 3, 13, 5,
	13, 541, 10, 13, 3, 13, 7, 13, 544, 10, 13, 12, 13, 14, 13, 547, 11, 13,
	3, 13, 5, 13, 550, 10, 13, 3, 13, 7, 13, 553, 10, 13, 12, 13, 14, 13, 556,
	11, 13, 3, 13, 3, 13, 7, 13, 560, 10, 13, 12, 13, 14, 13, 563, 11, 13,
	3, 13, 5, 13, 566, 10, 13, 3, 13, 7, 13, 569, 10, 13, 12, 13, 14, 13, 572,
	11, 13, 3, 13, 5, 13, 575, 10, 13, 3, 13, 7, 13, 578, 10, 13, 12, 13, 14,
	13, 581, 11, 13, 3, 13, 3, 13, 7, 13, 585, 10, 13, 12, 13, 14, 13, 588,
	11, 13, 3, 13, 5, 13, 591, 10, 13, 3, 14, 5, 14, 594, 10, 14, 3, 14, 3,
	14, 7, 14, 598, 10, 14, 12, 14, 14, 14, 601, 11, 14, 5, 14, 603, 10, 14,
	3, 14, 3, 14, 3, 15, 3, 15, 7, 15, 609, 10, 15, 12, 15, 14, 15, 612, 11,
	15, 3, 15, 3, 15, 7, 15, 616, 10, 15, 12, 15, 14, 15, 619, 11, 15, 3, 15,
	3, 15, 3, 16, 3, 16, 7, 16, 625, 10, 16, 12, 16, 14, 16, 628, 11, 16, 3,
	16, 3, 16, 7, 16, 632, 10, 16, 12, 16, 14, 16, 635, 11, 16, 3, 16, 3, 16,
	7, 16, 639, 10, 16, 12, 16, 14, 16, 642, 11, 16, 3, 16, 7, 16, 645, 10,
	16, 12, 16, 14, 16, 648, 11, 16, 3, 16, 7, 16, 651, 10, 16, 12, 16, 14,
	16, 654, 11, 16, 3, 16, 5, 16, 657, 10, 16, 5, 16, 659, 10, 16, 3, 16,
	7, 16, 662, 10, 16, 12, 16, 14, 16, 665, 11, 16, 3, 16, 3, 16, 3, 17, 5,
	17, 670, 10, 17, 3, 17, 5, 17, 673, 10, 17, 3, 17, 7, 17, 676, 10, 17,
	12, 17, 14, 17, 679, 11, 17, 3, 17, 3, 17, 3, 17, 7, 17, 684, 10, 17, 12,
	17, 14, 17, 687, 11, 17, 3, 17, 3, 17, 7, 17, 691, 10, 17, 12, 17, 14,
	17, 694, 11, 17, 3, 17, 3, 17, 7, 17, 698, 10, 17, 12, 17, 14, 17, 701,
	11, 17, 3, 17, 5, 17, 704, 10, 17, 3, 18, 3, 18, 7, 18, 708, 10, 18, 12,
	18, 14, 18, 711, 11, 18, 3, 18, 3, 18, 7, 18, 715, 10, 18, 12, 18, 14,
	18, 718, 11, 18, 3, 18, 7, 18, 721, 10, 18, 12, 18, 14, 18, 724, 11, 18,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 730, 10, 19, 3, 20, 3, 20, 3, 20, 3,
	21, 7, 21, 736, 10, 21, 12, 21, 14, 21, 739, 11, 21, 3, 21, 7, 21, 742,
	10, 21, 12, 21, 14, 21, 745, 11, 21, 3, 21, 3, 21, 3, 22, 3, 22, 5, 22,
	751, 10, 22, 3, 22, 7, 22, 754, 10, 22, 12, 22, 14, 22, 757, 11, 22, 3,
	22, 3, 22, 7, 22, 761, 10, 22, 12, 22, 14, 22, 764, 11, 22, 3, 22, 3, 22,
	3, 23, 3, 23, 7, 23, 770, 10, 23, 12, 23, 14, 23, 773, 11, 23, 3, 23, 3,
	23, 7, 23, 777, 10, 23, 12, 23, 14, 23, 780, 11, 23, 3, 23, 3, 23, 7, 23,
	784, 10, 23, 12, 23, 14, 23, 787, 11, 23, 3, 23, 7, 23, 790, 10, 23, 12,
	23, 14, 23, 793, 11, 23, 3, 23, 7, 23, 796, 10, 23, 12, 23, 14, 23, 799,
	11, 23, 3, 23, 5, 23, 802, 10, 23, 3, 23, 7, 23, 805, 10, 23, 12, 23, 14,
	23, 808, 11, 23, 3, 23, 3, 23, 3, 24, 5, 24, 813, 10, 24, 3, 24, 7, 24,
	816, 10, 24, 12, 24, 14, 24, 819, 11, 24, 3, 24, 3, 24, 7, 24, 823, 10,
	24, 12, 24, 14, 24, 826, 11, 24, 3, 24, 3, 24, 7, 24, 830, 10, 24, 12,
	24, 14, 24, 833, 11, 24, 3, 24, 5, 24, 836, 10, 24, 3, 25, 3, 25, 7, 25,
	840, 10, 25, 12, 25, 14, 25, 843, 11, 25, 3, 25, 3, 25, 7, 25, 847, 10,
	25, 12, 25, 14, 25, 850, 11, 25, 3, 25, 3, 25, 7, 25, 854, 10, 25, 12,
	25, 14, 25, 857, 11, 25, 3, 25, 7, 25, 860, 10, 25, 12, 25, 14, 25, 863,
	11, 25, 3, 26, 7, 26, 866, 10, 26, 12, 26, 14, 26, 869, 11, 26, 3, 26,
	3, 26, 7, 26, 873, 10, 26, 12, 26, 14, 26, 876, 11, 26, 3, 26, 3, 26, 7,
	26, 880, 10, 26, 12, 26, 14, 26, 883, 11, 26, 3, 26, 3, 26, 3, 27, 3, 27,
	5, 27, 889, 10, 27, 7, 27, 891, 10, 27, 12, 27, 14, 27, 894, 11, 27, 3,
	28, 3, 28, 3, 28, 3, 28, 5, 28, 900, 10, 28, 3, 29, 3, 29, 7, 29, 904,
	10, 29, 12, 29, 14, 29, 907, 11, 29, 3, 29, 3, 29, 3, 30, 5, 30, 912, 10,
	30, 3, 30, 3, 30, 7, 30, 916, 10, 30, 12, 30, 14, 30, 919, 11, 30, 3, 30,
	3, 30, 7, 30, 923, 10, 30, 12, 30, 14, 30, 926, 11, 30, 3, 30, 5, 30, 929,
	10, 30, 3, 30, 7, 30, 932, 10, 30, 12, 30, 14, 30, 935, 11, 30, 3, 30,
	3, 30, 7, 30, 939, 10, 30, 12, 30, 14, 30, 942, 11, 30, 3, 30, 5, 30, 945,
	10, 30, 3, 30, 7, 30, 948, 10, 30, 12, 30, 14, 30, 951, 11, 30, 3, 30,
	5, 30, 954, 10, 30, 3, 31, 3, 31, 7, 31, 958, 10, 31, 12, 31, 14, 31, 961,
	11, 31, 3, 31, 3, 31, 7, 31, 965, 10, 31, 12, 31, 14, 31, 968, 11, 31,
	3, 31, 3, 31, 7, 31, 972, 10, 31, 12, 31, 14, 31, 975, 11, 31, 3, 31, 7,
	31, 978, 10, 31, 12, 31, 14, 31, 981, 11, 31, 3, 31, 7, 31, 984, 10, 31,
	12, 31, 14, 31, 987, 11, 31, 3, 31, 5, 31, 990, 10, 31, 5, 31, 992, 10,
	31, 3, 31, 7, 31, 995, 10, 31, 12, 31, 14, 31, 998, 11, 31, 3, 31, 3, 31,
	3, 32, 5, 32, 1003, 10, 32, 3, 32, 3, 32, 7, 32, 1007, 10, 32, 12, 32,
	14, 32, 1010, 11, 32, 3, 32, 3, 32, 7, 32, 1014, 10, 32, 12, 32, 14, 32,
	1017, 11, 32, 3, 32, 5, 32, 1020, 10, 32, 3, 33, 5, 33, 1023, 10, 33, 3,
	33, 3, 33, 7, 33, 1027, 10, 33, 12, 33, 14, 33, 1030, 11, 33, 3, 33, 5,
	33, 1033, 10, 33, 3, 33, 7, 33, 1036, 10, 33, 12, 33, 14, 33, 1039, 11,
	33, 3, 33, 3, 33, 7, 33, 1043, 10, 33, 12, 33, 14, 33, 1046, 11, 33, 3,
	33, 3, 33, 5, 33, 1050, 10, 33, 3, 33, 7, 33, 1053, 10, 33, 12, 33, 14,
	33, 1056, 11, 33, 3, 33, 3, 33, 7, 33, 1060, 10, 33, 12, 33, 14, 33, 1063,
	11, 33, 3, 33, 3, 33, 7, 33, 1067, 10, 33, 12, 33, 14, 33, 1070, 11, 33,
	3, 33, 3, 33, 7, 33, 1074, 10, 33, 12, 33, 14, 33, 1077, 11, 33, 3, 33,
	5, 33, 1080, 10, 33, 3, 33, 7, 33, 1083, 10, 33, 12, 33, 14, 33, 1086,
	11, 33, 3, 33, 5, 33, 1089, 10, 33, 3, 33, 7, 33, 1092, 10, 33, 12, 33,
	14, 33, 1095, 11, 33, 3, 33, 5, 33, 1098, 10, 33, 3, 34, 3, 34, 3, 34,
	7, 34, 1103, 10, 34, 12, 34, 14, 34, 1106, 11, 34, 3, 34, 5, 34, 1109,
	10, 34, 3, 35, 7, 35, 1112, 10, 35, 12, 35, 14, 35, 1115, 11, 35, 3, 35,
	7, 35, 1118, 10, 35, 12, 35, 14, 35, 1121, 11, 35, 3, 35, 3, 35, 7, 35,
	1125, 10, 35, 12, 35, 14, 35, 1128, 11, 35, 3, 35, 3, 35, 7, 35, 1132,
	10, 35, 12, 35, 14, 35, 1135, 11, 35, 3, 35, 5, 35, 1138, 10, 35, 3, 36,
	3, 36, 7, 36, 1142, 10, 36, 12, 36, 14, 36, 1145, 11, 36, 3, 36, 3, 36,
	7, 36, 1149, 10, 36, 12, 36, 14, 36, 1152, 11, 36, 3, 36, 3, 36, 7, 36,
	1156, 10, 36, 12, 36, 14, 36, 1159, 11, 36, 3, 36, 7, 36, 1162, 10, 36,
	12, 36, 14, 36, 1165, 11, 36, 3, 36, 7, 36, 1168, 10, 36, 12, 36, 14, 36,
	1171, 11, 36, 3, 36, 5, 36, 1174, 10, 36, 3, 36, 7, 36, 1177, 10, 36, 12,
	36, 14, 36, 1180, 11, 36, 3, 36, 3, 36, 3, 37, 5, 37, 1185, 10, 37, 3,
	37, 3, 37, 7, 37, 1189, 10, 37, 12, 37, 14, 37, 1192, 11, 37, 3, 37, 5,
	37, 1195, 10, 37, 3, 37, 7, 37, 1198, 10, 37, 12, 37, 14, 37, 1201, 11,
	37, 3, 37, 3, 37, 7, 37, 1205, 10, 37, 12, 37, 14, 37, 1208, 11, 37, 3,
	37, 3, 37, 5, 37, 1212, 10, 37, 3, 37, 7, 37, 1215, 10, 37, 12, 37, 14,
	37, 1218, 11, 37, 3, 37, 3, 37, 5, 37, 1222, 10, 37, 3, 37, 7, 37, 1225,
	10, 37, 12, 37, 14, 37, 1228, 11, 37, 3, 37, 5, 37, 1231, 10, 37, 3, 37,
	7, 37, 1234, 10, 37, 12, 37, 14, 37, 1237, 11, 37, 3, 37, 3, 37, 7, 37,
	1241, 10, 37, 12, 37, 14, 37, 1244, 11, 37, 3, 37, 3, 37, 5, 37, 1248,
	10, 37, 5, 37, 1250, 10, 37, 3, 37, 6, 37, 1253, 10, 37, 13, 37, 14, 37,
	1254, 3, 37, 5, 37, 1258, 10, 37, 3, 37, 7, 37, 1261, 10, 37, 12, 37, 14,
	37, 1264, 11, 37, 3, 37, 5, 37, 1267, 10, 37, 3, 37, 7, 37, 1270, 10, 37,
	12, 37, 14, 37, 1273, 11, 37, 3, 37, 5, 37, 1276, 10, 37, 3, 37, 5, 37,
	1279, 10, 37, 3, 37, 5, 37, 1282, 10, 37, 3, 37, 7, 37, 1285, 10, 37, 12,
	37, 14, 37, 1288, 11, 37, 3, 37, 5, 37, 1291, 10, 37, 3, 37, 5, 37, 1294,
	10, 37, 5, 37, 1296, 10, 37, 3, 38, 3, 38, 7, 38, 1300, 10, 38, 12, 38,
	14, 38, 1303, 11, 38, 3, 38, 3, 38, 3, 39, 5, 39, 1308, 10, 39, 3, 39,
	3, 39, 7, 39, 1312, 10, 39, 12, 39, 14, 39, 1315, 11, 39, 3, 39, 3, 39,
	7, 39, 1319, 10, 39, 12, 39, 14, 39, 1322, 11, 39, 3, 39, 3, 39, 7, 39,
	1326, 10, 39, 12, 39, 14, 39, 1329, 11, 39, 3, 39, 3, 39, 7, 39, 1333,
	10, 39, 12, 39, 14, 39, 1336, 11, 39, 3, 39, 5, 39, 1339, 10, 39, 3, 39,
	7, 39, 1342, 10, 39, 12, 39, 14, 39, 1345, 11, 39, 3, 39, 5, 39, 1348,
	10, 39, 3, 40, 5, 40, 1351, 10, 40, 3, 40, 3, 40, 7, 40, 1355, 10, 40,
	12, 40, 14, 40, 1358, 11, 40, 3, 40, 3, 40, 7, 40, 1362, 10, 40, 12, 40,
	14, 40, 1365, 11, 40, 3, 40, 3, 40, 7, 40, 1369, 10, 40, 12, 40, 14, 40,
	1372, 11, 40, 3, 40, 5, 40, 1375, 10, 40, 3, 40, 7, 40, 1378, 10, 40, 12,
	40, 14, 40, 1381, 11, 40, 3, 40, 3, 40, 7, 40, 1385, 10, 40, 12, 40, 14,
	40, 1388, 11, 40, 3, 40, 3, 40, 7, 40, 1392, 10, 40, 12, 40, 14, 40, 1395,
	11, 40, 3, 40, 5, 40, 1398, 10, 40, 3, 40, 7, 40, 1401, 10, 40, 12, 40,
	14, 40, 1404, 11, 40, 3, 40, 3, 40, 5, 40, 1408, 10, 40, 3, 41, 3, 41,
	7, 41, 1412, 10, 41, 12, 41, 14, 41, 1415, 11, 41, 3, 41, 3, 41, 7, 41,
	1419, 10, 41, 12, 41, 14, 41, 1422, 11, 41, 3, 41, 3, 41, 7, 41, 1426,
	10, 41, 12, 41, 14, 41, 1429, 11, 41, 3, 41, 7, 41, 1432, 10, 41, 12, 41,
	14, 41, 1435, 11, 41, 3, 41, 7, 41, 1438, 10, 41, 12, 41, 14, 41, 1441,
	11, 41, 3, 41, 5, 41, 1444, 10, 41, 5, 41, 1446, 10, 41, 3, 41, 7, 41,
	1449, 10, 41, 12, 41, 14, 41, 1452, 11, 41, 3, 41, 3, 41, 3, 42, 5, 42,
	1457, 10, 42, 3, 42, 3, 42, 7, 42, 1461, 10, 42, 12, 42, 14, 42, 1464,
	11, 42, 3, 42, 3, 42, 7, 42, 1468, 10, 42, 12, 42, 14, 42, 1471, 11, 42,
	3, 42, 5, 42, 1474, 10, 42, 3, 43, 3, 43, 7, 43, 1478, 10, 43, 12, 43,
	14, 43, 1481, 11, 43, 3, 43, 3, 43, 7, 43, 1485, 10, 43, 12, 43, 14, 43,
	1488, 11, 43, 3, 43, 5, 43, 1491, 10, 43, 3, 44, 3, 44, 7, 44, 1495, 10,
	44, 12, 44, 14, 44, 1498, 11, 44, 3, 44, 3, 44, 7, 44, 1502, 10, 44, 12,
	44, 14, 44, 1505, 11, 44, 3, 44, 3, 44, 3, 45, 5, 45, 1510, 10, 45, 3,
	45, 3, 45, 7, 45, 1514, 10, 45, 12, 45, 14, 45, 1517, 11, 45, 3, 45, 3,
	45, 7, 45, 1521, 10, 45, 12, 45, 14, 45, 1524, 11, 45, 3, 45, 3, 45, 7,
	45, 1528, 10, 45, 12, 45, 14, 45, 1531, 11, 45, 3, 45, 5, 45, 1534, 10,
	45, 3, 45, 7, 45, 1537, 10, 45, 12, 45, 14, 45, 1540, 11, 45, 3, 45, 5,
	45, 1543, 10, 45, 3, 46, 5, 46, 1546, 10, 46, 3, 46, 3, 46, 7, 46, 1550,
	10, 46, 12, 46, 14, 46, 1553, 11, 46, 3, 46, 3, 46, 7, 46, 1557, 10, 46,
	12, 46, 14, 46, 1560, 11, 46, 3, 46, 3, 46, 7, 46, 1564, 10, 46, 12, 46,
	14, 46, 1567, 11, 46, 3, 46, 5, 46, 1570, 10, 46, 3, 46, 7, 46, 1573, 10,
	46, 12, 46, 14, 46, 1576, 11, 46, 3, 46, 5, 46, 1579, 10, 46, 3, 47, 3,
	47, 7, 47, 1583, 10, 47, 12, 47, 14, 47, 1586, 11, 47, 3, 47, 3, 47, 3,
	48, 3, 48, 7, 48, 1592, 10, 48, 12, 48, 14, 48, 1595, 11, 48, 3, 48, 5,
	48, 1598, 10, 48, 3, 48, 7, 48, 1601, 10, 48, 12, 48, 14, 48, 1604, 11,
	48, 3, 48, 3, 48, 7, 48, 1608, 10, 48, 12, 48, 14, 48, 1611, 11, 48, 3,
	48, 5, 48, 1614, 10, 48, 3, 48, 7, 48, 1617, 10, 48, 12, 48, 14, 48, 1620,
	11, 48, 3, 48, 3, 48, 3, 49, 3, 49, 7, 49, 1626, 10, 49, 12, 49, 14, 49,
	1629, 11, 49, 3, 49, 3, 49, 7, 49, 1633, 10, 49, 12, 49, 14, 49, 1636,
	11, 49, 3, 49, 7, 49, 1639, 10, 49, 12, 49, 14, 49, 1642, 11, 49, 3, 49,
	7, 49, 1645, 10, 49, 12, 49, 14, 49, 1648, 11, 49, 3, 49, 5, 49, 1651,
	10, 49, 3, 50, 3, 50, 7, 50, 1655, 10, 50, 12, 50, 14, 50, 1658, 11, 50,
	5, 50, 1660, 10, 50, 3, 50, 3, 50, 7, 50, 1664, 10, 50, 12, 50, 14, 50,
	1667, 11, 50, 3, 50, 5, 50, 1670, 10, 50, 3, 50, 7, 50, 1673, 10, 50, 12,
	50, 14, 50, 1676, 11, 50, 3, 50, 5, 50, 1679, 10, 50, 3, 51, 5, 51, 1682,
	10, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 1688, 10, 51, 3, 52, 3, 52,
	5, 52, 1692, 10, 52, 3, 53, 3, 53, 5, 53, 1696, 10, 53, 3, 53, 7, 53, 1699,
	10, 53, 12, 53, 14, 53, 1702, 11, 53, 3, 53, 6, 53, 1705, 10, 53, 13, 53,
	14, 53, 1706, 3, 54, 3, 54, 3, 55, 3, 55, 7, 55, 1713, 10, 55, 12, 55,
	14, 55, 1716, 11, 55, 3, 55, 3, 55, 7, 55, 1720, 10, 55, 12, 55, 14, 55,
	1723, 11, 55, 3, 55, 7, 55, 1726, 10, 55, 12, 55, 14, 55, 1729, 11, 55,
	3, 56, 3, 56, 7, 56, 1733, 10, 56, 12, 56, 14, 56, 1736, 11, 56, 3, 56,
	5, 56, 1739, 10, 56, 3, 57, 5, 57, 1742, 10, 57, 3, 57, 3, 57, 5, 57, 1746,
	10, 57, 3, 58, 6, 58, 1749, 10, 58, 13, 58, 14, 58, 1750, 3, 59, 3, 59,
	7, 59, 1755, 10, 59, 12, 59, 14, 59, 1758, 11, 59, 3, 59, 5, 59, 1761,
	10, 59, 3, 60, 3, 60, 7, 60, 1765, 10, 60, 12, 60, 14, 60, 1768, 11, 60,
	3, 60, 3, 60, 7, 60, 1772, 10, 60, 12, 60, 14, 60, 1775, 11, 60, 5, 60,
	1777, 10, 60, 3, 60, 3, 60, 7, 60, 1781, 10, 60, 12, 60, 14, 60, 1784,
	11, 60, 3, 60, 3, 60, 7, 60, 1788, 10, 60, 12, 60, 14, 60, 1791, 11, 60,
	3, 60, 3, 60, 3, 61, 3, 61, 7, 61, 1797, 10, 61, 12, 61, 14, 61, 1800,
	11, 61, 3, 61, 3, 61, 5, 61, 1804, 10, 61, 3, 61, 7, 61, 1807, 10, 61,
	12, 61, 14, 61, 1810, 11, 61, 3, 61, 3, 61, 7, 61, 1814, 10, 61, 12, 61,
	14, 61, 1817, 11, 61, 3, 61, 3, 61, 5, 61, 1821, 10, 61, 7, 61, 1823, 10,
	61, 12, 61, 14, 61, 1826, 11, 61, 3, 61, 7, 61, 1829, 10, 61, 12, 61, 14,
	61, 1832, 11, 61, 3, 61, 5, 61, 1835, 10, 61, 3, 61, 7, 61, 1838, 10, 61,
	12, 61, 14, 61, 1841, 11, 61, 3, 61, 3, 61, 3, 62, 3, 62, 7, 62, 1847,
	10, 62, 12, 62, 14, 62, 1850, 11, 62, 3, 62, 3, 62, 7, 62, 1854, 10, 62,
	12, 62, 14, 62, 1857, 11, 62, 3, 62, 3, 62, 3, 63, 5, 63, 1862, 10, 63,
	3, 63, 3, 63, 3, 63, 5, 63, 1867, 10, 63, 3, 64, 3, 64, 7, 64, 1871, 10,
	64, 12, 64, 14, 64, 1874, 11, 64, 3, 64, 3, 64, 5, 64, 1878, 10, 64, 3,
	64, 7, 64, 1881, 10, 64, 12, 64, 14, 64, 1884, 11, 64, 3, 64, 3, 64, 3,
	65, 3, 65, 3, 65, 3, 65, 7, 65, 1892, 10, 65, 12, 65, 14, 65, 1895, 11,
	65, 5, 65, 1897, 10, 65, 3, 65, 5, 65, 1900, 10, 65, 3, 66, 3, 66, 7, 66,
	1904, 10, 66, 12, 66, 14, 66, 1907, 11, 66, 3, 66, 3, 66, 3, 66, 3, 66,
	5, 66, 1913, 10, 66, 3, 67, 3, 67, 3, 67, 7, 67, 1918, 10, 67, 12, 67,
	14, 67, 1921, 11, 67, 3, 68, 3, 68, 5, 68, 1925, 10, 68, 3, 69, 3, 69,
	7, 69, 1929, 10, 69, 12, 69, 14, 69, 1932, 11, 69, 3, 69, 3, 69, 7, 69,
	1936, 10, 69, 12, 69, 14, 69, 1939, 11, 69, 3, 69, 3, 69, 3, 70, 3, 70,
	3, 70, 5, 70, 1946, 10, 70, 3, 71, 3, 71, 7, 71, 1950, 10, 71, 12, 71,
	14, 71, 1953, 11, 71, 3, 71, 3, 71, 7, 71, 1957, 10, 71, 12, 71, 14, 71,
	1960, 11, 71, 3, 71, 3, 71, 5, 71, 1964, 10, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 7, 71, 1970, 10, 71, 12, 71, 14, 71, 1973, 11, 71, 3, 71, 5, 71, 1976,
	10, 71, 3, 72, 3, 72, 7, 72, 1980, 10, 72, 12, 72, 14, 72, 1983, 11, 72,
	3, 72, 3, 72, 3, 72, 3, 72, 7, 72, 1989, 10, 72, 12, 72, 14, 72, 1992,
	11, 72, 3, 72, 3, 72, 5, 72, 1996, 10, 72, 3, 73, 3, 73, 7, 73, 2000, 10,
	73, 12, 73, 14, 73, 2003, 11, 73, 3, 73, 5, 73, 2006, 10, 73, 3, 73, 7,
	73, 2009, 10, 73, 12, 73, 14, 73, 2012, 11, 73, 3, 73, 3, 73, 7, 73, 2016,
	10, 73, 12, 73, 14, 73, 2019, 11, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 2031, 10, 74, 3, 74, 7, 74, 2034,
	10, 74, 12, 74, 14, 74, 2037, 11, 74, 3, 74, 3, 74, 3, 75, 3, 75, 7, 75,
	2043, 10, 75, 12, 75, 14, 75, 2046, 11, 75, 3, 75, 5, 75, 2049, 10, 75,
	3, 76, 6, 76, 2052, 10, 76, 13, 76, 14, 76, 2053, 3, 76, 5, 76, 2057, 10,
	76, 3, 77, 3, 77, 3, 78, 3, 78, 7, 78, 2063, 10, 78, 12, 78, 14, 78, 2066,
	11, 78, 3, 78, 3, 78, 7, 78, 2070, 10, 78, 12, 78, 14, 78, 2073, 11, 78,
	3, 78, 7, 78, 2076, 10, 78, 12, 78, 14, 78, 2079, 11, 78, 3, 79, 3, 79,
	7, 79, 2083, 10, 79, 12, 79, 14, 79, 2086, 11, 79, 3, 79, 3, 79, 7, 79,
	2090, 10, 79, 12, 79, 14, 79, 2093, 11, 79, 3, 79, 7, 79, 2096, 10, 79,
	12, 79, 14, 79, 2099, 11, 79, 3, 80, 3, 80, 3, 80, 7, 80, 2104, 10, 80,
	12, 80, 14, 80, 2107, 11, 80, 3, 80, 3, 80, 7, 80, 2111, 10, 80, 12, 80,
	14, 80, 2114, 11, 80, 3, 81, 3, 81, 3, 81, 7, 81, 2119, 10, 81, 12, 81,
	14, 81, 2122, 11, 81, 3, 81, 3, 81, 7, 81, 2126, 10, 81, 12, 81, 14, 81,
	2129, 11, 81, 3, 82, 3, 82, 7, 82, 2133, 10, 82, 12, 82, 14, 82, 2136,
	11, 82, 3, 83, 3, 83, 3, 83, 7, 83, 2141, 10, 83, 12, 83, 14, 83, 2144,
	11, 83, 3, 83, 3, 83, 3, 83, 3, 83, 7, 83, 2150, 10, 83, 12, 83, 14, 83,
	2153, 11, 83, 3, 83, 3, 83, 7, 83, 2157, 10, 83, 12, 83, 14, 83, 2160,
	11, 83, 3, 84, 3, 84, 7, 84, 2164, 10, 84, 12, 84, 14, 84, 2167, 11, 84,
	3, 84, 3, 84, 7, 84, 2171, 10, 84, 12, 84, 14, 84, 2174, 11, 84, 3, 84,
	3, 84, 7, 84, 2178, 10, 84, 12, 84, 14, 84, 2181, 11, 84, 3, 85, 3, 85,
	3, 85, 3, 86, 3, 86, 3, 86, 7, 86, 2189, 10, 86, 12, 86, 14, 86, 2192,
	11, 86, 3, 86, 3, 86, 7, 86, 2196, 10, 86, 12, 86, 14, 86, 2199, 11, 86,
	3, 87, 3, 87, 3, 87, 7, 87, 2204, 10, 87, 12, 87, 14, 87, 2207, 11, 87,
	3, 87, 7, 87, 2210, 10, 87, 12, 87, 14, 87, 2213, 11, 87, 3, 88, 3, 88,
	3, 88, 7, 88, 2218, 10, 88, 12, 88, 14, 88, 2221, 11, 88, 3, 88, 3, 88,
	7, 88, 2225, 10, 88, 12, 88, 14, 88, 2228, 11, 88, 3, 89, 3, 89, 3, 89,
	7, 89, 2233, 10, 89, 12, 89, 14, 89, 2236, 11, 89, 3, 89, 3, 89, 7, 89,
	2240, 10, 89, 12, 89, 14, 89, 2243, 11, 89, 3, 90, 3, 90, 7, 90, 2247,
	10, 90, 12, 90, 14, 90, 2250, 11, 90, 3, 90, 3, 90, 7, 90, 2254, 10, 90,
	12, 90, 14, 90, 2257, 11, 90, 3, 90, 3, 90, 7, 90, 2261, 10, 90, 12, 90,
	14, 90, 2264, 11, 90, 3, 91, 7, 91, 2267, 10, 91, 12, 91, 14, 91, 2270,
	11, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3, 92, 3, 92, 7, 92, 2278, 10, 92,
	12, 92, 14, 92, 2281, 11, 92, 5, 92, 2283, 10, 92, 3, 93, 3, 93, 7, 93,
	2287, 10, 93, 12, 93, 14, 93, 2290, 11, 93, 3, 94, 3, 94, 3, 94, 3, 94,
	3, 94, 5, 94, 2297, 10, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 2304,
	10, 95, 3, 96, 3, 96, 7, 96, 2308, 10, 96, 12, 96, 14, 96, 2311, 11, 96,
	3, 96, 3, 96, 7, 96, 2315, 10, 96, 12, 96, 14, 96, 2318, 11, 96, 3, 96,
	3, 96, 3, 97, 3, 97, 5, 97, 2324, 10, 97, 3, 98, 3, 98, 7, 98, 2328, 10,
	98, 12, 98, 14, 98, 2331, 11, 98, 3, 98, 3, 98, 7, 98, 2335, 10, 98, 12,
	98, 14, 98, 2338, 11, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 5, 99, 2345,
	10, 99, 3, 100, 3, 100, 7, 100, 2349, 10, 100, 12, 100, 14, 100, 2352,
	11, 100, 3, 100, 3, 100, 7, 100, 2356, 10, 100, 12, 100, 14, 100, 2359,
	11, 100, 3, 100, 3, 100, 7, 100, 2363, 10, 100, 12, 100, 14, 100, 2366,
	11, 100, 3, 100, 7, 100, 2369, 10, 100, 12, 100, 14, 100, 2372, 11, 100,
	3, 100, 7, 100, 2375, 10, 100, 12, 100, 14, 100, 2378, 11, 100, 3, 100,
	5, 100, 2381, 10, 100, 3, 100, 7, 100, 2384, 10, 100, 12, 100, 14, 100,
	2387, 11, 100, 3, 100, 3, 100, 3, 101, 3, 101, 7, 101, 2393, 10, 101, 12,
	101, 14, 101, 2396, 11, 101, 3, 101, 3, 101, 3, 101, 5, 101, 2401, 10,
	101, 3, 102, 5, 102, 2404, 10, 102, 3, 102, 5, 102, 2407, 10, 102, 3, 102,
	3, 102, 5, 102, 2411, 10, 102, 3, 103, 7, 103, 2414, 10, 103, 12, 103,
	14, 103, 2417, 11, 103, 3, 103, 5, 103, 2420, 10, 103, 3, 103, 7, 103,
	2423, 10, 103, 12, 103, 14, 103, 2426, 11, 103, 3, 103, 3, 103, 3, 104,
	3, 104, 7, 104, 2432, 10, 104, 12, 104, 14, 104, 2435, 11, 104, 3, 104,
	3, 104, 7, 104, 2439, 10, 104, 12, 104, 14, 104, 2442, 11, 104, 3, 104,
	3, 104, 7, 104, 2446, 10, 104, 12, 104, 14, 104, 2449, 11, 104, 3, 104,
	7, 104, 2452, 10, 104, 12, 104, 14, 104, 2455, 11, 104, 3, 104, 7, 104,
	2458, 10, 104, 12, 104, 14, 104, 2461, 11, 104, 3, 104, 5, 104, 2464, 10,
	104, 3, 104, 7, 104, 2467, 10, 104, 12, 104, 14, 104, 2470, 11, 104, 3,
	104, 3, 104, 3, 105, 3, 105, 7, 105, 2476, 10, 105, 12, 105, 14, 105, 2479,
	11, 105, 3, 105, 3, 105, 7, 105, 2483, 10, 105, 12, 105, 14, 105, 2486,
	11, 105, 3, 105, 3, 105, 7, 105, 2490, 10, 105, 12, 105, 14, 105, 2493,
	11, 105, 3, 105, 7, 105, 2496, 10, 105, 12, 105, 14, 105, 2499, 11, 105,
	3, 105, 7, 105, 2502, 10, 105, 12, 105, 14, 105, 2505, 11, 105, 3, 105,
	5, 105, 2508, 10, 105, 3, 105, 7, 105, 2511, 10, 105, 12, 105, 14, 105,
	2514, 11, 105, 5, 105, 2516, 10, 105, 3, 105, 3, 105, 3, 106, 5, 106, 2521,
	10, 106, 3, 106, 7, 106, 2524, 10, 106, 12, 106, 14, 106, 2527, 11, 106,
	3, 106, 3, 106, 7, 106, 2531, 10, 106, 12, 106, 14, 106, 2534, 11, 106,
	3, 106, 3, 106, 7, 106, 2538, 10, 106, 12, 106, 14, 106, 2541, 11, 106,
	5, 106, 2543, 10, 106, 3, 106, 5, 106, 2546, 10, 106, 3, 106, 7, 106, 2549,
	10, 106, 12, 106, 14, 106, 2552, 11, 106, 3, 106, 3, 106, 3, 107, 3, 107,
	3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107,
	3, 107, 3, 107, 3, 107, 5, 107, 2570, 10, 107, 3, 108, 3, 108, 7, 108,
	2574, 10, 108, 12, 108, 14, 108, 2577, 11, 108, 3, 108, 3, 108, 7, 108,
	2581, 10, 108, 12, 108, 14, 108, 2584, 11, 108, 3, 108, 3, 108, 3, 109,
	3, 109, 7, 109, 2590, 10, 109, 12, 109, 14, 109, 2593, 11, 109, 3, 109,
	3, 109, 7, 109, 2597, 10, 109, 12, 109, 14, 109, 2600, 11, 109, 3, 109,
	3, 109, 7, 109, 2604, 10, 109, 12, 109, 14, 109, 2607, 11, 109, 3, 109,
	7, 109, 2610, 10, 109, 12, 109, 14, 109, 2613, 11, 109, 3, 109, 7, 109,
	2616, 10, 109, 12, 109, 14, 109, 2619, 11, 109, 3, 109, 5, 109, 2622, 10,
	109, 3, 109, 7, 109, 2625, 10, 109, 12, 109, 14, 109, 2628, 11, 109, 5,
	109, 2630, 10, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 111, 3, 111, 5,
	111, 2638, 10, 111, 3, 112, 3, 112, 3, 112, 7, 112, 2643, 10, 112, 12,
	112, 14, 112, 2646, 11, 112, 3, 112, 3, 112, 3, 113, 3, 113, 3, 113, 3,
	113, 7, 113, 2654, 10, 113, 12, 113, 14, 113, 2657, 11, 113, 3, 113, 3,
	113, 3, 114, 3, 114, 3, 115, 3, 115, 7, 115, 2665, 10, 115, 12, 115, 14,
	115, 2668, 11, 115, 3, 115, 3, 115, 7, 115, 2672, 10, 115, 12, 115, 14,
	115, 2675, 11, 115, 3, 115, 3, 115, 3, 116, 3, 116, 3, 117, 3, 117, 7,
	117, 2683, 10, 117, 12, 117, 14, 117, 2686, 11, 117, 3, 117, 3, 117, 7,
	117, 2690, 10, 117, 12, 117, 14, 117, 2693, 11, 117, 3, 117, 3, 117, 3,
	118, 3, 118, 7, 118, 2699, 10, 118, 12, 118, 14, 118, 2702, 11, 118, 3,
	118, 5, 118, 2705, 10, 118, 3, 118, 7, 118, 2708, 10, 118, 12, 118, 14,
	118, 2711, 11, 118, 3, 118, 3, 118, 7, 118, 2715, 10, 118, 12, 118, 14,
	118, 2718, 11, 118, 5, 118, 2720, 10, 118, 3, 118, 3, 118, 7, 118, 2724,
	10, 118, 12, 118, 14, 118, 2727, 11, 118, 3, 118, 3, 118, 3, 119, 3, 119,
	7, 119, 2733, 10, 119, 12, 119, 14, 119, 2736, 11, 119, 3, 119, 3, 119,
	7, 119, 2740, 10, 119, 12, 119, 14, 119, 2743, 11, 119, 3, 119, 7, 119,
	2746, 10, 119, 12, 119, 14, 119, 2749, 11, 119, 3, 119, 7, 119, 2752, 10,
	119, 12, 119, 14, 119, 2755, 11, 119, 3, 119, 5, 119, 2758, 10, 119, 3,
	120, 3, 120, 3, 120, 7, 120, 2763, 10, 120, 12, 120, 14, 120, 2766, 11,
	120, 3, 120, 3, 120, 7, 120, 2770, 10, 120, 12, 120, 14, 120, 2773, 11,
	120, 3, 120, 5, 120, 2776, 10, 120, 5, 120, 2778, 10, 120, 3, 121, 3, 121,
	7, 121, 2782, 10, 121, 12, 121, 14, 121, 2785, 11, 121, 3, 121, 3, 121,
	7, 121, 2789, 10, 121, 12, 121, 14, 121, 2792, 11, 121, 3, 121, 3, 121,
	5, 121, 2796, 10, 121, 3, 121, 7, 121, 2799, 10, 121, 12, 121, 14, 121,
	2802, 11, 121, 3, 121, 3, 121, 7, 121, 2806, 10, 121, 12, 121, 14, 121,
	2809, 11, 121, 3, 121, 3, 121, 7, 121, 2813, 10, 121, 12, 121, 14, 121,
	2816, 11, 121, 3, 121, 5, 121, 2819, 10, 121, 3, 121, 7, 121, 2822, 10,
	121, 12, 121, 14, 121, 2825, 11, 121, 3, 121, 5, 121, 2828, 10, 121, 3,
	121, 7, 121, 2831, 10, 121, 12, 121, 14, 121, 2834, 11, 121, 3, 121, 5,
	121, 2837, 10, 121, 3, 122, 3, 122, 5, 122, 2841, 10, 122, 3, 123, 3, 123,
	7, 123, 2845, 10, 123, 12, 123, 14, 123, 2848, 11, 123, 3, 123, 3, 123,
	7, 123, 2852, 10, 123, 12, 123, 14, 123, 2855, 11, 123, 3, 123, 3, 123,
	7, 123, 2859, 10, 123, 12, 123, 14, 123, 2862, 11, 123, 5, 123, 2864, 10,
	123, 3, 123, 7, 123, 2867, 10, 123, 12, 123, 14, 123, 2870, 11, 123, 3,
	123, 5, 123, 2873, 10, 123, 3, 124, 3, 124, 3, 125, 3, 125, 3, 125, 7,
	125, 2880, 10, 125, 12, 125, 14, 125, 2883, 11, 125, 3, 125, 3, 125, 7,
	125, 2887, 10, 125, 12, 125, 14, 125, 2890, 11, 125, 3, 125, 3, 125, 5,
	125, 2894, 10, 125, 3, 125, 3, 125, 5, 125, 2898, 10, 125, 3, 125, 5, 125,
	2901, 10, 125, 3, 126, 3, 126, 7, 126, 2905, 10, 126, 12, 126, 14, 126,
	2908, 11, 126, 3, 126, 3, 126, 7, 126, 2912, 10, 126, 12, 126, 14, 126,
	2915, 11, 126, 3, 126, 3, 126, 7, 126, 2919, 10, 126, 12, 126, 14, 126,
	2922, 11, 126, 3, 126, 3, 126, 7, 126, 2926, 10, 126, 12, 126, 14, 126,
	2929, 11, 126, 3, 126, 3, 126, 5, 126, 2933, 10, 126, 3, 126, 7, 126, 2936,
	10, 126, 12, 126, 14, 126, 2939, 11, 126, 3, 126, 5, 126, 2942, 10, 126,
	3, 126, 7, 126, 2945, 10, 126, 12, 126, 14, 126, 2948, 11, 126, 3, 126,
	3, 126, 7, 126, 2952, 10, 126, 12, 126, 14, 126, 2955, 11, 126, 3, 126,
	3, 126, 5, 126, 2959, 10, 126, 3, 126, 5, 126, 2962, 10, 126, 3, 127, 3,
	127, 7, 127, 2966, 10, 127, 12, 127, 14, 127, 2969, 11, 127, 3, 127, 7,
	127, 2972, 10, 127, 12, 127, 14, 127, 2975, 11, 127, 3, 127, 3, 127, 7,
	127, 2979, 10, 127, 12, 127, 14, 127, 2982, 11, 127, 3, 127, 3, 127, 7,
	127, 2986, 10, 127, 12, 127, 14, 127, 2989, 11, 127, 3, 127, 3, 127, 7,
	127, 2993, 10, 127, 12, 127, 14, 127, 2996, 11, 127, 5, 127, 2998, 10,
	127, 3, 127, 3, 127, 3, 127, 3, 128, 3, 128, 7, 128, 3005, 10, 128, 12,
	128, 14, 128, 3008, 11, 128, 3, 128, 5, 128, 3011, 10, 128, 3, 128, 7,
	128, 3014, 10, 128, 12, 128, 14, 128, 3017, 11, 128, 3, 128, 3, 128, 7,
	128, 3021, 10, 128, 12, 128, 14, 128, 3024, 11, 128, 3, 128, 3, 128, 7,
	128, 3028, 10, 128, 12, 128, 14, 128, 3031, 11, 128, 7, 128, 3033, 10,
	128, 12, 128, 14, 128, 3036, 11, 128, 3, 128, 7, 128, 3039, 10, 128, 12,
	128, 14, 128, 3042, 11, 128, 3, 128, 3, 128, 3, 129, 3, 129, 7, 129, 3048,
	10, 129, 12, 129, 14, 129, 3051, 11, 129, 3, 129, 3, 129, 7, 129, 3055,
	10, 129, 12, 129, 14, 129, 3058, 11, 129, 3, 129, 7, 129, 3061, 10, 129,
	12, 129, 14, 129, 3064, 11, 129, 3, 129, 7, 129, 3067, 10, 129, 12, 129,
	14, 129, 3070, 11, 129, 3, 129, 5, 129, 3073, 10, 129, 3, 129, 7, 129,
	3076, 10, 129, 12, 129, 14, 129, 3079, 11, 129, 3, 129, 3, 129, 7, 129,
	3083, 10, 129, 12, 129, 14, 129, 3086, 11, 129, 3, 129, 3, 129, 5, 129,
	3090, 10, 129, 3, 129, 3, 129, 7, 129, 3094, 10, 129, 12, 129, 14, 129,
	3097, 11, 129, 3, 129, 3, 129, 7, 129, 3101, 10, 129, 12, 129, 14, 129,
	3104, 11, 129, 3, 129, 3, 129, 5, 129, 3108, 10, 129, 5, 129, 3110, 10,
	129, 3, 130, 3, 130, 3, 130, 5, 130, 3115, 10, 130, 3, 131, 3, 131, 7,
	131, 3119, 10, 131, 12, 131, 14, 131, 3122, 11, 131, 3, 131, 3, 131, 3,
	132, 3, 132, 7, 132, 3128, 10, 132, 12, 132, 14, 132, 3131, 11, 132, 3,
	132, 3, 132, 3, 133, 3, 133, 7, 133, 3137, 10, 133, 12, 133, 14, 133, 3140,
	11, 133, 3, 133, 3, 133, 7, 133, 3144, 10, 133, 12, 133, 14, 133, 3147,
	11, 133, 3, 133, 6, 133, 3150, 10, 133, 13, 133, 14, 133, 3151, 3, 133,
	7, 133, 3155, 10, 133, 12, 133, 14, 133, 3158, 11, 133, 3, 133, 5, 133,
	3161, 10, 133, 3, 133, 7, 133, 3164, 10, 133, 12, 133, 14, 133, 3167, 11,
	133, 3, 133, 5, 133, 3170, 10, 133, 3, 134, 3, 134, 7, 134, 3174, 10, 134,
	12, 134, 14, 134, 3177, 11, 134, 3, 134, 3, 134, 7, 134, 3181, 10, 134,
	12, 134, 14, 134, 3184, 11, 134, 3, 134, 3, 134, 3, 134, 3, 134, 7, 134,
	3190, 10, 134, 12, 134, 14, 134, 3193, 11, 134, 3, 134, 5, 134, 3196, 10,
	134, 3, 134, 3, 134, 7, 134, 3200, 10, 134, 12, 134, 14, 134, 3203, 11,
	134, 3, 134, 3, 134, 3, 135, 3, 135, 7, 135, 3209, 10, 135, 12, 135, 14,
	135, 3212, 11, 135, 3, 135, 3, 135, 3, 136, 3, 136, 7, 136, 3218, 10, 136,
	12, 136, 14, 136, 3221, 11, 136, 3, 136, 3, 136, 3, 136, 5, 136, 3226,
	10, 136, 3, 136, 3, 136, 3, 136, 3, 136, 5, 136, 3232, 10, 136, 3, 137,
	5, 137, 3235, 10, 137, 3, 137, 3, 137, 7, 137, 3239, 10, 137, 12, 137,
	14, 137, 3242, 11, 137, 3, 137, 3, 137, 5, 137, 3246, 10, 137, 3, 138,
	3, 138, 3, 139, 3, 139, 3, 140, 3, 140, 3, 141, 3, 141, 3, 142, 3, 142,
	3, 143, 3, 143, 3, 144, 3, 144, 3, 145, 3, 145, 3, 146, 3, 146, 3, 146,
	3, 146, 3, 146, 5, 146, 3269, 10, 146, 3, 147, 3, 147, 3, 147, 3, 147,
	5, 147, 3275, 10, 147, 3, 148, 3, 148, 3, 149, 7, 149, 3280, 10, 149, 12,
	149, 14, 149, 3283, 11, 149, 3, 149, 3, 149, 7, 149, 3287, 10, 149, 12,
	149, 14, 149, 3290, 11, 149, 3, 149, 3, 149, 5, 149, 3294, 10, 149, 3,
	150, 3, 150, 3, 150, 3, 151, 3, 151, 6, 151, 3301, 10, 151, 13, 151, 14,
	151, 3302, 3, 152, 3, 152, 6, 152, 3307, 10, 152, 13, 152, 14, 152, 3308,
	3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 5, 153,
	3319, 10, 153, 3, 153, 7, 153, 3322, 10, 153, 12, 153, 14, 153, 3325, 11,
	153, 3, 154, 6, 154, 3328, 10, 154, 13, 154, 14, 154, 3329, 3, 155, 3,
	155, 3, 155, 7, 155, 3335, 10, 155, 12, 155, 14, 155, 3338, 11, 155, 5,
	155, 3340, 10, 155, 3, 156, 3, 156, 3, 157, 3, 157, 3, 158, 3, 158, 3,
	159, 3, 159, 3, 160, 6, 160, 3351, 10, 160, 13, 160, 14, 160, 3352, 3,
	161, 3, 161, 7, 161, 3357, 10, 161, 12, 161, 14, 161, 3360, 11, 161, 3,
	161, 3, 161, 7, 161, 3364, 10, 161, 12, 161, 14, 161, 3367, 11, 161, 3,
	161, 5, 161, 3370, 10, 161, 3, 162, 3, 162, 3, 163, 3, 163, 3, 164, 3,
	164, 3, 165, 3, 165, 3, 166, 3, 166, 3, 167, 3, 167, 3, 168, 3, 168, 5,
	168, 3386, 10, 168, 3, 168, 7, 168, 3389, 10, 168, 12, 168, 14, 168, 3392,
	11, 168, 3, 169, 3, 169, 7, 169, 3396, 10, 169, 12, 169, 14, 169, 3399,
	11, 169, 3, 169, 3, 169, 5, 169, 3403, 10, 169, 3, 169, 3, 169, 3, 170,
	3, 170, 7, 170, 3409, 10, 170, 12, 170, 14, 170, 3412, 11, 170, 3, 170,
	3, 170, 5, 170, 3416, 10, 170, 3, 170, 3, 170, 6, 170, 3420, 10, 170, 13,
	170, 14, 170, 3421, 3, 170, 3, 170, 3, 171, 3, 171, 3, 171, 7, 171, 3429,
	10, 171, 12, 171, 14, 171, 3432, 11, 171, 3, 171, 3, 171, 3, 172, 3, 172,
	5, 172, 3438, 10, 172, 3, 173, 3, 173, 3, 174, 3, 174, 7, 174, 3444, 10,
	174, 12, 174, 14, 174, 3447, 11, 174, 3, 174, 3, 174, 7, 174, 3451, 10,
	174, 12, 174, 14, 174, 3454, 11, 174, 3, 174, 2, 2, 175, 2, 4, 6, 8, 10,
	12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
	48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
	84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
	116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
	146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
	176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
	206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
	236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264,
	266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294,
	296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324,
	326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 2, 32, 4, 2, 42,
	42, 44, 44, 3, 2, 78, 79, 3, 2, 85, 86, 3, 2, 46, 47, 3, 2, 42, 43, 4,
	2, 7, 7, 29, 29, 4, 2, 137, 137, 140, 147, 3, 2, 161, 163, 3, 2, 166, 168,
	4, 2, 61, 61, 85, 85, 4, 2, 58, 58, 99, 99, 3, 2, 31, 35, 4, 2, 52, 53,
	55, 56, 3, 2, 48, 51, 4, 2, 104, 104, 106, 106, 4, 2, 103, 103, 105, 105,
	3, 2, 20, 21, 3, 2, 17, 19, 4, 2, 54, 54, 102, 102, 3, 2, 26, 27, 3, 2,
	113, 118, 4, 2, 125, 125, 130, 130, 3, 2, 109, 112, 4, 2, 104, 104, 107,
	107, 3, 2, 119, 124, 3, 2, 126, 128, 3, 2, 131, 133, 3, 2, 135, 136, 3,
	2, 64, 71, 9, 2, 63, 71, 73, 73, 81, 84, 88, 88, 93, 94, 107, 136, 148,
	148, 2, 3868, 2, 349, 3, 2, 2, 2, 4, 374, 3, 2, 2, 2, 6, 400, 3, 2, 2,
	2, 8, 406, 3, 2, 2, 2, 10, 443, 3, 2, 2, 2, 12, 448, 3, 2, 2, 2, 14, 451,
	3, 2, 2, 2, 16, 461, 3, 2, 2, 2, 18, 464, 3, 2, 2, 2, 20, 469, 3, 2, 2,
	2, 22, 508, 3, 2, 2, 2, 24, 511, 3, 2, 2, 2, 26, 602, 3, 2, 2, 2, 28, 606,
	3, 2, 2, 2, 30, 622, 3, 2, 2, 2, 32, 669, 3, 2, 2, 2, 34, 705, 3, 2, 2,
	2, 36, 729, 3, 2, 2, 2, 38, 731, 3, 2, 2, 2, 40, 737, 3, 2, 2, 2, 42, 750,
	3, 2, 2, 2, 44, 767, 3, 2, 2, 2, 46, 812, 3, 2, 2, 2, 48, 837, 3, 2, 2,
	2, 50, 867, 3, 2, 2, 2, 52, 892, 3, 2, 2, 2, 54, 899, 3, 2, 2, 2, 56, 901,
	3, 2, 2, 2, 58, 911, 3, 2, 2, 2, 60, 955, 3, 2, 2, 2, 62, 1002, 3, 2, 2,
	2, 64, 1022, 3, 2, 2, 2, 66, 1108, 3, 2, 2, 2, 68, 1113, 3, 2, 2, 2, 70,
	1139, 3, 2, 2, 2, 72, 1184, 3, 2, 2, 2, 74, 1297, 3, 2, 2, 2, 76, 1307,
	3, 2, 2, 2, 78, 1350, 3, 2, 2, 2, 80, 1409, 3, 2, 2, 2, 82, 1456, 3, 2,
	2, 2, 84, 1475, 3, 2, 2, 2, 86, 1492, 3, 2, 2, 2, 88, 1509, 3, 2, 2, 2,
	90, 1545, 3, 2, 2, 2, 92, 1580, 3, 2, 2, 2, 94, 1589, 3, 2, 2, 2, 96, 1623,
	3, 2, 2, 2, 98, 1659, 3, 2, 2, 2, 100, 1681, 3, 2, 2, 2, 102, 1691, 3,
	2, 2, 2, 104, 1695, 3, 2, 2, 2, 106, 1708, 3, 2, 2, 2, 108, 1710, 3, 2,
	2, 2, 110, 1730, 3, 2, 2, 2, 112, 1745, 3, 2, 2, 2, 114, 1748, 3, 2, 2,
	2, 116, 1760, 3, 2, 2, 2, 118, 1776, 3, 2, 2, 2, 120, 1794, 3, 2, 2, 2,
	122, 1844, 3, 2, 2, 2, 124, 1861, 3, 2, 2, 2, 126, 1868, 3, 2, 2, 2, 128,
	1896, 3, 2, 2, 2, 130, 1905, 3, 2, 2, 2, 132, 1914, 3, 2, 2, 2, 134, 1924,
	3, 2, 2, 2, 136, 1926, 3, 2, 2, 2, 138, 1945, 3, 2, 2, 2, 140, 1947, 3,
	2, 2, 2, 142, 1977, 3, 2, 2, 2, 144, 1997, 3, 2, 2, 2, 146, 2030, 3, 2,
	2, 2, 148, 2048, 3, 2, 2, 2, 150, 2056, 3, 2, 2, 2, 152, 2058, 3, 2, 2,
	2, 154, 2060, 3, 2, 2, 2, 156, 2080, 3, 2, 2, 2, 158, 2100, 3, 2, 2, 2,
	160, 2115, 3, 2, 2, 2, 162, 2130, 3, 2, 2, 2, 164, 2137, 3, 2, 2, 2, 166,
	2161, 3, 2, 2, 2, 168, 2182, 3, 2, 2, 2, 170, 2185, 3, 2, 2, 2, 172, 2200,
	3, 2, 2, 2, 174, 2214, 3, 2, 2, 2, 176, 2229, 3, 2, 2, 2, 178, 2244, 3,
	2, 2, 2, 180, 2268, 3, 2, 2, 2, 182, 2282, 3, 2, 2, 2, 184, 2284, 3, 2,
	2, 2, 186, 2296, 3, 2, 2, 2, 188, 2303, 3, 2, 2, 2, 190, 2305, 3, 2, 2,
	2, 192, 2323, 3, 2, 2, 2, 194, 2325, 3, 2, 2, 2, 196, 2344, 3, 2, 2, 2,
	198, 2346, 3, 2, 2, 2, 200, 2390, 3, 2, 2, 2, 202, 2403, 3, 2, 2, 2, 204,
	2415, 3, 2, 2, 2, 206, 2429, 3, 2, 2, 2, 208, 2473, 3, 2, 2, 2, 210, 2520,
	3, 2, 2, 2, 212, 2569, 3, 2, 2, 2, 214, 2571, 3, 2, 2, 2, 216, 2587, 3,
	2, 2, 2, 218, 2633, 3, 2, 2, 2, 220, 2637, 3, 2, 2, 2, 222, 2639, 3, 2,
	2, 2, 224, 2649, 3, 2, 2, 2, 226, 2660, 3, 2, 2, 2, 228, 2662, 3, 2, 2,
	2, 230, 2678, 3, 2, 2, 2, 232, 2680, 3, 2, 2, 2, 234, 2696, 3, 2, 2, 2,
	236, 2730, 3, 2, 2, 2, 238, 2777, 3, 2, 2, 2, 240, 2779, 3, 2, 2, 2, 242,
	2840, 3, 2, 2, 2, 244, 2842, 3, 2, 2, 2, 246, 2874, 3, 2, 2, 2, 248, 2900,
	3, 2, 2, 2, 250, 2902, 3, 2, 2, 2, 252, 2963, 3, 2, 2, 2, 254, 3002, 3,
	2, 2, 2, 256, 3109, 3, 2, 2, 2, 258, 3114, 3, 2, 2, 2, 260, 3116, 3, 2,
	2, 2, 262, 3125, 3, 2, 2, 2, 264, 3134, 3, 2, 2, 2, 266, 3171, 3, 2, 2,
	2, 268, 3206, 3, 2, 2, 2, 270, 3231, 3, 2, 2, 2, 272, 3234, 3, 2, 2, 2,
	274, 3247, 3, 2, 2, 2, 276, 3249, 3, 2, 2, 2, 278, 3251, 3, 2, 2, 2, 280,
	3253, 3, 2, 2, 2, 282, 3255, 3, 2, 2, 2, 284, 3257, 3, 2, 2, 2, 286, 3259,
	3, 2, 2, 2, 288, 3261, 3, 2, 2, 2, 290, 3268, 3, 2, 2, 2, 292, 3274, 3,
	2, 2, 2, 294, 3276, 3, 2, 2, 2, 296, 3293, 3, 2, 2, 2, 298, 3295, 3, 2,
	2, 2, 300, 3300, 3, 2, 2, 2, 302, 3306, 3, 2, 2, 2, 304, 3318, 3, 2, 2,
	2, 306, 3327, 3, 2, 2, 2, 308, 3339, 3, 2, 2, 2, 310, 3341, 3, 2, 2, 2,
	312, 3343, 3, 2, 2, 2, 314, 3345, 3, 2, 2, 2, 316, 3347, 3, 2, 2, 2, 318,
	3350, 3, 2, 2, 2, 320, 3369, 3, 2, 2, 2, 322, 3371, 3, 2, 2, 2, 324, 3373,
	3, 2, 2, 2, 326, 3375, 3, 2, 2, 2, 328, 3377, 3, 2, 2, 2, 330, 3379, 3,
	2, 2, 2, 332, 3381, 3, 2, 2, 2, 334, 3385, 3, 2, 2, 2, 336, 3402, 3, 2,
	2, 2, 338, 3415, 3, 2, 2, 2, 340, 3425, 3, 2, 2, 2, 342, 3437, 3, 2, 2,
	2, 344, 3439, 3, 2, 2, 2, 346, 3441, 3, 2, 2, 2, 348, 350, 5, 6, 4, 2,
	349, 348, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 354, 3, 2, 2, 2, 351,
	353, 7, 7, 2, 2, 352, 351, 3, 2, 2, 2, 353, 356, 3, 2, 2, 2, 354, 352,
	3, 2, 2, 2, 354, 355, 3, 2, 2, 2, 355, 360, 3, 2, 2, 2, 356, 354, 3, 2,
	2, 2, 357, 359, 5, 8, 5, 2, 358, 357, 3, 2, 2, 2, 359, 362, 3, 2, 2, 2,
	360, 358, 3, 2, 2, 2, 360, 361, 3, 2, 2, 2, 361, 363, 3, 2, 2, 2, 362,
	360, 3, 2, 2, 2, 363, 364, 5, 10, 6, 2, 364, 368, 5, 12, 7, 2, 365, 367,
	5, 18, 10, 2, 366, 365, 3, 2, 2, 2, 367, 370, 3, 2, 2, 2, 368, 366, 3,
	2, 2, 2, 368, 369, 3, 2, 2, 2, 369, 371, 3, 2, 2, 2, 370, 368, 3, 2, 2,
	2, 371, 372, 7, 2, 2, 3, 372, 3, 3, 2, 2, 2, 373, 375, 5, 6, 4, 2, 374,
	373, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 379, 3, 2, 2, 2, 376, 378,
	7, 7, 2, 2, 377, 376, 3, 2, 2, 2, 378, 381, 3, 2, 2, 2, 379, 377, 3, 2,
	2, 2, 379, 380, 3, 2, 2, 2, 380, 385, 3, 2, 2, 2, 381, 379, 3, 2, 2, 2,
	382, 384, 5, 8, 5, 2, 383, 382, 3, 2, 2, 2, 384, 387, 3, 2, 2, 2, 385,
	383, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 388, 3, 2, 2, 2, 387, 385,
	3, 2, 2, 2, 388, 389, 5, 10, 6, 2, 389, 395, 5, 12, 7, 2, 390, 391, 5,
	130, 66, 2, 391, 392, 5, 148, 75, 2, 392, 394, 3, 2, 2, 2, 393, 390, 3,
	2, 2, 2, 394, 397, 3, 2, 2, 2, 395, 393, 3, 2, 2, 2, 395, 396, 3, 2, 2,
	2, 396, 398, 3, 2, 2, 2, 397, 395, 3, 2, 2, 2, 398, 399, 7, 2, 2, 3, 399,
	5, 3, 2, 2, 2, 400, 402, 7, 3, 2, 2, 401, 403, 7, 7, 2, 2, 402, 401, 3,
	2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2, 404, 405, 3, 2, 2,
	2, 405, 7, 3, 2, 2, 2, 406, 407, 9, 2, 2, 2, 407, 411, 7, 63, 2, 2, 408,
	410, 7, 7, 2, 2, 409, 408, 3, 2, 2, 2, 410, 413, 3, 2, 2, 2, 411, 409,
	3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412, 414, 3, 2, 2, 2, 413, 411, 3, 2,
	2, 2, 414, 418, 7, 28, 2, 2, 415, 417, 7, 7, 2, 2, 416, 415, 3, 2, 2, 2,
	417, 420, 3, 2, 2, 2, 418, 416, 3, 2, 2, 2, 418, 419, 3, 2, 2, 2, 419,
	430, 3, 2, 2, 2, 420, 418, 3, 2, 2, 2, 421, 423, 7, 13, 2, 2, 422, 424,
	5, 342, 172, 2, 423, 422, 3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 423, 3,
	2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 427, 3, 2, 2, 2, 427, 428, 7, 14, 2,
	2, 428, 431, 3, 2, 2, 2, 429, 431, 5, 342, 172, 2, 430, 421, 3, 2, 2, 2,
	430, 429, 3, 2, 2, 2, 431, 435, 3, 2, 2, 2, 432, 434, 7, 7, 2, 2, 433,
	432, 3, 2, 2, 2, 434, 437, 3, 2, 2, 2, 435, 433, 3, 2, 2, 2, 435, 436,
	3, 2, 2, 2, 436, 9, 3, 2, 2, 2, 437, 435, 3, 2, 2, 2, 438, 439, 7, 72,
	2, 2, 439, 441, 5, 346, 174, 2, 440, 442, 5, 148, 75, 2, 441, 440, 3, 2,
	2, 2, 441, 442, 3, 2, 2, 2, 442, 444, 3, 2, 2, 2, 443, 438, 3, 2, 2, 2,
	443, 444, 3, 2, 2, 2, 444, 11, 3, 2, 2, 2, 445, 447, 5, 14, 8, 2, 446,
	445, 3, 2, 2, 2, 447, 450, 3, 2, 2, 2, 448, 446, 3, 2, 2, 2, 448, 449,
	3, 2, 2, 2, 449, 13, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 451, 452, 7, 73,
	2, 2, 452, 456, 5, 346, 174, 2, 453, 454, 7, 9, 2, 2, 454, 457, 7, 17,
	2, 2, 455, 457, 5, 16, 9, 2, 456, 453, 3, 2, 2, 2, 456, 455, 3, 2, 2, 2,
	456, 457, 3, 2, 2, 2, 457, 459, 3, 2, 2, 2, 458, 460, 5, 148, 75, 2, 459,
	458, 3, 2, 2, 2, 459, 460, 3, 2, 2, 2, 460, 15, 3, 2, 2, 2, 461, 462, 7,
	102, 2, 2, 462, 463, 5, 344, 173, 2, 463, 17, 3, 2, 2, 2, 464, 466, 5,
	22, 12, 2, 465, 467, 5, 150, 76, 2, 466, 465, 3, 2, 2, 2, 466, 467, 3,
	2, 2, 2, 467, 19, 3, 2, 2, 2, 468, 470, 5, 300, 151, 2, 469, 468, 3, 2,
	2, 2, 469, 470, 3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471, 475, 7, 80, 2, 2,
	472, 474, 7, 7, 2, 2, 473, 472, 3, 2, 2, 2, 474, 477, 3, 2, 2, 2, 475,
	473, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 478, 3, 2, 2, 2, 477, 475,
	3, 2, 2, 2, 478, 486, 5, 344, 173, 2, 479, 481, 7, 7, 2, 2, 480, 479, 3,
	2, 2, 2, 481, 484, 3, 2, 2, 2, 482, 480, 3, 2, 2, 2, 482, 483, 3, 2, 2,
	2, 483, 485, 3, 2, 2, 2, 484, 482, 3, 2, 2, 2, 485, 487, 5, 44, 23, 2,
	486, 482, 3, 2, 2, 2, 486, 487, 3, 2, 2, 2, 487, 491, 3, 2, 2, 2, 488,
	490, 7, 7, 2, 2, 489, 488, 3, 2, 2, 2, 490, 493, 3, 2, 2, 2, 491, 489,
	3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 494, 3, 2, 2, 2, 493, 491, 3, 2,
	2, 2, 494, 498, 7, 30, 2, 2, 495, 497, 7, 7, 2, 2, 496, 495, 3, 2, 2, 2,
	497, 500, 3, 2, 2, 2, 498, 496, 3, 2, 2, 2, 498, 499, 3, 2, 2, 2, 499,
	501, 3, 2, 2, 2, 500, 498, 3, 2, 2, 2, 501, 502, 5, 100, 51, 2, 502, 21,
	3, 2, 2, 2, 503, 509, 5, 24, 13, 2, 504, 509, 5, 88, 45, 2, 505, 509, 5,
	64, 33, 2, 506, 509, 5, 72, 37, 2, 507, 509, 5, 20, 11, 2, 508, 503, 3,
	2, 2, 2, 508, 504, 3, 2, 2, 2, 508, 505, 3, 2, 2, 2, 508, 506, 3, 2, 2,
	2, 508, 507, 3, 2, 2, 2, 509, 23, 3, 2, 2, 2, 510, 512, 5, 300, 151, 2,
	511, 510, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512, 524, 3, 2, 2, 2, 513,
	525, 7, 74, 2, 2, 514, 518, 7, 76, 2, 2, 515, 517, 7, 7, 2, 2, 516, 515,
	3, 2, 2, 2, 517, 520, 3, 2, 2, 2, 518, 516, 3, 2, 2, 2, 518, 519, 3, 2,
	2, 2, 519, 522, 3, 2, 2, 2, 520, 518, 3, 2, 2, 2, 521, 514, 3, 2, 2, 2,
	521, 522, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 525, 7, 75, 2, 2, 524,
	513, 3, 2, 2, 2, 524, 521, 3, 2, 2, 2, 525, 529, 3, 2, 2, 2, 526, 528,
	7, 7, 2, 2, 527, 526, 3, 2, 2, 2, 528, 531, 3, 2, 2, 2, 529, 527, 3, 2,
	2, 2, 529, 530, 3, 2, 2, 2, 530, 532, 3, 2, 2, 2, 531, 529, 3, 2, 2, 2,
	532, 540, 5, 344, 173, 2, 533, 535, 7, 7, 2, 2, 534, 533, 3, 2, 2, 2, 535,
	538, 3, 2, 2, 2, 536, 534, 3, 2, 2, 2, 536, 537, 3, 2, 2, 2, 537, 539,
	3, 2, 2, 2, 538, 536, 3, 2, 2, 2, 539, 541, 5, 44, 23, 2, 540, 536, 3,
	2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 549, 3, 2, 2, 2, 542, 544, 7, 7, 2,
	2, 543, 542, 3, 2, 2, 2, 544, 547, 3, 2, 2, 2, 545, 543, 3, 2, 2, 2, 545,
	546, 3, 2, 2, 2, 546, 548, 3, 2, 2, 2, 547, 545, 3, 2, 2, 2, 548, 550,
	5, 26, 14, 2, 549, 545, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 565, 3,
	2, 2, 2, 551, 553, 7, 7, 2, 2, 552, 551, 3, 2, 2, 2, 553, 556, 3, 2, 2,
	2, 554, 552, 3, 2, 2, 2, 554, 555, 3, 2, 2, 2, 555, 557, 3, 2, 2, 2, 556,
	554, 3, 2, 2, 2, 557, 561, 7, 28, 2, 2, 558, 560, 7, 7, 2, 2, 559, 558,
	3, 2, 2, 2, 560, 563, 3, 2, 2, 2, 561, 559, 3, 2, 2, 2, 561, 562, 3, 2,
	2, 2, 562, 564, 3, 2, 2, 2, 563, 561, 3, 2, 2, 2, 564, 566, 5, 34, 18,
	2, 565, 554, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 574, 3, 2, 2, 2, 567,
	569, 7, 7, 2, 2, 568, 567, 3, 2, 2, 2, 569, 572, 3, 2, 2, 2, 570, 568,
	3, 2, 2, 2, 570, 571, 3, 2, 2, 2, 571, 573, 3, 2, 2, 2, 572, 570, 3, 2,
	2, 2, 573, 575, 5, 48, 25, 2, 574, 570, 3, 2, 2, 2, 574, 575, 3, 2, 2,
	2, 575, 590, 3, 2, 2, 2, 576, 578, 7, 7, 2, 2, 577, 576, 3, 2, 2, 2, 578,
	581, 3, 2, 2, 2, 579, 577, 3, 2, 2, 2, 579, 580, 3, 2, 2, 2, 580, 582,
	3, 2, 2, 2, 581, 579, 3, 2, 2, 2, 582, 591, 5, 28, 15, 2, 583, 585, 7,
	7, 2, 2, 584, 583, 3, 2, 2, 2, 585, 588, 3, 2, 2, 2, 586, 584, 3, 2, 2,
	2, 586, 587, 3, 2, 2, 2, 587, 589, 3, 2, 2, 2, 588, 586, 3, 2, 2, 2, 589,
	591, 5, 94, 48, 2, 590, 579, 3, 2, 2, 2, 590, 586, 3, 2, 2, 2, 590, 591,
	3, 2, 2, 2, 591, 25, 3, 2, 2, 2, 592, 594, 5, 300, 151, 2, 593, 592, 3,
	2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595, 599, 7, 81, 2,
	2, 596, 598, 7, 7, 2, 2, 597, 596, 3, 2, 2, 2, 598, 601, 3, 2, 2, 2, 599,
	597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 603, 3, 2, 2, 2, 601, 599,
	3, 2, 2, 2, 602, 593, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 604, 3, 2,
	2, 2, 604, 605, 5, 30, 16, 2, 605, 27, 3, 2, 2, 2, 606, 610, 7, 15, 2,
	2, 607, 609, 7, 7, 2, 2, 608, 607, 3, 2, 2, 2, 609, 612, 3, 2, 2, 2, 610,
	608, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 613, 3, 2, 2, 2, 612, 610,
	3, 2, 2, 2, 613, 617, 5, 52, 27, 2, 614, 616, 7, 7, 2, 2, 615, 614, 3,
	2, 2, 2, 616, 619, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2, 617, 618, 3, 2, 2,
	2, 618, 620, 3, 2, 2, 2, 619, 617, 3, 2, 2, 2, 620, 621, 7, 16, 2, 2, 621,
	29, 3, 2, 2, 2, 622, 626, 7, 11, 2, 2, 623, 625, 7, 7, 2, 2, 624, 623,
	3, 2, 2, 2, 625, 628, 3, 2, 2, 2, 626, 624, 3, 2, 2, 2, 626, 627, 3, 2,
	2, 2, 627, 658, 3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 629, 646, 5, 32, 17,
	2, 630, 632, 7, 7, 2, 2, 631, 630, 3, 2, 2, 2, 632, 635, 3, 2, 2, 2, 633,
	631, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 636, 3, 2, 2, 2, 635, 633,
	3, 2, 2, 2, 636, 640, 7, 10, 2, 2, 637, 639, 7, 7, 2, 2, 638, 637, 3, 2,
	2, 2, 639, 642, 3, 2, 2, 2, 640, 638, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2,
	641, 643, 3, 2, 2, 2, 642, 640, 3, 2, 2, 2, 643, 645, 5, 32, 17, 2, 644,
	633, 3, 2, 2, 2, 645, 648, 3, 2, 2, 2, 646, 644, 3, 2, 2, 2, 646, 647,
	3, 2, 2, 2, 647, 656, 3, 2, 2, 2, 648, 646, 3, 2, 2, 2, 649, 651, 7, 7,
	2, 2, 650, 649, 3, 2, 2, 2, 651, 654, 3, 2, 2, 2, 652, 650, 3, 2, 2, 2,
	652, 653, 3, 2, 2, 2, 653, 655, 3, 2, 2, 2, 654, 652, 3, 2, 2, 2, 655,
	657, 7, 10, 2, 2, 656, 652, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 659,
	3, 2, 2, 2, 658, 629, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659, 663, 3, 2,
	2, 2, 660, 662, 7, 7, 2, 2, 661, 660, 3, 2, 2, 2, 662, 665, 3, 2, 2, 2,
	663, 661, 3, 2, 2, 2, 663, 664, 3, 2, 2, 2, 664, 666, 3, 2, 2, 2, 665,
	663, 3, 2, 2, 2, 666, 667, 7, 12, 2, 2, 667, 31, 3, 2, 2, 2, 668, 670,
	5, 300, 151, 2, 669, 668, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670, 672, 3,
	2, 2, 2, 671, 673, 9, 3, 2, 2, 672, 671, 3, 2, 2, 2, 672, 673, 3, 2, 2,
	2, 673, 677, 3, 2, 2, 2, 674, 676, 7, 7, 2, 2, 675, 674, 3, 2, 2, 2, 676,
	679, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2, 677, 678, 3, 2, 2, 2, 678, 680,
	3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 680, 681, 5, 344, 173, 2, 681, 685, 7,
	28, 2, 2, 682, 684, 7, 7, 2, 2, 683, 682, 3, 2, 2, 2, 684, 687, 3, 2, 2,
	2, 685, 683, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 688, 3, 2, 2, 2, 687,
	685, 3, 2, 2, 2, 688, 703, 5, 100, 51, 2, 689, 691, 7, 7, 2, 2, 690, 689,
	3, 2, 2, 2, 691, 694, 3, 2, 2, 2, 692, 690, 3, 2, 2, 2, 692, 693, 3, 2,
	2, 2, 693, 695, 3, 2, 2, 2, 694, 692, 3, 2, 2, 2, 695, 699, 7, 30, 2, 2,
	696, 698, 7, 7, 2, 2, 697, 696, 3, 2, 2, 2, 698, 701, 3, 2, 2, 2, 699,
	697, 3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 702, 3, 2, 2, 2, 701, 699,
	3, 2, 2, 2, 702, 704, 5, 152, 77, 2, 703, 692, 3, 2, 2, 2, 703, 704, 3,
	2, 2, 2, 704, 33, 3, 2, 2, 2, 705, 722, 5, 40, 21, 2, 706, 708, 7, 7, 2,
	2, 707, 706, 3, 2, 2, 2, 708, 711, 3, 2, 2, 2, 709, 707, 3, 2, 2, 2, 709,
	710, 3, 2, 2, 2, 710, 712, 3, 2, 2, 2, 711, 709, 3, 2, 2, 2, 712, 716,
	7, 10, 2, 2, 713, 715, 7, 7, 2, 2, 714, 713, 3, 2, 2, 2, 715, 718, 3, 2,
	2, 2, 716, 714, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 719, 3, 2, 2, 2,
	718, 716, 3, 2, 2, 2, 719, 721, 5, 40, 21, 2, 720, 709, 3, 2, 2, 2, 721,
	724, 3, 2, 2, 2, 722, 720, 3, 2, 2, 2, 722, 723, 3, 2, 2, 2, 723, 35, 3,
	2, 2, 2, 724, 722, 3, 2, 2, 2, 725, 730, 5, 38, 20, 2, 726, 730, 5, 42,
	22, 2, 727, 730, 5, 108, 55, 2, 728, 730, 5, 118, 60, 2, 729, 725, 3, 2,
	2, 2, 729, 726, 3, 2, 2, 2, 729, 727, 3, 2, 2, 2, 729, 728, 3, 2, 2, 2,
	730, 37, 3, 2, 2, 2, 731, 732, 5, 108, 55, 2, 732, 733, 5, 208, 105, 2,
	733, 39, 3, 2, 2, 2, 734, 736, 5, 334, 168, 2, 735, 734, 3, 2, 2, 2, 736,
	739, 3, 2, 2, 2, 737, 735, 3, 2, 2, 2, 737, 738, 3, 2, 2, 2, 738, 743,
	3, 2, 2, 2, 739, 737, 3, 2, 2, 2, 740, 742, 7, 7, 2, 2, 741, 740, 3, 2,
	2, 2, 742, 745, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 743, 744, 3, 2, 2, 2,
	744, 746, 3, 2, 2, 2, 745, 743, 3, 2, 2, 2, 746, 747, 5, 36, 19, 2, 747,
	41, 3, 2, 2, 2, 748, 751, 5, 108, 55, 2, 749, 751, 5, 118, 60, 2, 750,
	748, 3, 2, 2, 2, 750, 749, 3, 2, 2, 2, 751, 755, 3, 2, 2, 2, 752, 754,
	7, 7, 2, 2, 753, 752, 3, 2, 2, 2, 754, 757, 3, 2, 2, 2, 755, 753, 3, 2,
	2, 2, 755, 756, 3, 2, 2, 2, 756, 758, 3, 2, 2, 2, 757, 755, 3, 2, 2, 2,
	758, 762, 7, 82, 2, 2, 759, 761, 7, 7, 2, 2, 760, 759, 3, 2, 2, 2, 761,
	764, 3, 2, 2, 2, 762, 760, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2, 763, 765,
	3, 2, 2, 2, 764, 762, 3, 2, 2, 2, 765, 766, 5, 152, 77, 2, 766, 43, 3,
	2, 2, 2, 767, 771, 7, 48, 2, 2, 768, 770, 7, 7, 2, 2, 769, 768, 3, 2, 2,
	2, 770, 773, 3, 2, 2, 2, 771, 769, 3, 2, 2, 2, 771, 772, 3, 2, 2, 2, 772,
	774, 3, 2, 2, 2, 773, 771, 3, 2, 2, 2, 774, 791, 5, 46, 24, 2, 775, 777,
	7, 7, 2, 2, 776, 775, 3, 2, 2, 2, 777, 780, 3, 2, 2, 2, 778, 776, 3, 2,
	2, 2, 778, 779, 3, 2, 2, 2, 779, 781, 3, 2, 2, 2, 780, 778, 3, 2, 2, 2,
	781, 785, 7, 10, 2, 2, 782, 784, 7, 7, 2, 2, 783, 782, 3, 2, 2, 2, 784,
	787, 3, 2, 2, 2, 785, 783, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 788,
	3, 2, 2, 2, 787, 785, 3, 2, 2, 2, 788, 790, 5, 46, 24, 2, 789, 778, 3,
	2, 2, 2, 790, 793, 3, 2, 2, 2, 791, 789, 3, 2, 2, 2, 791, 792, 3, 2, 2,
	2, 792, 801, 3, 2, 2, 2, 793, 791, 3, 2, 2, 2, 794, 796, 7, 7, 2, 2, 795,
	794, 3, 2, 2, 2, 796, 799, 3, 2, 2, 2, 797, 795, 3, 2, 2, 2, 797, 798,
	3, 2, 2, 2, 798, 800, 3, 2, 2, 2, 799, 797, 3, 2, 2, 2, 800, 802, 7, 10,
	2, 2, 801, 797, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2, 802, 806, 3, 2, 2, 2,
	803, 805, 7, 7, 2, 2, 804, 803, 3, 2, 2, 2, 805, 808, 3, 2, 2, 2, 806,
	804, 3, 2, 2, 2, 806, 807, 3, 2, 2, 2, 807, 809, 3, 2, 2, 2, 808, 806,
	3, 2, 2, 2, 809, 810, 7, 49, 2, 2, 810, 45, 3, 2, 2, 2, 811, 813, 5, 318,
	160, 2, 812, 811, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813, 817, 3, 2, 2,
	2, 814, 816, 7, 7, 2, 2, 815, 814, 3, 2, 2, 2, 816, 819, 3, 2, 2, 2, 817,
	815, 3, 2, 2, 2, 817, 818, 3, 2, 2, 2, 818, 820, 3, 2, 2, 2, 819, 817,
	3, 2, 2, 2, 820, 835, 5, 344, 173, 2, 821, 823, 7, 7, 2, 2, 822, 821, 3,
	2, 2, 2, 823, 826, 3, 2, 2, 2, 824, 822, 3, 2, 2, 2, 824, 825, 3, 2, 2,
	2, 825, 827, 3, 2, 2, 2, 826, 824, 3, 2, 2, 2, 827, 831, 7, 28, 2, 2, 828,
	830, 7, 7, 2, 2, 829, 828, 3, 2, 2, 2, 830, 833, 3, 2, 2, 2, 831, 829,
	3, 2, 2, 2, 831, 832, 3, 2, 2, 2, 832, 834, 3, 2, 2, 2, 833, 831, 3, 2,
	2, 2, 834, 836, 5, 100, 51, 2, 835, 824, 3, 2, 2, 2, 835, 836, 3, 2, 2,
	2, 836, 47, 3, 2, 2, 2, 837, 841, 7, 88, 2, 2, 838, 840, 7, 7, 2, 2, 839,
	838, 3, 2, 2, 2, 840, 843, 3, 2, 2, 2, 841, 839, 3, 2, 2, 2, 841, 842,
	3, 2, 2, 2, 842, 844, 3, 2, 2, 2, 843, 841, 3, 2, 2, 2, 844, 861, 5, 50,
	26, 2, 845, 847, 7, 7, 2, 2, 846, 845, 3, 2, 2, 2, 847, 850, 3, 2, 2, 2,
	848, 846, 3, 2, 2, 2, 848, 849, 3, 2, 2, 2, 849, 851, 3, 2, 2, 2, 850,
	848, 3, 2, 2, 2, 851, 855, 7, 10, 2, 2, 852, 854, 7, 7, 2, 2, 853, 852,
	3, 2, 2, 2, 854, 857, 3, 2, 2, 2, 855, 853, 3, 2, 2, 2, 855, 856, 3, 2,
	2, 2, 856, 858, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2, 858, 860, 5, 50, 26,
	2, 859, 848, 3, 2, 2, 2, 860, 863, 3, 2, 2, 2, 861, 859, 3, 2, 2, 2, 861,
	862, 3, 2, 2, 2, 862, 49, 3, 2, 2, 2, 863, 861, 3, 2, 2, 2, 864, 866, 5,
	334, 168, 2, 865, 864, 3, 2, 2, 2, 866, 869, 3, 2, 2, 2, 867, 865, 3, 2,
	2, 2, 867, 868, 3, 2, 2, 2, 868, 870, 3, 2, 2, 2, 869, 867, 3, 2, 2, 2,
	870, 874, 5, 344, 173, 2, 871, 873, 7, 7, 2, 2, 872, 871, 3, 2, 2, 2, 873,
	876, 3, 2, 2, 2, 874, 872, 3, 2, 2, 2, 874, 875, 3, 2, 2, 2, 875, 877,
	3, 2, 2, 2, 876, 874, 3, 2, 2, 2, 877, 881, 7, 28, 2, 2, 878, 880, 7, 7,
	2, 2, 879, 878, 3, 2, 2, 2, 880, 883, 3, 2, 2, 2, 881, 879, 3, 2, 2, 2,
	881, 882, 3, 2, 2, 2, 882, 884, 3, 2, 2, 2, 883, 881, 3, 2, 2, 2, 884,
	885, 5, 100, 51, 2, 885, 51, 3, 2, 2, 2, 886, 888, 5, 54, 28, 2, 887, 889,
	5, 150, 76, 2, 888, 887, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 891, 3,
	2, 2, 2, 890, 886, 3, 2, 2, 2, 891, 894, 3, 2, 2, 2, 892, 890, 3, 2, 2,
	2, 892, 893, 3, 2, 2, 2, 893, 53, 3, 2, 2, 2, 894, 892, 3, 2, 2, 2, 895,
	900, 5, 22, 12, 2, 896, 900, 5, 58, 30, 2, 897, 900, 5, 56, 29, 2, 898,
	900, 5, 90, 46, 2, 899, 895, 3, 2, 2, 2, 899, 896, 3, 2, 2, 2, 899, 897,
	3, 2, 2, 2, 899, 898, 3, 2, 2, 2, 900, 55, 3, 2, 2, 2, 901, 905, 7, 84,
	2, 2, 902, 904, 7, 7, 2, 2, 903, 902, 3, 2, 2, 2, 904, 907, 3, 2, 2, 2,
	905, 903, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 908, 3, 2, 2, 2, 907,
	905, 3, 2, 2, 2, 908, 909, 5, 136, 69, 2, 909, 57, 3, 2, 2, 2, 910, 912,
	5, 300, 151, 2, 911, 910, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 913, 3,
	2, 2, 2, 913, 917, 7, 83, 2, 2, 914, 916, 7, 7, 2, 2, 915, 914, 3, 2, 2,
	2, 916, 919, 3, 2, 2, 2, 917, 915, 3, 2, 2, 2, 917, 918, 3, 2, 2, 2, 918,
	920, 3, 2, 2, 2, 919, 917, 3, 2, 2, 2, 920, 928, 7, 77, 2, 2, 921, 923,
	7, 7, 2, 2, 922, 921, 3, 2, 2, 2, 923, 926, 3, 2, 2, 2, 924, 922, 3, 2,
	2, 2, 924, 925, 3, 2, 2, 2, 925, 927, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2,
	927, 929, 5, 344, 173, 2, 928, 924, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929,
	944, 3, 2, 2, 2, 930, 932, 7, 7, 2, 2, 931, 930, 3, 2, 2, 2, 932, 935,
	3, 2, 2, 2, 933, 931, 3, 2, 2, 2, 933, 934, 3, 2, 2, 2, 934, 936, 3, 2,
	2, 2, 935, 933, 3, 2, 2, 2, 936, 940, 7, 28, 2, 2, 937, 939, 7, 7, 2, 2,
	938, 937, 3, 2, 2, 2, 939, 942, 3, 2, 2, 2, 940, 938, 3, 2, 2, 2, 940,
	941, 3, 2, 2, 2, 941, 943, 3, 2, 2, 2, 942, 940, 3, 2, 2, 2, 943, 945,
	5, 34, 18, 2, 944, 933, 3, 2, 2, 2, 944, 945, 3, 2, 2, 2, 945, 953, 3,
	2, 2, 2, 946, 948, 7, 7, 2, 2, 947, 946, 3, 2, 2, 2, 948, 951, 3, 2, 2,
	2, 949, 947, 3, 2, 2, 2, 949, 950, 3, 2, 2, 2, 950, 952, 3, 2, 2, 2, 951,
	949, 3, 2, 2, 2, 952, 954, 5, 28, 15, 2, 953, 949, 3, 2, 2, 2, 953, 954,
	3, 2, 2, 2, 954, 59, 3, 2, 2, 2, 955, 959, 7, 11, 2, 2, 956, 958, 7, 7,
	2, 2, 957, 956, 3, 2, 2, 2, 958, 961, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2,
	959, 960, 3, 2, 2, 2, 960, 991, 3, 2, 2, 2, 961, 959, 3, 2, 2, 2, 962,
	979, 5, 62, 32, 2, 963, 965, 7, 7, 2, 2, 964, 963, 3, 2, 2, 2, 965, 968,
	3, 2, 2, 2, 966, 964, 3, 2, 2, 2, 966, 967, 3, 2, 2, 2, 967, 969, 3, 2,
	2, 2, 968, 966, 3, 2, 2, 2, 969, 973, 7, 10, 2, 2, 970, 972, 7, 7, 2, 2,
	971, 970, 3, 2, 2, 2, 972, 975, 3, 2, 2, 2, 973, 971, 3, 2, 2, 2, 973,
	974, 3, 2, 2, 2, 974, 976, 3, 2, 2, 2, 975, 973, 3, 2, 2, 2, 976, 978,
	5, 62, 32, 2, 977, 966, 3, 2, 2, 2, 978, 981, 3, 2, 2, 2, 979, 977, 3,
	2, 2, 2, 979, 980, 3, 2, 2, 2, 980, 989, 3, 2, 2, 2, 981, 979, 3, 2, 2,
	2, 982, 984, 7, 7, 2, 2, 983, 982, 3, 2, 2, 2, 984, 987, 3, 2, 2, 2, 985,
	983, 3, 2, 2, 2, 985, 986, 3, 2, 2, 2, 986, 988, 3, 2, 2, 2, 987, 985,
	3, 2, 2, 2, 988, 990, 7, 10, 2, 2, 989, 985, 3, 2, 2, 2, 989, 990, 3, 2,
	2, 2, 990, 992, 3, 2, 2, 2, 991, 962, 3, 2, 2, 2, 991, 992, 3, 2, 2, 2,
	992, 996, 3, 2, 2, 2, 993, 995, 7, 7, 2, 2, 994, 993, 3, 2, 2, 2, 995,
	998, 3, 2, 2, 2, 996, 994, 3, 2, 2, 2, 996, 997, 3, 2, 2, 2, 997, 999,
	3, 2, 2, 2, 998, 996, 3, 2, 2, 2, 999, 1000, 7, 12, 2, 2, 1000, 61, 3,
	2, 2, 2, 1001, 1003, 5, 302, 152, 2, 1002, 1001, 3, 2, 2, 2, 1002, 1003,
	3, 2, 2, 2, 1003, 1004, 3, 2, 2, 2, 1004, 1019, 5, 86, 44, 2, 1005, 1007,
	7, 7, 2, 2, 1006, 1005, 3, 2, 2, 2, 1007, 1010, 3, 2, 2, 2, 1008, 1006,
	3, 2, 2, 2, 1008, 1009, 3, 2, 2, 2, 1009, 1011, 3, 2, 2, 2, 1010, 1008,
	3, 2, 2, 2, 1011, 1015, 7, 30, 2, 2, 1012, 1014, 7, 7, 2, 2, 1013, 1012,
	3, 2, 2, 2, 1014, 1017, 3, 2, 2, 2, 1015, 1013, 3, 2, 2, 2, 1015, 1016,
	3, 2, 2, 2, 1016, 1018, 3, 2, 2, 2, 1017, 1015, 3, 2, 2, 2, 1018, 1020,
	5, 152, 77, 2, 1019, 1008, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 63,
	3, 2, 2, 2, 1021, 1023, 5, 300, 151, 2, 1022, 1021, 3, 2, 2, 2, 1022, 1023,
	3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024, 1032, 7, 76, 2, 2, 1025, 1027,
	7, 7, 2, 2, 1026, 1025, 3, 2, 2, 2, 1027, 1030, 3, 2, 2, 2, 1028, 1026,
	3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 1031, 3, 2, 2, 2, 1030, 1028,
	3, 2, 2, 2, 1031, 1033, 5, 44, 23, 2, 1032, 1028, 3, 2, 2, 2, 1032, 1033,
	3, 2, 2, 2, 1033, 1049, 3, 2, 2, 2, 1034, 1036, 7, 7, 2, 2, 1035, 1034,
	3, 2, 2, 2, 1036, 1039, 3, 2, 2, 2, 1037, 1035, 3, 2, 2, 2, 1037, 1038,
	3, 2, 2, 2, 1038, 1040, 3, 2, 2, 2, 1039, 1037, 3, 2, 2, 2, 1040, 1044,
	5, 124, 63, 2, 1041, 1043, 7, 7, 2, 2, 1042, 1041, 3, 2, 2, 2, 1043, 1046,
	3, 2, 2, 2, 1044, 1042, 3, 2, 2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 1047,
	3, 2, 2, 2, 1046, 1044, 3, 2, 2, 2, 1047, 1048, 7, 9, 2, 2, 1048, 1050,
	3, 2, 2, 2, 1049, 1037, 3, 2, 2, 2, 1049, 1050, 3, 2, 2, 2, 1050, 1054,
	3, 2, 2, 2, 1051, 1053, 7, 7, 2, 2, 1052, 1051, 3, 2, 2, 2, 1053, 1056,
	3, 2, 2, 2, 1054, 1052, 3, 2, 2, 2, 1054, 1055, 3, 2, 2, 2, 1055, 1057,
	3, 2, 2, 2, 1056, 1054, 3, 2, 2, 2, 1057, 1061, 5, 344, 173, 2, 1058, 1060,
	7, 7, 2, 2, 1059, 1058, 3, 2, 2, 2, 1060, 1063, 3, 2, 2, 2, 1061, 1059,
	3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1064, 3, 2, 2, 2, 1063, 1061,
	3, 2, 2, 2, 1064, 1079, 5, 60, 31, 2, 1065, 1067, 7, 7, 2, 2, 1066, 1065,
	3, 2, 2, 2, 1067, 1070, 3, 2, 2, 2, 1068, 1066, 3, 2, 2, 2, 1068, 1069,
	3, 2, 2, 2, 1069, 1071, 3, 2, 2, 2, 1070, 1068, 3, 2, 2, 2, 1071, 1075,
	7, 28, 2, 2, 1072, 1074, 7, 7, 2, 2, 1073, 1072, 3, 2, 2, 2, 1074, 1077,
	3, 2, 2, 2, 1075, 1073, 3, 2, 2, 2, 1075, 1076, 3, 2, 2, 2, 1076, 1078,
	3, 2, 2, 2, 1077, 1075, 3, 2, 2, 2, 1078, 1080, 5, 100, 51, 2, 1079, 1068,
	3, 2, 2, 2, 1079, 1080, 3, 2, 2, 2, 1080, 1088, 3, 2, 2, 2, 1081, 1083,
	7, 7, 2, 2, 1082, 1081, 3, 2, 2, 2, 1083, 1086, 3, 2, 2, 2, 1084, 1082,
	3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1087, 3, 2, 2, 2, 1086, 1084,
	3, 2, 2, 2, 1087, 1089, 5, 48, 25, 2, 1088, 1084, 3, 2, 2, 2, 1088, 1089,
	3, 2, 2, 2, 1089, 1097, 3, 2, 2, 2, 1090, 1092, 7, 7, 2, 2, 1091, 1090,
	3, 2, 2, 2, 1092, 1095, 3, 2, 2, 2, 1093, 1091, 3, 2, 2, 2, 1093, 1094,
	3, 2, 2, 2, 1094, 1096, 3, 2, 2, 2, 1095, 1093, 3, 2, 2, 2, 1096, 1098,
	5, 66, 34, 2, 1097, 1093, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 65,
	3, 2, 2, 2, 1099, 1109, 5, 136, 69, 2, 1100, 1104, 7, 30, 2, 2, 1101, 1103,
	7, 7, 2, 2, 1102, 1101, 3, 2, 2, 2, 1103, 1106, 3, 2, 2, 2, 1104, 1102,
	3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 1107, 3, 2, 2, 2, 1106, 1104,
	3, 2, 2, 2, 1107, 1109, 5, 152, 77, 2, 1108, 1099, 3, 2, 2, 2, 1108, 1100,
	3, 2, 2, 2, 1109, 67, 3, 2, 2, 2, 1110, 1112, 5, 334, 168, 2, 1111, 1110,
	3, 2, 2, 2, 1112, 1115, 3, 2, 2, 2, 1113, 1111, 3, 2, 2, 2, 1113, 1114,
	3, 2, 2, 2, 1114, 1119, 3, 2, 2, 2, 1115, 1113, 3, 2, 2, 2, 1116, 1118,
	7, 7, 2, 2, 1117, 1116, 3, 2, 2, 2, 1118, 1121, 3, 2, 2, 2, 1119, 1117,
	3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1122, 3, 2, 2, 2, 1121, 1119,
	3, 2, 2, 2, 1122, 1137, 5, 344, 173, 2, 1123, 1125, 7, 7, 2, 2, 1124, 1123,
	3, 2, 2, 2, 1125, 1128, 3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1126, 1127,
	3, 2, 2, 2, 1127, 1129, 3, 2, 2, 2, 1128, 1126, 3, 2, 2, 2, 1129, 1133,
	7, 28, 2, 2, 1130, 1132, 7, 7, 2, 2, 1131, 1130, 3, 2, 2, 2, 1132, 1135,
	3, 2, 2, 2, 1133, 1131, 3, 2, 2, 2, 1133, 1134, 3, 2, 2, 2, 1134, 1136,
	3, 2, 2, 2, 1135, 1133, 3, 2, 2, 2, 1136, 1138, 5, 100, 51, 2, 1137, 1126,
	3, 2, 2, 2, 1137, 1138, 3, 2, 2, 2, 1138, 69, 3, 2, 2, 2, 1139, 1143, 7,
	11, 2, 2, 1140, 1142, 7, 7, 2, 2, 1141, 1140, 3, 2, 2, 2, 1142, 1145, 3,
	2, 2, 2, 1143, 1141, 3, 2, 2, 2, 1143, 1144, 3, 2, 2, 2, 1144, 1146, 3,
	2, 2, 2, 1145, 1143, 3, 2, 2, 2, 1146, 1163, 5, 68, 35, 2, 1147, 1149,
	7, 7, 2, 2, 1148, 1147, 3, 2, 2, 2, 1149, 1152, 3, 2, 2, 2, 1150, 1148,
	3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 1153, 3, 2, 2, 2, 1152, 1150,
	3, 2, 2, 2, 1153, 1157, 7, 10, 2, 2, 1154, 1156, 7, 7, 2, 2, 1155, 1154,
	3, 2, 2, 2, 1156, 1159, 3, 2, 2, 2, 1157, 1155, 3, 2, 2, 2, 1157, 1158,
	3, 2, 2, 2, 1158, 1160, 3, 2, 2, 2, 1159, 1157, 3, 2, 2, 2, 1160, 1162,
	5, 68, 35, 2, 1161, 1150, 3, 2, 2, 2, 1162, 1165, 3, 2, 2, 2, 1163, 1161,
	3, 2, 2, 2, 1163, 1164, 3, 2, 2, 2, 1164, 1173, 3, 2, 2, 2, 1165, 1163,
	3, 2, 2, 2, 1166, 1168, 7, 7, 2, 2, 1167, 1166, 3, 2, 2, 2, 1168, 1171,
	3, 2, 2, 2, 1169, 1167, 3, 2, 2, 2, 1169, 1170, 3, 2, 2, 2, 1170, 1172,
	3, 2, 2, 2, 1171, 1169, 3, 2, 2, 2, 1172, 1174, 7, 10, 2, 2, 1173, 1169,
	3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174, 1178, 3, 2, 2, 2, 1175, 1177,
	7, 7, 2, 2, 1176, 1175, 3, 2, 2, 2, 1177, 1180, 3, 2, 2, 2, 1178, 1176,
	3, 2, 2, 2, 1178, 1179, 3, 2, 2, 2, 1179, 1181, 3, 2, 2, 2, 1180, 1178,
	3, 2, 2, 2, 1181, 1182, 7, 12, 2, 2, 1182, 71, 3, 2, 2, 2, 1183, 1185,
	5, 300, 151, 2, 1184, 1183, 3, 2, 2, 2, 1184, 1185, 3, 2, 2, 2, 1185, 1186,
	3, 2, 2, 2, 1186, 1194, 9, 3, 2, 2, 1187, 1189, 7, 7, 2, 2, 1188, 1187,
	3, 2, 2, 2, 1189, 1192, 3, 2, 2, 2, 1190, 1188, 3, 2, 2, 2, 1190, 1191,
	3, 2, 2, 2, 1191, 1193, 3, 2, 2, 2, 1192, 1190, 3, 2, 2, 2, 1193, 1195,
	5, 44, 23, 2, 1194, 1190, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1211,
	3, 2, 2, 2, 1196, 1198, 7, 7, 2, 2, 1197, 1196, 3, 2, 2, 2, 1198, 1201,
	3, 2, 2, 2, 1199, 1197, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200, 1202,
	3, 2, 2, 2, 1201, 1199, 3, 2, 2, 2, 1202, 1206, 5, 124, 63, 2, 1203, 1205,
	7, 7, 2, 2, 1204, 1203, 3, 2, 2, 2, 1205, 1208, 3, 2, 2, 2, 1206, 1204,
	3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 1209, 3, 2, 2, 2, 1208, 1206,
	3, 2, 2, 2, 1209, 1210, 7, 9, 2, 2, 1210, 1212, 3, 2, 2, 2, 1211, 1199,
	3, 2, 2, 2, 1211, 1212, 3, 2, 2, 2, 1212, 1216, 3, 2, 2, 2, 1213, 1215,
	7, 7, 2, 2, 1214, 1213, 3, 2, 2, 2, 1215, 1218, 3, 2, 2, 2, 1216, 1214,
	3, 2, 2, 2, 1216, 1217, 3, 2, 2, 2, 1217, 1221, 3, 2, 2, 2, 1218, 1216,
	3, 2, 2, 2, 1219, 1222, 5, 70, 36, 2, 1220, 1222, 5, 68, 35, 2, 1221, 1219,
	3, 2, 2, 2, 1221, 1220, 3, 2, 2, 2, 1222, 1230, 3, 2, 2, 2, 1223, 1225,
	7, 7, 2, 2, 1224, 1223, 3, 2, 2, 2, 1225, 1228, 3, 2, 2, 2, 1226, 1224,
	3, 2, 2, 2, 1226, 1227, 3, 2, 2, 2, 1227, 1229, 3, 2, 2, 2, 1228, 1226,
	3, 2, 2, 2, 1229, 1231, 5, 48, 25, 2, 1230, 1226, 3, 2, 2, 2, 1230, 1231,
	3, 2, 2, 2, 1231, 1249, 3, 2, 2, 2, 1232, 1234, 7, 7, 2, 2, 1233, 1232,
	3, 2, 2, 2, 1234, 1237, 3, 2, 2, 2, 1235, 1233, 3, 2, 2, 2, 1235, 1236,
	3, 2, 2, 2, 1236, 1247, 3, 2, 2, 2, 1237, 1235, 3, 2, 2, 2, 1238, 1242,
	7, 30, 2, 2, 1239, 1241, 7, 7, 2, 2, 1240, 1239, 3, 2, 2, 2, 1241, 1244,
	3, 2, 2, 2, 1242, 1240, 3, 2, 2, 2, 1242, 1243, 3, 2, 2, 2, 1243, 1245,
	3, 2, 2, 2, 1244, 1242, 3, 2, 2, 2, 1245, 1248, 5, 152, 77, 2, 1246, 1248,
	5, 74, 38, 2, 1247, 1238, 3, 2, 2, 2, 1247, 1246, 3, 2, 2, 2, 1248, 1250,
	3, 2, 2, 2, 1249, 1235, 3, 2, 2, 2, 1249, 1250, 3, 2, 2, 2, 1250, 1257,
	3, 2, 2, 2, 1251, 1253, 7, 7, 2, 2, 1252, 1251, 3, 2, 2, 2, 1253, 1254,
	3, 2, 2, 2, 1254, 1252, 3, 2, 2, 2, 1254, 1255, 3, 2, 2, 2, 1255, 1256,
	3, 2, 2, 2, 1256, 1258, 7, 29, 2, 2, 1257, 1252, 3, 2, 2, 2, 1257, 1258,
	3, 2, 2, 2, 1258, 1262, 3, 2, 2, 2, 1259, 1261, 7, 7, 2, 2, 1260, 1259,
	3, 2, 2, 2, 1261, 1264, 3, 2, 2, 2, 1262, 1260, 3, 2, 2, 2, 1262, 1263,
	3, 2, 2, 2, 1263, 1295, 3, 2, 2, 2, 1264, 1262, 3, 2, 2, 2, 1265, 1267,
	5, 76, 39, 2, 1266, 1265, 3, 2, 2, 2, 1266, 1267, 3, 2, 2, 2, 1267, 1278,
	3, 2, 2, 2, 1268, 1270, 7, 7, 2, 2, 1269, 1268, 3, 2, 2, 2, 1270, 1273,
	3, 2, 2, 2, 1271, 1269, 3, 2, 2, 2, 1271, 1272, 3, 2, 2, 2, 1272, 1275,
	3, 2, 2, 2, 1273, 1271, 3, 2, 2, 2, 1274, 1276, 5, 148, 75, 2, 1275, 1274,
	3, 2, 2, 2, 1275, 1276, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 1279,
	5, 78, 40, 2, 1278, 1271, 3, 2, 2, 2, 1278, 1279, 3, 2, 2, 2, 1279, 1296,
	3, 2, 2, 2, 1280, 1282, 5, 78, 40, 2, 1281, 1280, 3, 2, 2, 2, 1281, 1282,
	3, 2, 2, 2, 1282, 1293, 3, 2, 2, 2, 1283, 1285, 7, 7, 2, 2, 1284, 1283,
	3, 2, 2, 2, 1285, 1288, 3, 2, 2, 2, 1286, 1284, 3, 2, 2, 2, 1286, 1287,
	3, 2, 2, 2, 1287, 1290, 3, 2, 2, 2, 1288, 1286, 3, 2, 2, 2, 1289, 1291,
	5, 148, 75, 2, 1290, 1289, 3, 2, 2, 2, 1290, 1291, 3, 2, 2, 2, 1291, 1292,
	3, 2, 2, 2, 1292, 1294, 5, 76, 39, 2, 1293, 1286, 3, 2, 2, 2, 1293, 1294,
	3, 2, 2, 2, 1294, 1296, 3, 2, 2, 2, 1295, 1266, 3, 2, 2, 2, 1295, 1281,
	3, 2, 2, 2, 1296, 73, 3, 2, 2, 2, 1297, 1301, 7, 82, 2, 2, 1298, 1300,
	7, 7, 2, 2, 1299, 1298, 3, 2, 2, 2, 1300, 1303, 3, 2, 2, 2, 1301, 1299,
	3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 1304, 3, 2, 2, 2, 1303, 1301,
	3, 2, 2, 2, 1304, 1305, 5, 152, 77, 2, 1305, 75, 3, 2, 2, 2, 1306, 1308,
	5, 300, 151, 2, 1307, 1306, 3, 2, 2, 2, 1307, 1308, 3, 2, 2, 2, 1308, 1309,
	3, 2, 2, 2, 1309, 1347, 7, 66, 2, 2, 1310, 1312, 7, 7, 2, 2, 1311, 1310,
	3, 2, 2, 2, 1312, 1315, 3, 2, 2, 2, 1313, 1311, 3, 2, 2, 2, 1313, 1314,
	3, 2, 2, 2, 1314, 1316, 3, 2, 2, 2, 1315, 1313, 3, 2, 2, 2, 1316, 1320,
	7, 11, 2, 2, 1317, 1319, 7, 7, 2, 2, 1318, 1317, 3, 2, 2, 2, 1319, 1322,
	3, 2, 2, 2, 1320, 1318, 3, 2, 2, 2, 1320, 1321, 3, 2, 2, 2, 1321, 1323,
	3, 2, 2, 2, 1322, 1320, 3, 2, 2, 2, 1323, 1338, 7, 12, 2, 2, 1324, 1326,
	7, 7, 2, 2, 1325, 1324, 3, 2, 2, 2, 1326, 1329, 3, 2, 2, 2, 1327, 1325,
	3, 2, 2, 2, 1327, 1328, 3, 2, 2, 2, 1328, 1330, 3, 2, 2, 2, 1329, 1327,
	3, 2, 2, 2, 1330, 1334, 7, 28, 2, 2, 1331, 1333, 7, 7, 2, 2, 1332, 1331,
	3, 2, 2, 2, 1333, 1336, 3, 2, 2, 2, 1334, 1332, 3, 2, 2, 2, 1334, 1335,
	3, 2, 2, 2, 1335, 1337, 3, 2, 2, 2, 1336, 1334, 3, 2, 2, 2, 1337, 1339,
	5, 100, 51, 2, 1338, 1327, 3, 2, 2, 2, 1338, 1339, 3, 2, 2, 2, 1339, 1343,
	3, 2, 2, 2, 1340, 1342, 7, 7, 2, 2, 1341, 1340, 3, 2, 2, 2, 1342, 1345,
	3, 2, 2, 2, 1343, 1341, 3, 2, 2, 2, 1343, 1344, 3, 2, 2, 2, 1344, 1346,
	3, 2, 2, 2, 1345, 1343, 3, 2, 2, 2, 1346, 1348, 5, 66, 34, 2, 1347, 1313,
	3, 2, 2, 2, 1347, 1348, 3, 2, 2, 2, 1348, 77, 3, 2, 2, 2, 1349, 1351, 5,
	300, 151, 2, 1350, 1349, 3, 2, 2, 2, 1350, 1351, 3, 2, 2, 2, 1351, 1352,
	3, 2, 2, 2, 1352, 1407, 7, 67, 2, 2, 1353, 1355, 7, 7, 2, 2, 1354, 1353,
	3, 2, 2, 2, 1355, 1358, 3, 2, 2, 2, 1356, 1354, 3, 2, 2, 2, 1356, 1357,
	3, 2, 2, 2, 1357, 1359, 3, 2, 2, 2, 1358, 1356, 3, 2, 2, 2, 1359, 1363,
	7, 11, 2, 2, 1360, 1362, 7, 7, 2, 2, 1361, 1360, 3, 2, 2, 2, 1362, 1365,
	3, 2, 2, 2, 1363, 1361, 3, 2, 2, 2, 1363, 1364, 3, 2, 2, 2, 1364, 1366,
	3, 2, 2, 2, 1365, 1363, 3, 2, 2, 2, 1366, 1374, 5, 82, 42, 2, 1367, 1369,
	7, 7, 2, 2, 1368, 1367, 3, 2, 2, 2, 1369, 1372, 3, 2, 2, 2, 1370, 1368,
	3, 2, 2, 2, 1370, 1371, 3, 2, 2, 2, 1371, 1373, 3, 2, 2, 2, 1372, 1370,
	3, 2, 2, 2, 1373, 1375, 7, 10, 2, 2, 1374, 1370, 3, 2, 2, 2, 1374, 1375,
	3, 2, 2, 2, 1375, 1379, 3, 2, 2, 2, 1376, 1378, 7, 7, 2, 2, 1377, 1376,
	3, 2, 2, 2, 1378, 1381, 3, 2, 2, 2, 1379, 1377, 3, 2, 2, 2, 1379, 1380,
	3, 2, 2, 2, 1380, 1382, 3, 2, 2, 2, 1381, 1379, 3, 2, 2, 2, 1382, 1397,
	7, 12, 2, 2, 1383, 1385, 7, 7, 2, 2, 1384, 1383, 3, 2, 2, 2, 1385, 1388,
	3, 2, 2, 2, 1386, 1384, 3, 2, 2, 2, 1386, 1387, 3, 2, 2, 2, 1387, 1389,
	3, 2, 2, 2, 1388, 1386, 3, 2, 2, 2, 1389, 1393, 7, 28, 2, 2, 1390, 1392,
	7, 7, 2, 2, 1391, 1390, 3, 2, 2, 2, 1392, 1395, 3, 2, 2, 2, 1393, 1391,
	3, 2, 2, 2, 1393, 1394, 3, 2, 2, 2, 1394, 1396, 3, 2, 2, 2, 1395, 1393,
	3, 2, 2, 2, 1396, 1398, 5, 100, 51, 2, 1397, 1386, 3, 2, 2, 2, 1397, 1398,
	3, 2, 2, 2, 1398, 1402, 3, 2, 2, 2, 1399, 1401, 7, 7, 2, 2, 1400, 1399,
	3, 2, 2, 2, 1401, 1404, 3, 2, 2, 2, 1402, 1400, 3, 2, 2, 2, 1402, 1403,
	3, 2, 2, 2, 1403, 1405, 3, 2, 2, 2, 1404, 1402, 3, 2, 2, 2, 1405, 1406,
	5, 66, 34, 2, 1406, 1408, 3, 2, 2, 2, 1407, 1356, 3, 2, 2, 2, 1407, 1408,
	3, 2, 2, 2, 1408, 79, 3, 2, 2, 2, 1409, 1413, 7, 11, 2, 2, 1410, 1412,
	7, 7, 2, 2, 1411, 1410, 3, 2, 2, 2, 1412, 1415, 3, 2, 2, 2, 1413, 1411,
	3, 2, 2, 2, 1413, 1414, 3, 2, 2, 2, 1414, 1445, 3, 2, 2, 2, 1415, 1413,
	3, 2, 2, 2, 1416, 1433, 5, 82, 42, 2, 1417, 1419, 7, 7, 2, 2, 1418, 1417,
	3, 2, 2, 2, 1419, 1422, 3, 2, 2, 2, 1420, 1418, 3, 2, 2, 2, 1420, 1421,
	3, 2, 2, 2, 1421, 1423, 3, 2, 2, 2, 1422, 1420, 3, 2, 2, 2, 1423, 1427,
	7, 10, 2, 2, 1424, 1426, 7, 7, 2, 2, 1425, 1424, 3, 2, 2, 2, 1426, 1429,
	3, 2, 2, 2, 1427, 1425, 3, 2, 2, 2, 1427, 1428, 3, 2, 2, 2, 1428, 1430,
	3, 2, 2, 2, 1429, 1427, 3, 2, 2, 2, 1430, 1432, 5, 82, 42, 2, 1431, 1420,
	3, 2, 2, 2, 1432, 1435, 3, 2, 2, 2, 1433, 1431, 3, 2, 2, 2, 1433, 1434,
	3, 2, 2, 2, 1434, 1443, 3, 2, 2, 2, 1435, 1433, 3, 2, 2, 2, 1436, 1438,
	7, 7, 2, 2, 1437, 1436, 3, 2, 2, 2, 1438, 1441, 3, 2, 2, 2, 1439, 1437,
	3, 2, 2, 2, 1439, 1440, 3, 2, 2, 2, 1440, 1442, 3, 2, 2, 2, 1441, 1439,
	3, 2, 2, 2, 1442, 1444, 7, 10, 2, 2, 1443, 1439, 3, 2, 2, 2, 1443, 1444,
	3, 2, 2, 2, 1444, 1446, 3, 2, 2, 2, 1445, 1416, 3, 2, 2, 2, 1445, 1446,
	3, 2, 2, 2, 1446, 1450, 3, 2, 2, 2, 1447, 1449, 7, 7, 2, 2, 1448, 1447,
	3, 2, 2, 2, 1449, 1452, 3, 2, 2, 2, 1450, 1448, 3, 2, 2, 2, 1450, 1451,
	3, 2, 2, 2, 1451, 1453, 3, 2, 2, 2, 1452, 1450, 3, 2, 2, 2, 1453, 1454,
	7, 12, 2, 2, 1454, 81, 3, 2, 2, 2, 1455, 1457, 5, 302, 152, 2, 1456, 1455,
	3, 2, 2, 2, 1456, 1457, 3, 2, 2, 2, 1457, 1458, 3, 2, 2, 2, 1458, 1473,
	5, 84, 43, 2, 1459, 1461, 7, 7, 2, 2, 1460, 1459, 3, 2, 2, 2, 1461, 1464,
	3, 2, 2, 2, 1462, 1460, 3, 2, 2, 2, 1462, 1463, 3, 2, 2, 2, 1463, 1465,
	3, 2, 2, 2, 1464, 1462, 3, 2, 2, 2, 1465, 1469, 7, 30, 2, 2, 1466, 1468,
	7, 7, 2, 2, 1467, 1466, 3, 2, 2, 2, 1468, 1471, 3, 2, 2, 2, 1469, 1467,
	3, 2, 2, 2, 1469, 1470, 3, 2, 2, 2, 1470, 1472, 3, 2, 2, 2, 1471, 1469,
	3, 2, 2, 2, 1472, 1474, 5, 152, 77, 2, 1473, 1462, 3, 2, 2, 2, 1473, 1474,
	3, 2, 2, 2, 1474, 83, 3, 2, 2, 2, 1475, 1479, 5, 344, 173, 2, 1476, 1478,
	7, 7, 2, 2, 1477, 1476, 3, 2, 2, 2, 1478, 1481, 3, 2, 2, 2, 1479, 1477,
	3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 1490, 3, 2, 2, 2, 1481, 1479,
	3, 2, 2, 2, 1482, 1486, 7, 28, 2, 2, 1483, 1485, 7, 7, 2, 2, 1484, 1483,
	3, 2, 2, 2, 1485, 1488, 3, 2, 2, 2, 1486, 1484, 3, 2, 2, 2, 1486, 1487,
	3, 2, 2, 2, 1487, 1489, 3, 2, 2, 2, 1488, 1486, 3, 2, 2, 2, 1489, 1491,
	5, 100, 51, 2, 1490, 1482, 3, 2, 2, 2, 1490, 1491, 3, 2, 2, 2, 1491, 85,
	3, 2, 2, 2, 1492, 1496, 5, 344, 173, 2, 1493, 1495, 7, 7, 2, 2, 1494, 1493,
	3, 2, 2, 2, 1495, 1498, 3, 2, 2, 2, 1496, 1494, 3, 2, 2, 2, 1496, 1497,
	3, 2, 2, 2, 1497, 1499, 3, 2, 2, 2, 1498, 1496, 3, 2, 2, 2, 1499, 1503,
	7, 28, 2, 2, 1500, 1502, 7, 7, 2, 2, 1501, 1500, 3, 2, 2, 2, 1502, 1505,
	3, 2, 2, 2, 1503, 1501, 3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504, 1506,
	3, 2, 2, 2, 1505, 1503, 3, 2, 2, 2, 1506, 1507, 5, 100, 51, 2, 1507, 87,
	3, 2, 2, 2, 1508, 1510, 5, 300, 151, 2, 1509, 1508, 3, 2, 2, 2, 1509, 1510,
	3, 2, 2, 2, 1510, 1511, 3, 2, 2, 2, 1511, 1515, 7, 77, 2, 2, 1512, 1514,
	7, 7, 2, 2, 1513, 1512, 3, 2, 2, 2, 1514, 1517, 3, 2, 2, 2, 1515, 1513,
	3, 2, 2, 2, 1515, 1516, 3, 2, 2, 2, 1516, 1518, 3, 2, 2, 2, 1517, 1515,
	3, 2, 2, 2, 1518, 1533, 5, 344, 173, 2, 1519, 1521, 7, 7, 2, 2, 1520, 1519,
	3, 2, 2, 2, 1521, 1524, 3, 2, 2, 2, 1522, 1520, 3, 2, 2, 2, 1522, 1523,
	3, 2, 2, 2, 1523, 1525, 3, 2, 2, 2, 1524, 1522, 3, 2, 2, 2, 1525, 1529,
	7, 28, 2, 2, 1526, 1528, 7, 7, 2, 2, 1527, 1526, 3, 2, 2, 2, 1528, 1531,
	3, 2, 2, 2, 1529, 1527, 3, 2, 2, 2, 1529, 1530, 3, 2, 2, 2, 1530, 1532,
	3, 2, 2, 2, 1531, 1529, 3, 2, 2, 2, 1532, 1534, 5, 34, 18, 2, 1533, 1522,
	3, 2, 2, 2, 1533, 1534, 3, 2, 2, 2, 1534, 1542, 3, 2, 2, 2, 1535, 1537,
	7, 7, 2, 2, 1536, 1535, 3, 2, 2, 2, 1537, 1540, 3, 2, 2, 2, 1538, 1536,
	3, 2, 2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 1541, 3, 2, 2, 2, 1540, 1538,
	3, 2, 2, 2, 1541, 1543, 5, 28, 15, 2, 1542, 1538, 3, 2, 2, 2, 1542, 1543,
	3, 2, 2, 2, 1543, 89, 3, 2, 2, 2, 1544, 1546, 5, 300, 151, 2, 1545, 1544,
	3, 2, 2, 2, 1545, 1546, 3, 2, 2, 2, 1546, 1547, 3, 2, 2, 2, 1547, 1551,
	7, 81, 2, 2, 1548, 1550, 7, 7, 2, 2, 1549, 1548, 3, 2, 2, 2, 1550, 1553,
	3, 2, 2, 2, 1551, 1549, 3, 2, 2, 2, 1551, 1552, 3, 2, 2, 2, 1552, 1554,
	3, 2, 2, 2, 1553, 1551, 3, 2, 2, 2, 1554, 1569, 5, 60, 31, 2, 1555, 1557,
	7, 7, 2, 2, 1556, 1555, 3, 2, 2, 2, 1557, 1560, 3, 2, 2, 2, 1558, 1556,
	3, 2, 2, 2, 1558, 1559, 3, 2, 2, 2, 1559, 1561, 3, 2, 2, 2, 1560, 1558,
	3, 2, 2, 2, 1561, 1565, 7, 28, 2, 2, 1562, 1564, 7, 7, 2, 2, 1563, 1562,
	3, 2, 2, 2, 1564, 1567, 3, 2, 2, 2, 1565, 1563, 3, 2, 2, 2, 1565, 1566,
	3, 2, 2, 2, 1566, 1568, 3, 2, 2, 2, 1567, 1565, 3, 2, 2, 2, 1568, 1570,
	5, 92, 47, 2, 1569, 1558, 3, 2, 2, 2, 1569, 1570, 3, 2, 2, 2, 1570, 1574,
	3, 2, 2, 2, 1571, 1573, 7, 7, 2, 2, 1572, 1571, 3, 2, 2, 2, 1573, 1576,
	3, 2, 2, 2, 1574, 1572, 3, 2, 2, 2, 1574, 1575, 3, 2, 2, 2, 1575, 1578,
	3, 2, 2, 2, 1576, 1574, 3, 2, 2, 2, 1577, 1579, 5, 136, 69, 2, 1578, 1577,
	3, 2, 2, 2, 1578, 1579, 3, 2, 2, 2, 1579, 91, 3, 2, 2, 2, 1580, 1584, 9,
	4, 2, 2, 1581, 1583, 7, 7, 2, 2, 1582, 1581, 3, 2, 2, 2, 1583, 1586, 3,
	2, 2, 2, 1584, 1582, 3, 2, 2, 2, 1584, 1585, 3, 2, 2, 2, 1585, 1587, 3,
	2, 2, 2, 1586, 1584, 3, 2, 2, 2, 1587, 1588, 5, 208, 105, 2, 1588, 93,
	3, 2, 2, 2, 1589, 1593, 7, 15, 2, 2, 1590, 1592, 7, 7, 2, 2, 1591, 1590,
	3, 2, 2, 2, 1592, 1595, 3, 2, 2, 2, 1593, 1591, 3, 2, 2, 2, 1593, 1594,
	3, 2, 2, 2, 1594, 1597, 3, 2, 2, 2, 1595, 1593, 3, 2, 2, 2, 1596, 1598,
	5, 96, 49, 2, 1597, 1596, 3, 2, 2, 2, 1597, 1598, 3, 2, 2, 2, 1598, 1613,
	3, 2, 2, 2, 1599, 1601, 7, 7, 2, 2, 1600, 1599, 3, 2, 2, 2, 1601, 1604,
	3, 2, 2, 2, 1602, 1600, 3, 2, 2, 2, 1602, 1603, 3, 2, 2, 2, 1603, 1605,
	3, 2, 2, 2, 1604, 1602, 3, 2, 2, 2, 1605, 1609, 7, 29, 2, 2, 1606, 1608,
	7, 7, 2, 2, 1607, 1606, 3, 2, 2, 2, 1608, 1611, 3, 2, 2, 2, 1609, 1607,
	3, 2, 2, 2, 1609, 1610, 3, 2, 2, 2, 1610, 1612, 3, 2, 2, 2, 1611, 1609,
	3, 2, 2, 2, 1612, 1614, 5, 52, 27, 2, 1613, 1602, 3, 2, 2, 2, 1613, 1614,
	3, 2, 2, 2, 1614, 1618, 3, 2, 2, 2, 1615, 1617, 7, 7, 2, 2, 1616, 1615,
	3, 2, 2, 2, 1617, 1620, 3, 2, 2, 2, 1618, 1616, 3, 2, 2, 2, 1618, 1619,
	3, 2, 2, 2, 1619, 1621, 3, 2, 2, 2, 1620, 1618, 3, 2, 2, 2, 1621, 1622,
	7, 16, 2, 2, 1622, 95, 3, 2, 2, 2, 1623, 1640, 5, 98, 50, 2, 1624, 1626,
	7, 7, 2, 2, 1625, 1624, 3, 2, 2, 2, 1626, 1629, 3, 2, 2, 2, 1627, 1625,
	3, 2, 2, 2, 1627, 1628, 3, 2, 2, 2, 1628, 1630, 3, 2, 2, 2, 1629, 1627,
	3, 2, 2, 2, 1630, 1634, 7, 10, 2, 2, 1631, 1633, 7, 7, 2, 2, 1632, 1631,
	3, 2, 2, 2, 1633, 1636, 3, 2, 2, 2, 1634, 1632, 3, 2, 2, 2, 1634, 1635,
	3, 2, 2, 2, 1635, 1637, 3, 2, 2, 2, 1636, 1634, 3, 2, 2, 2, 1637, 1639,
	5, 98, 50, 2, 1638, 1627, 3, 2, 2, 2, 1639, 1642, 3, 2, 2, 2, 1640, 1638,
	3, 2, 2, 2, 1640, 1641, 3, 2, 2, 2, 1641, 1646, 3, 2, 2, 2, 1642, 1640,
	3, 2, 2, 2, 1643, 1645, 7, 7, 2, 2, 1644, 1643, 3, 2, 2, 2, 1645, 1648,
	3, 2, 2, 2, 1646, 1644, 3, 2, 2, 2, 1646, 1647, 3, 2, 2, 2, 1647, 1650,
	3, 2, 2, 2, 1648, 1646, 3, 2, 2, 2, 1649, 1651, 7, 10, 2, 2, 1650, 1649,
	3, 2, 2, 2, 1650, 1651, 3, 2, 2, 2, 1651, 97, 3, 2, 2, 2, 1652, 1656, 5,
	300, 151, 2, 1653, 1655, 7, 7, 2, 2, 1654, 1653, 3, 2, 2, 2, 1655, 1658,
	3, 2, 2, 2, 1656, 1654, 3, 2, 2, 2, 1656, 1657, 3, 2, 2, 2, 1657, 1660,
	3, 2, 2, 2, 1658, 1656, 3, 2, 2, 2, 1659, 1652, 3, 2, 2, 2, 1659, 1660,
	3, 2, 2, 2, 1660, 1661, 3, 2, 2, 2, 1661, 1669, 5, 344, 173, 2, 1662, 1664,
	7, 7, 2, 2, 1663, 1662, 3, 2, 2, 2, 1664, 1667, 3, 2, 2, 2, 1665, 1663,
	3, 2, 2, 2, 1665, 1666, 3, 2, 2, 2, 1666, 1668, 3, 2, 2, 2, 1667, 1665,
	3, 2, 2, 2, 1668, 1670, 5, 208, 105, 2, 1669, 1665, 3, 2, 2, 2, 1669, 1670,
	3, 2, 2, 2, 1670, 1678, 3, 2, 2, 2, 1671, 1673, 7, 7, 2, 2, 1672, 1671,
	3, 2, 2, 2, 1673, 1676, 3, 2, 2, 2, 1674, 1672, 3, 2, 2, 2, 1674, 1675,
	3, 2, 2, 2, 1675, 1677, 3, 2, 2, 2, 1676, 1674, 3, 2, 2, 2, 1677, 1679,
	5, 28, 15, 2, 1678, 1674, 3, 2, 2, 2, 1678, 1679, 3, 2, 2, 2, 1679, 99,
	3, 2, 2, 2, 1680, 1682, 5, 306, 154, 2, 1681, 1680, 3, 2, 2, 2, 1681, 1682,
	3, 2, 2, 2, 1682, 1687, 3, 2, 2, 2, 1683, 1688, 5, 122, 62, 2, 1684, 1688,
	5, 104, 53, 2, 1685, 1688, 5, 102, 52, 2, 1686, 1688, 5, 118, 60, 2, 1687,
	1683, 3, 2, 2, 2, 1687, 1684, 3, 2, 2, 2, 1687, 1685, 3, 2, 2, 2, 1687,
	1686, 3, 2, 2, 2, 1688, 101, 3, 2, 2, 2, 1689, 1692, 5, 108, 55, 2, 1690,
	1692, 7, 108, 2, 2, 1691, 1689, 3, 2, 2, 2, 1691, 1690, 3, 2, 2, 2, 1692,
	103, 3, 2, 2, 2, 1693, 1696, 5, 102, 52, 2, 1694, 1696, 5, 122, 62, 2,
	1695, 1693, 3, 2, 2, 2, 1695, 1694, 3, 2, 2, 2, 1696, 1700, 3, 2, 2, 2,
	1697, 1699, 7, 7, 2, 2, 1698, 1697, 3, 2, 2, 2, 1699, 1702, 3, 2, 2, 2,
	1700, 1698, 3, 2, 2, 2, 1700, 1701, 3, 2, 2, 2, 1701, 1704, 3, 2, 2, 2,
	1702, 1700, 3, 2, 2, 2, 1703, 1705, 5, 106, 54, 2, 1704, 1703, 3, 2, 2,
	2, 1705, 1706, 3, 2, 2, 2, 1706, 1704, 3, 2, 2, 2, 1706, 1707, 3, 2, 2,
	2, 1707, 105, 3, 2, 2, 2, 1708, 1709, 9, 5, 2, 2, 1709, 107, 3, 2, 2, 2,
	1710, 1727, 5, 110, 56, 2, 1711, 1713, 7, 7, 2, 2, 1712, 1711, 3, 2, 2,
	2, 1713, 1716, 3, 2, 2, 2, 1714, 1712, 3, 2, 2, 2, 1714, 1715, 3, 2, 2,
	2, 1715, 1717, 3, 2, 2, 2, 1716, 1714, 3, 2, 2, 2, 1717, 1721, 7, 9, 2,
	2, 1718, 1720, 7, 7, 2, 2, 1719, 1718, 3, 2, 2, 2, 1720, 1723, 3, 2, 2,
	2, 1721, 1719, 3, 2, 2, 2, 1721, 1722, 3, 2, 2, 2, 1722, 1724, 3, 2, 2,
	2, 1723, 1721, 3, 2, 2, 2, 1724, 1726, 5, 110, 56, 2, 1725, 1714, 3, 2,
	2, 2, 1726, 1729, 3, 2, 2, 2, 1727, 1725, 3, 2, 2, 2, 1727, 1728, 3, 2,
	2, 2, 1728, 109, 3, 2, 2, 2, 1729, 1727, 3, 2, 2, 2, 1730, 1738, 5, 344,
	173, 2, 1731, 1733, 7, 7, 2, 2, 1732, 1731, 3, 2, 2, 2, 1733, 1736, 3,
	2, 2, 2, 1734, 1732, 3, 2, 2, 2, 1734, 1735, 3, 2, 2, 2, 1735, 1737, 3,
	2, 2, 2, 1736, 1734, 3, 2, 2, 2, 1737, 1739, 5, 206, 104, 2, 1738, 1734,
	3, 2, 2, 2, 1738, 1739, 3, 2, 2, 2, 1739, 111, 3, 2, 2, 2, 1740, 1742,
	5, 114, 58, 2, 1741, 1740, 3, 2, 2, 2, 1741, 1742, 3, 2, 2, 2, 1742, 1743,
	3, 2, 2, 2, 1743, 1746, 5, 100, 51, 2, 1744, 1746, 7, 17, 2, 2, 1745, 1741,
	3, 2, 2, 2, 1745, 1744, 3, 2, 2, 2, 1746, 113, 3, 2, 2, 2, 1747, 1749,
	5, 116, 59, 2, 1748, 1747, 3, 2, 2, 2, 1749, 1750, 3, 2, 2, 2, 1750, 1748,
	3, 2, 2, 2, 1750, 1751, 3, 2, 2, 2, 1751, 115, 3, 2, 2, 2, 1752, 1756,
	5, 316, 159, 2, 1753, 1755, 7, 7, 2, 2, 1754, 1753, 3, 2, 2, 2, 1755, 1758,
	3, 2, 2, 2, 1756, 1754, 3, 2, 2, 2, 1756, 1757, 3, 2, 2, 2, 1757, 1761,
	3, 2, 2, 2, 1758, 1756, 3, 2, 2, 2, 1759, 1761, 5, 334, 168, 2, 1760, 1752,
	3, 2, 2, 2, 1760, 1759, 3, 2, 2, 2, 1761, 117, 3, 2, 2, 2, 1762, 1766,
	5, 124, 63, 2, 1763, 1765, 7, 7, 2, 2, 1764, 1763, 3, 2, 2, 2, 1765, 1768,
	3, 2, 2, 2, 1766, 1764, 3, 2, 2, 2, 1766, 1767, 3, 2, 2, 2, 1767, 1769,
	3, 2, 2, 2, 1768, 1766, 3, 2, 2, 2, 1769, 1773, 7, 9, 2, 2, 1770, 1772,
	7, 7, 2, 2, 1771, 1770, 3, 2, 2, 2, 1772, 1775, 3, 2, 2, 2, 1773, 1771,
	3, 2, 2, 2, 1773, 1774, 3, 2, 2, 2, 1774, 1777, 3, 2, 2, 2, 1775, 1773,
	3, 2, 2, 2, 1776, 1762, 3, 2, 2, 2, 1776, 1777, 3, 2, 2, 2, 1777, 1778,
	3, 2, 2, 2, 1778, 1782, 5, 120, 61, 2, 1779, 1781, 7, 7, 2, 2, 1780, 1779,
	3, 2, 2, 2, 1781, 1784, 3, 2, 2, 2, 1782, 1780, 3, 2, 2, 2, 1782, 1783,
	3, 2, 2, 2, 1783, 1785, 3, 2, 2, 2, 1784, 1782, 3, 2, 2, 2, 1785, 1789,
	7, 36, 2, 2, 1786, 1788, 7, 7, 2, 2, 1787, 1786, 3, 2, 2, 2, 1788, 1791,
	3, 2, 2, 2, 1789, 1787, 3, 2, 2, 2, 1789, 1790, 3, 2, 2, 2, 1790, 1792,
	3, 2, 2, 2, 1791, 1789, 3, 2, 2, 2, 1792, 1793, 5, 100, 51, 2, 1793, 119,
	3, 2, 2, 2, 1794, 1798, 7, 11, 2, 2, 1795, 1797, 7, 7, 2, 2, 1796, 1795,
	3, 2, 2, 2, 1797, 1800, 3, 2, 2, 2, 1798, 1796, 3, 2, 2, 2, 1798, 1799,
	3, 2, 2, 2, 1799, 1803, 3, 2, 2, 2, 1800, 1798, 3, 2, 2, 2, 1801, 1804,
	5, 86, 44, 2, 1802, 1804, 5, 100, 51, 2, 1803, 1801, 3, 2, 2, 2, 1803,
	1802, 3, 2, 2, 2, 1803, 1804, 3, 2, 2, 2, 1804, 1824, 3, 2, 2, 2, 1805,
	1807, 7, 7, 2, 2, 1806, 1805, 3, 2, 2, 2, 1807, 1810, 3, 2, 2, 2, 1808,
	1806, 3, 2, 2, 2, 1808, 1809, 3, 2, 2, 2, 1809, 1811, 3, 2, 2, 2, 1810,
	1808, 3, 2, 2, 2, 1811, 1815, 7, 10, 2, 2, 1812, 1814, 7, 7, 2, 2, 1813,
	1812, 3, 2, 2, 2, 1814, 1817, 3, 2, 2, 2, 1815, 1813, 3, 2, 2, 2, 1815,
	1816, 3, 2, 2, 2, 1816, 1820, 3, 2, 2, 2, 1817, 1815, 3, 2, 2, 2, 1818,
	1821, 5, 86, 44, 2, 1819, 1821, 5, 100, 51, 2, 1820, 1818, 3, 2, 2, 2,
	1820, 1819, 3, 2, 2, 2, 1821, 1823, 3, 2, 2, 2, 1822, 1808, 3, 2, 2, 2,
	1823, 1826, 3, 2, 2, 2, 1824, 1822, 3, 2, 2, 2, 1824, 1825, 3, 2, 2, 2,
	1825, 1834, 3, 2, 2, 2, 1826, 1824, 3, 2, 2, 2, 1827, 1829, 7, 7, 2, 2,
	1828, 1827, 3, 2, 2, 2, 1829, 1832, 3, 2, 2, 2, 1830, 1828, 3, 2, 2, 2,
	1830, 1831, 3, 2, 2, 2, 1831, 1833, 3, 2, 2, 2, 1832, 1830, 3, 2, 2, 2,
	1833, 1835, 7, 10, 2, 2, 1834, 1830, 3, 2, 2, 2, 1834, 1835, 3, 2, 2, 2,
	1835, 1839, 3, 2, 2, 2, 1836, 1838, 7, 7, 2, 2, 1837, 1836, 3, 2, 2, 2,
	1838, 1841, 3, 2, 2, 2, 1839, 1837, 3, 2, 2, 2, 1839, 1840, 3, 2, 2, 2,
	1840, 1842, 3, 2, 2, 2, 1841, 1839, 3, 2, 2, 2, 1842, 1843, 7, 12, 2, 2,
	1843, 121, 3, 2, 2, 2, 1844, 1848, 7, 11, 2, 2, 1845, 1847, 7, 7, 2, 2,
	1846, 1845, 3, 2, 2, 2, 1847, 1850, 3, 2, 2, 2, 1848, 1846, 3, 2, 2, 2,
	1848, 1849, 3, 2, 2, 2, 1849, 1851, 3, 2, 2, 2, 1850, 1848, 3, 2, 2, 2,
	1851, 1855, 5, 100, 51, 2, 1852, 1854, 7, 7, 2, 2, 1853, 1852, 3, 2, 2,
	2, 1854, 1857, 3, 2, 2, 2, 1855, 1853, 3, 2, 2, 2, 1855, 1856, 3, 2, 2,
	2, 1856, 1858, 3, 2, 2, 2, 1857, 1855, 3, 2, 2, 2, 1858, 1859, 7, 12, 2,
	2, 1859, 123, 3, 2, 2, 2, 1860, 1862, 5, 306, 154, 2, 1861, 1860, 3, 2,
	2, 2, 1861, 1862, 3, 2, 2, 2, 1862, 1866, 3, 2, 2, 2, 1863, 1867, 5, 122,
	62, 2, 1864, 1867, 5, 104, 53, 2, 1865, 1867, 5, 102, 52, 2, 1866, 1863,
	3, 2, 2, 2, 1866, 1864, 3, 2, 2, 2, 1866, 1865, 3, 2, 2, 2, 1867, 125,
	3, 2, 2, 2, 1868, 1872, 7, 11, 2, 2, 1869, 1871, 7, 7, 2, 2, 1870, 1869,
	3, 2, 2, 2, 1871, 1874, 3, 2, 2, 2, 1872, 1870, 3, 2, 2, 2, 1872, 1873,
	3, 2, 2, 2, 1873, 1877, 3, 2, 2, 2, 1874, 1872, 3, 2, 2, 2, 1875, 1878,
	5, 108, 55, 2, 1876, 1878, 5, 126, 64, 2, 1877, 1875, 3, 2, 2, 2, 1877,
	1876, 3, 2, 2, 2, 1878, 1882, 3, 2, 2, 2, 1879, 1881, 7, 7, 2, 2, 1880,
	1879, 3, 2, 2, 2, 1881, 1884, 3, 2, 2, 2, 1882, 1880, 3, 2, 2, 2, 1882,
	1883, 3, 2, 2, 2, 1883, 1885, 3, 2, 2, 2, 1884, 1882, 3, 2, 2, 2, 1885,
	1886, 7, 12, 2, 2, 1886, 127, 3, 2, 2, 2, 1887, 1893, 5, 130, 66, 2, 1888,
	1889, 5, 150, 76, 2, 1889, 1890, 5, 130, 66, 2, 1890, 1892, 3, 2, 2, 2,
	1891, 1888, 3, 2, 2, 2, 1892, 1895, 3, 2, 2, 2, 1893, 1891, 3, 2, 2, 2,
	1893, 1894, 3, 2, 2, 2, 1894, 1897, 3, 2, 2, 2, 1895, 1893, 3, 2, 2, 2,
	1896, 1887, 3, 2, 2, 2, 1896, 1897, 3, 2, 2, 2, 1897, 1899, 3, 2, 2, 2,
	1898, 1900, 5, 150, 76, 2, 1899, 1898, 3, 2, 2, 2, 1899, 1900, 3, 2, 2,
	2, 1900, 129, 3, 2, 2, 2, 1901, 1904, 5, 132, 67, 2, 1902, 1904, 5, 334,
	168, 2, 1903, 1901, 3, 2, 2, 2, 1903, 1902, 3, 2, 2, 2, 1904, 1907, 3,
	2, 2, 2, 1905, 1903, 3, 2, 2, 2, 1905, 1906, 3, 2, 2, 2, 1906, 1912, 3,
	2, 2, 2, 1907, 1905, 3, 2, 2, 2, 1908, 1913, 5, 22, 12, 2, 1909, 1913,
	5, 146, 74, 2, 1910, 1913, 5, 138, 70, 2, 1911, 1913, 5, 152, 77, 2, 1912,
	1908, 3, 2, 2, 2, 1912, 1909, 3, 2, 2, 2, 1912, 1910, 3, 2, 2, 2, 1912,
	1911, 3, 2, 2, 2, 1913, 131, 3, 2, 2, 2, 1914, 1915, 5, 344, 173, 2, 1915,
	1919, 9, 6, 2, 2, 1916, 1918, 7, 7, 2, 2, 1917, 1916, 3, 2, 2, 2, 1918,
	1921, 3, 2, 2, 2, 1919, 1917, 3, 2, 2, 2, 1919, 1920, 3, 2, 2, 2, 1920,
	133, 3, 2, 2, 2, 1921, 1919, 3, 2, 2, 2, 1922, 1925, 5, 136, 69, 2, 1923,
	1925, 5, 130, 66, 2, 1924, 1922, 3, 2, 2, 2, 1924, 1923, 3, 2, 2, 2, 1925,
	135, 3, 2, 2, 2, 1926, 1930, 7, 15, 2, 2, 1927, 1929, 7, 7, 2, 2, 1928,
	1927, 3, 2, 2, 2, 1929, 1932, 3, 2, 2, 2, 1930, 1928, 3, 2, 2, 2, 1930,
	1931, 3, 2, 2, 2, 1931, 1933, 3, 2, 2, 2, 1932, 1930, 3, 2, 2, 2, 1933,
	1937, 5, 128, 65, 2, 1934, 1936, 7, 7, 2, 2, 1935, 1934, 3, 2, 2, 2, 1936,
	1939, 3, 2, 2, 2, 1937, 1935, 3, 2, 2, 2, 1937, 1938, 3, 2, 2, 2, 1938,
	1940, 3, 2, 2, 2, 1939, 1937, 3, 2, 2, 2, 1940, 1941, 7, 16, 2, 2, 1941,
	137, 3, 2, 2, 2, 1942, 1946, 5, 140, 71, 2, 1943, 1946, 5, 142, 72, 2,
	1944, 1946, 5, 144, 73, 2, 1945, 1942, 3, 2, 2, 2, 1945, 1943, 3, 2, 2,
	2, 1945, 1944, 3, 2, 2, 2, 1946, 139, 3, 2, 2, 2, 1947, 1951, 7, 95, 2,
	2, 1948, 1950, 7, 7, 2, 2, 1949, 1948, 3, 2, 2, 2, 1950, 1953, 3, 2, 2,
	2, 1951, 1949, 3, 2, 2, 2, 1951, 1952, 3, 2, 2, 2, 1952, 1954, 3, 2, 2,
	2, 1953, 1951, 3, 2, 2, 2, 1954, 1958, 7, 11, 2, 2, 1955, 1957, 5, 334,
	168, 2, 1956, 1955, 3, 2, 2, 2, 1957, 1960, 3, 2, 2, 2, 1958, 1956, 3,
	2, 2, 2, 1958, 1959, 3, 2, 2, 2, 1959, 1963, 3, 2, 2, 2, 1960, 1958, 3,
	2, 2, 2, 1961, 1964, 5, 68, 35, 2, 1962, 1964, 5, 70, 36, 2, 1963, 1961,
	3, 2, 2, 2, 1963, 1962, 3, 2, 2, 2, 1964, 1965, 3, 2, 2, 2, 1965, 1966,
	7, 104, 2, 2, 1966, 1967, 5, 152, 77, 2, 1967, 1971, 7, 12, 2, 2, 1968,
	1970, 7, 7, 2, 2, 1969, 1968, 3, 2, 2, 2, 1970, 1973, 3, 2, 2, 2, 1971,
	1969, 3, 2, 2, 2, 1971, 1972, 3, 2, 2, 2, 1972, 1975, 3, 2, 2, 2, 1973,
	1971, 3, 2, 2, 2, 1974, 1976, 5, 134, 68, 2, 1975, 1974, 3, 2, 2, 2, 1975,
	1976, 3, 2, 2, 2, 1976, 141, 3, 2, 2, 2, 1977, 1981, 7, 97, 2, 2, 1978,
	1980, 7, 7, 2, 2, 1979, 1978, 3, 2, 2, 2, 1980, 1983, 3, 2, 2, 2, 1981,
	1979, 3, 2, 2, 2, 1981, 1982, 3, 2, 2, 2, 1982, 1984, 3, 2, 2, 2, 1983,
	1981, 3, 2, 2, 2, 1984, 1985, 7, 11, 2, 2, 1985, 1986, 5, 152, 77, 2, 1986,
	1990, 7, 12, 2, 2, 1987, 1989, 7, 7, 2, 2, 1988, 1987, 3, 2, 2, 2, 1989,
	1992, 3, 2, 2, 2, 1990, 1988, 3, 2, 2, 2, 1990, 1991, 3, 2, 2, 2, 1991,
	1995, 3, 2, 2, 2, 1992, 1990, 3, 2, 2, 2, 1993, 1996, 5, 134, 68, 2, 1994,
	1996, 7, 29, 2, 2, 1995, 1993, 3, 2, 2, 2, 1995, 1994, 3, 2, 2, 2, 1996,
	143, 3, 2, 2, 2, 1997, 2001, 7, 96, 2, 2, 1998, 2000, 7, 7, 2, 2, 1999,
	1998, 3, 2, 2, 2, 2000, 2003, 3, 2, 2, 2, 2001, 1999, 3, 2, 2, 2, 2001,
	2002, 3, 2, 2, 2, 2002, 2005, 3, 2, 2, 2, 2003, 2001, 3, 2, 2, 2, 2004,
	2006, 5, 134, 68, 2, 2005, 2004, 3, 2, 2, 2, 2005, 2006, 3, 2, 2, 2, 2006,
	2010, 3, 2, 2, 2, 2007, 2009, 7, 7, 2, 2, 2008, 2007, 3, 2, 2, 2, 2009,
	2012, 3, 2, 2, 2, 2010, 2008, 3, 2, 2, 2, 2010, 2011, 3, 2, 2, 2, 2011,
	2013, 3, 2, 2, 2, 2012, 2010, 3, 2, 2, 2, 2013, 2017, 7, 97, 2, 2, 2014,
	2016, 7, 7, 2, 2, 2015, 2014, 3, 2, 2, 2, 2016, 2019, 3, 2, 2, 2, 2017,
	2015, 3, 2, 2, 2, 2017, 2018, 3, 2, 2, 2, 2018, 2020, 3, 2, 2, 2, 2019,
	2017, 3, 2, 2, 2, 2020, 2021, 7, 11, 2, 2, 2021, 2022, 5, 152, 77, 2, 2022,
	2023, 7, 12, 2, 2, 2023, 145, 3, 2, 2, 2, 2024, 2025, 5, 188, 95, 2, 2025,
	2026, 7, 30, 2, 2, 2026, 2031, 3, 2, 2, 2, 2027, 2028, 5, 192, 97, 2, 2028,
	2029, 5, 274, 138, 2, 2029, 2031, 3, 2, 2, 2, 2030, 2024, 3, 2, 2, 2, 2030,
	2027, 3, 2, 2, 2, 2031, 2035, 3, 2, 2, 2, 2032, 2034, 7, 7, 2, 2, 2033,
	2032, 3, 2, 2, 2, 2034, 2037, 3, 2, 2, 2, 2035, 2033, 3, 2, 2, 2, 2035,
	2036, 3, 2, 2, 2, 2036, 2038, 3, 2, 2, 2, 2037, 2035, 3, 2, 2, 2, 2038,
	2039, 5, 152, 77, 2, 2039, 147, 3, 2, 2, 2, 2040, 2044, 9, 7, 2, 2, 2041,
	2043, 7, 7, 2, 2, 2042, 2041, 3, 2, 2, 2, 2043, 2046, 3, 2, 2, 2, 2044,
	2042, 3, 2, 2, 2, 2044, 2045, 3, 2, 2, 2, 2045, 2049, 3, 2, 2, 2, 2046,
	2044, 3, 2, 2, 2, 2047, 2049, 7, 2, 2, 3, 2048, 2040, 3, 2, 2, 2, 2048,
	2047, 3, 2, 2, 2, 2049, 149, 3, 2, 2, 2, 2050, 2052, 9, 7, 2, 2, 2051,
	2050, 3, 2, 2, 2, 2052, 2053, 3, 2, 2, 2, 2053, 2051, 3, 2, 2, 2, 2053,
	2054, 3, 2, 2, 2, 2054, 2057, 3, 2, 2, 2, 2055, 2057, 7, 2, 2, 3, 2056,
	2051, 3, 2, 2, 2, 2056, 2055, 3, 2, 2, 2, 2057, 151, 3, 2, 2, 2, 2058,
	2059, 5, 154, 78, 2, 2059, 153, 3, 2, 2, 2, 2060, 2077, 5, 156, 79, 2,
	2061, 2063, 7, 7, 2, 2, 2062, 2061, 3, 2, 2, 2, 2063, 2066, 3, 2, 2, 2,
	2064, 2062, 3, 2, 2, 2, 2064, 2065, 3, 2, 2, 2, 2065, 2067, 3, 2, 2, 2,
	2066, 2064, 3, 2, 2, 2, 2067, 2071, 7, 25, 2, 2, 2068, 2070, 7, 7, 2, 2,
	2069, 2068, 3, 2, 2, 2, 2070, 2073, 3, 2, 2, 2, 2071, 2069, 3, 2, 2, 2,
	2071, 2072, 3, 2, 2, 2, 2072, 2074, 3, 2, 2, 2, 2073, 2071, 3, 2, 2, 2,
	2074, 2076, 5, 156, 79, 2, 2075, 2064, 3, 2, 2, 2, 2076, 2079, 3, 2, 2,
	2, 2077, 2075, 3, 2, 2, 2, 2077, 2078, 3, 2, 2, 2, 2078, 155, 3, 2, 2,
	2, 2079, 2077, 3, 2, 2, 2, 2080, 2097, 5, 158, 80, 2, 2081, 2083, 7, 7,
	2, 2, 2082, 2081, 3, 2, 2, 2, 2083, 2086, 3, 2, 2, 2, 2084, 2082, 3, 2,
	2, 2, 2084, 2085, 3, 2, 2, 2, 2085, 2087, 3, 2, 2, 2, 2086, 2084, 3, 2,
	2, 2, 2087, 2091, 7, 24, 2, 2, 2088, 2090, 7, 7, 2, 2, 2089, 2088, 3, 2,
	2, 2, 2090, 2093, 3, 2, 2, 2, 2091, 2089, 3, 2, 2, 2, 2091, 2092, 3, 2,
	2, 2, 2092, 2094, 3, 2, 2, 2, 2093, 2091, 3, 2, 2, 2, 2094, 2096, 5, 158,
	80, 2, 2095, 2084, 3, 2, 2, 2, 2096, 2099, 3, 2, 2, 2, 2097, 2095, 3, 2,
	2, 2, 2097, 2098, 3, 2, 2, 2, 2098, 157, 3, 2, 2, 2, 2099, 2097, 3, 2,
	2, 2, 2100, 2112, 5, 160, 81, 2, 2101, 2105, 5, 276, 139, 2, 2102, 2104,
	7, 7, 2, 2, 2103, 2102, 3, 2, 2, 2, 2104, 2107, 3, 2, 2, 2, 2105, 2103,
	3, 2, 2, 2, 2105, 2106, 3, 2, 2, 2, 2106, 2108, 3, 2, 2, 2, 2107, 2105,
	3, 2, 2, 2, 2108, 2109, 5, 160, 81, 2, 2109, 2111, 3, 2, 2, 2, 2110, 2101,
	3, 2, 2, 2, 2111, 2114, 3, 2, 2, 2, 2112, 2110, 3, 2, 2, 2, 2112, 2113,
	3, 2, 2, 2, 2113, 159, 3, 2, 2, 2, 2114, 2112, 3, 2, 2, 2, 2115, 2127,
	5, 162, 82, 2, 2116, 2120, 5, 278, 140, 2, 2117, 2119, 7, 7, 2, 2, 2118,
	2117, 3, 2, 2, 2, 2119, 2122, 3, 2, 2, 2, 2120, 2118, 3, 2, 2, 2, 2120,
	2121, 3, 2, 2, 2, 2121, 2123, 3, 2, 2, 2, 2122, 2120, 3, 2, 2, 2, 2123,
	2124, 5, 162, 82, 2, 2124, 2126, 3, 2, 2, 2, 2125, 2116, 3, 2, 2, 2, 2126,
	2129, 3, 2, 2, 2, 2127, 2125, 3, 2, 2, 2, 2127, 2128, 3, 2, 2, 2, 2128,
	161, 3, 2, 2, 2, 2129, 2127, 3, 2, 2, 2, 2130, 2134, 5, 164, 83, 2, 2131,
	2133, 5, 202, 102, 2, 2132, 2131, 3, 2, 2, 2, 2133, 2136, 3, 2, 2, 2, 2134,
	2132, 3, 2, 2, 2, 2134, 2135, 3, 2, 2, 2, 2135, 163, 3, 2, 2, 2, 2136,
	2134, 3, 2, 2, 2, 2137, 2158, 5, 166, 84, 2, 2138, 2142, 5, 280, 141, 2,
	2139, 2141, 7, 7, 2, 2, 2140, 2139, 3, 2, 2, 2, 2141, 2144, 3, 2, 2, 2,
	2142, 2140, 3, 2, 2, 2, 2142, 2143, 3, 2, 2, 2, 2143, 2145, 3, 2, 2, 2,
	2144, 2142, 3, 2, 2, 2, 2145, 2146, 5, 166, 84, 2, 2146, 2157, 3, 2, 2,
	2, 2147, 2151, 5, 282, 142, 2, 2148, 2150, 7, 7, 2, 2, 2149, 2148, 3, 2,
	2, 2, 2150, 2153, 3, 2, 2, 2, 2151, 2149, 3, 2, 2, 2, 2151, 2152, 3, 2,
	2, 2, 2152, 2154, 3, 2, 2, 2, 2153, 2151, 3, 2, 2, 2, 2154, 2155, 5, 100,
	51, 2, 2155, 2157, 3, 2, 2, 2, 2156, 2138, 3, 2, 2, 2, 2156, 2147, 3, 2,
	2, 2, 2157, 2160, 3, 2, 2, 2, 2158, 2156, 3, 2, 2, 2, 2158, 2159, 3, 2,
	2, 2, 2159, 165, 3, 2, 2, 2, 2160, 2158, 3, 2, 2, 2, 2161, 2179, 5, 170,
	86, 2, 2162, 2164, 7, 7, 2, 2, 2163, 2162, 3, 2, 2, 2, 2164, 2167, 3, 2,
	2, 2, 2165, 2163, 3, 2, 2, 2, 2165, 2166, 3, 2, 2, 2, 2166, 2168, 3, 2,
	2, 2, 2167, 2165, 3, 2, 2, 2, 2168, 2172, 5, 168, 85, 2, 2169, 2171, 7,
	7, 2, 2, 2170, 2169, 3, 2, 2, 2, 2171, 2174, 3, 2, 2, 2, 2172, 2170, 3,
	2, 2, 2, 2172, 2173, 3, 2, 2, 2, 2173, 2175, 3, 2, 2, 2, 2174, 2172, 3,
	2, 2, 2, 2175, 2176, 5, 170, 86, 2, 2176, 2178, 3, 2, 2, 2, 2177, 2165,
	3, 2, 2, 2, 2178, 2181, 3, 2, 2, 2, 2179, 2177, 3, 2, 2, 2, 2179, 2180,
	3, 2, 2, 2, 2180, 167, 3, 2, 2, 2, 2181, 2179, 3, 2, 2, 2, 2182, 2183,
	7, 47, 2, 2, 2183, 2184, 7, 28, 2, 2, 2184, 169, 3, 2, 2, 2, 2185, 2197,
	5, 172, 87, 2, 2186, 2190, 5, 344, 173, 2, 2187, 2189, 7, 7, 2, 2, 2188,
	2187, 3, 2, 2, 2, 2189, 2192, 3, 2, 2, 2, 2190, 2188, 3, 2, 2, 2, 2190,
	2191, 3, 2, 2, 2, 2191, 2193, 3, 2, 2, 2, 2192, 2190, 3, 2, 2, 2, 2193,
	2194, 5, 172, 87, 2, 2194, 2196, 3, 2, 2, 2, 2195, 2186, 3, 2, 2, 2, 2196,
	2199, 3, 2, 2, 2, 2197, 2195, 3, 2, 2, 2, 2197, 2198, 3, 2, 2, 2, 2198,
	171, 3, 2, 2, 2, 2199, 2197, 3, 2, 2, 2, 2200, 2211, 5, 174, 88, 2, 2201,
	2205, 7, 38, 2, 2, 2202, 2204, 7, 7, 2, 2, 2203, 2202, 3, 2, 2, 2, 2204,
	2207, 3, 2, 2, 2, 2205, 2203, 3, 2, 2, 2, 2205, 2206, 3, 2, 2, 2, 2206,
	2208, 3, 2, 2, 2, 2207, 2205, 3, 2, 2, 2, 2208, 2210, 5, 174, 88, 2, 2209,
	2201, 3, 2, 2, 2, 2210, 2213, 3, 2, 2, 2, 2211, 2209, 3, 2, 2, 2, 2211,
	2212, 3, 2, 2, 2, 2212, 173, 3, 2, 2, 2, 2213, 2211, 3, 2, 2, 2, 2214,
	2226, 5, 176, 89, 2, 2215, 2219, 5, 284, 143, 2, 2216, 2218, 7, 7, 2, 2,
	2217, 2216, 3, 2, 2, 2, 2218, 2221, 3, 2, 2, 2, 2219, 2217, 3, 2, 2, 2,
	2219, 2220, 3, 2, 2, 2, 2220, 2222, 3, 2, 2, 2, 2221, 2219, 3, 2, 2, 2,
	2222, 2223, 5, 176, 89, 2, 2223, 2225, 3, 2, 2, 2, 2224, 2215, 3, 2, 2,
	2, 2225, 2228, 3, 2, 2, 2, 2226, 2224, 3, 2, 2, 2, 2226, 2227, 3, 2, 2,
	2, 2227, 175, 3, 2, 2, 2, 2228, 2226, 3, 2, 2, 2, 2229, 2241, 5, 178, 90,
	2, 2230, 2234, 5, 286, 144, 2, 2231, 2233, 7, 7, 2, 2, 2232, 2231, 3, 2,
	2, 2, 2233, 2236, 3, 2, 2, 2, 2234, 2232, 3, 2, 2, 2, 2234, 2235, 3, 2,
	2, 2, 2235, 2237, 3, 2, 2, 2, 2236, 2234, 3, 2, 2, 2, 2237, 2238, 5, 178,
	90, 2, 2238, 2240, 3, 2, 2, 2, 2239, 2230, 3, 2, 2, 2, 2240, 2243, 3, 2,
	2, 2, 2241, 2239, 3, 2, 2, 2, 2241, 2242, 3, 2, 2, 2, 2242, 177, 3, 2,
	2, 2, 2243, 2241, 3, 2, 2, 2, 2244, 2262, 5, 180, 91, 2, 2245, 2247, 7,
	7, 2, 2, 2246, 2245, 3, 2, 2, 2, 2247, 2250, 3, 2, 2, 2, 2248, 2246, 3,
	2, 2, 2, 2248, 2249, 3, 2, 2, 2, 2249, 2251, 3, 2, 2, 2, 2250, 2248, 3,
	2, 2, 2, 2251, 2255, 5, 288, 145, 2, 2252, 2254, 7, 7, 2, 2, 2253, 2252,
	3, 2, 2, 2, 2254, 2257, 3, 2, 2, 2, 2255, 2253, 3, 2, 2, 2, 2255, 2256,
	3, 2, 2, 2, 2256, 2258, 3, 2, 2, 2, 2257, 2255, 3, 2, 2, 2, 2258, 2259,
	5, 100, 51, 2, 2259, 2261, 3, 2, 2, 2, 2260, 2248, 3, 2, 2, 2, 2261, 2264,
	3, 2, 2, 2, 2262, 2260, 3, 2, 2, 2, 2262, 2263, 3, 2, 2, 2, 2263, 179,
	3, 2, 2, 2, 2264, 2262, 3, 2, 2, 2, 2265, 2267, 5, 182, 92, 2, 2266, 2265,
	3, 2, 2, 2, 2267, 2270, 3, 2, 2, 2, 2268, 2266, 3, 2, 2, 2, 2268, 2269,
	3, 2, 2, 2, 2269, 2271, 3, 2, 2, 2, 2270, 2268, 3, 2, 2, 2, 2271, 2272,
	5, 184, 93, 2, 2272, 181, 3, 2, 2, 2, 2273, 2283, 5, 334, 168, 2, 2274,
	2283, 5, 132, 67, 2, 2275, 2279, 5, 290, 146, 2, 2276, 2278, 7, 7, 2, 2,
	2277, 2276, 3, 2, 2, 2, 2278, 2281, 3, 2, 2, 2, 2279, 2277, 3, 2, 2, 2,
	2279, 2280, 3, 2, 2, 2, 2280, 2283, 3, 2, 2, 2, 2281, 2279, 3, 2, 2, 2,
	2282, 2273, 3, 2, 2, 2, 2282, 2274, 3, 2, 2, 2, 2282, 2275, 3, 2, 2, 2,
	2283, 183, 3, 2, 2, 2, 2284, 2288, 5, 212, 107, 2, 2285, 2287, 5, 186,
	94, 2, 2286, 2285, 3, 2, 2, 2, 2287, 2290, 3, 2, 2, 2, 2288, 2286, 3, 2,
	2, 2, 2288, 2289, 3, 2, 2, 2, 2289, 185, 3, 2, 2, 2, 2290, 2288, 3, 2,
	2, 2, 2291, 2297, 5, 292, 147, 2, 2292, 2297, 5, 206, 104, 2, 2293, 2297,
	5, 202, 102, 2, 2294, 2297, 5, 198, 100, 2, 2295, 2297, 5, 200, 101, 2,
	2296, 2291, 3, 2, 2, 2, 2296, 2292, 3, 2, 2, 2, 2296, 2293, 3, 2, 2, 2,
	2296, 2294, 3, 2, 2, 2, 2296, 2295, 3, 2, 2, 2, 2297, 187, 3, 2, 2, 2,
	2298, 2299, 5, 184, 93, 2, 2299, 2300, 5, 196, 99, 2, 2300, 2304, 3, 2,
	2, 2, 2301, 2304, 5, 344, 173, 2, 2302, 2304, 5, 190, 96, 2, 2303, 2298,
	3, 2, 2, 2, 2303, 2301, 3, 2, 2, 2, 2303, 2302, 3, 2, 2, 2, 2304, 189,
	3, 2, 2, 2, 2305, 2309, 7, 11, 2, 2, 2306, 2308, 7, 7, 2, 2, 2307, 2306,
	3, 2, 2, 2, 2308, 2311, 3, 2, 2, 2, 2309, 2307, 3, 2, 2, 2, 2309, 2310,
	3, 2, 2, 2, 2310, 2312, 3, 2, 2, 2, 2311, 2309, 3, 2, 2, 2, 2312, 2316,
	5, 188, 95, 2, 2313, 2315, 7, 7, 2, 2, 2314, 2313, 3, 2, 2, 2, 2315, 2318,
	3, 2, 2, 2, 2316, 2314, 3, 2, 2, 2, 2316, 2317, 3, 2, 2, 2, 2317, 2319,
	3, 2, 2, 2, 2318, 2316, 3, 2, 2, 2, 2319, 2320, 7, 12, 2, 2, 2320, 191,
	3, 2, 2, 2, 2321, 2324, 5, 180, 91, 2, 2322, 2324, 5, 194, 98, 2, 2323,
	2321, 3, 2, 2, 2, 2323, 2322, 3, 2, 2, 2, 2324, 193, 3, 2, 2, 2, 2325,
	2329, 7, 11, 2, 2, 2326, 2328, 7, 7, 2, 2, 2327, 2326, 3, 2, 2, 2, 2328,
	2331, 3, 2, 2, 2, 2329, 2327, 3, 2, 2, 2, 2329, 2330, 3, 2, 2, 2, 2330,
	2332, 3, 2, 2, 2, 2331, 2329, 3, 2, 2, 2, 2332, 2336, 5, 192, 97, 2, 2333,
	2335, 7, 7, 2, 2, 2334, 2333, 3, 2, 2, 2, 2335, 2338, 3, 2, 2, 2, 2336,
	2334, 3, 2, 2, 2, 2336, 2337, 3, 2, 2, 2, 2337, 2339, 3, 2, 2, 2, 2338,
	2336, 3, 2, 2, 2, 2339, 2340, 7, 12, 2, 2, 2340, 195, 3, 2, 2, 2, 2341,
	2345, 5, 206, 104, 2, 2342, 2345, 5, 198, 100, 2, 2343, 2345, 5, 200, 101,
	2, 2344, 2341, 3, 2, 2, 2, 2344, 2342, 3, 2, 2, 2, 2344, 2343, 3, 2, 2,
	2, 2345, 197, 3, 2, 2, 2, 2346, 2350, 7, 13, 2, 2, 2347, 2349, 7, 7, 2,
	2, 2348, 2347, 3, 2, 2, 2, 2349, 2352, 3, 2, 2, 2, 2350, 2348, 3, 2, 2,
	2, 2350, 2351, 3, 2, 2, 2, 2351, 2353, 3, 2, 2, 2, 2352, 2350, 3, 2, 2,
	2, 2353, 2370, 5, 152, 77, 2, 2354, 2356, 7, 7, 2, 2, 2355, 2354, 3, 2,
	2, 2, 2356, 2359, 3, 2, 2, 2, 2357, 2355, 3, 2, 2, 2, 2357, 2358, 3, 2,
	2, 2, 2358, 2360, 3, 2, 2, 2, 2359, 2357, 3, 2, 2, 2, 2360, 2364, 7, 10,
	2, 2, 2361, 2363, 7, 7, 2, 2, 2362, 2361, 3, 2, 2, 2, 2363, 2366, 3, 2,
	2, 2, 2364, 2362, 3, 2, 2, 2, 2364, 2365, 3, 2, 2, 2, 2365, 2367, 3, 2,
	2, 2, 2366, 2364, 3, 2, 2, 2, 2367, 2369, 5, 152, 77, 2, 2368, 2357, 3,
	2, 2, 2, 2369, 2372, 3, 2, 2, 2, 2370, 2368, 3, 2, 2, 2, 2370, 2371, 3,
	2, 2, 2, 2371, 2380, 3, 2, 2, 2, 2372, 2370, 3, 2, 2, 2, 2373, 2375, 7,
	7, 2, 2, 2374, 2373, 3, 2, 2, 2, 2375, 2378, 3, 2, 2, 2, 2376, 2374, 3,
	2, 2, 2, 2376, 2377, 3, 2, 2, 2, 2377, 2379, 3, 2, 2, 2, 2378, 2376, 3,
	2, 2, 2, 2379, 2381, 7, 10, 2, 2, 2380, 2376, 3, 2, 2, 2, 2380, 2381, 3,
	2, 2, 2, 2381, 2385, 3, 2, 2, 2, 2382, 2384, 7, 7, 2, 2, 2383, 2382, 3,
	2, 2, 2, 2384, 2387, 3, 2, 2, 2, 2385, 2383, 3, 2, 2, 2, 2385, 2386, 3,
	2, 2, 2, 2386, 2388, 3, 2, 2, 2, 2387, 2385, 3, 2, 2, 2, 2388, 2389, 7,
	14, 2, 2, 2389, 199, 3, 2, 2, 2, 2390, 2394, 5, 296, 149, 2, 2391, 2393,
	7, 7, 2, 2, 2392, 2391, 3, 2, 2, 2, 2393, 2396, 3, 2, 2, 2, 2394, 2392,
	3, 2, 2, 2, 2394, 2395, 3, 2, 2, 2, 2395, 2400, 3, 2, 2, 2, 2396, 2394,
	3, 2, 2, 2, 2397, 2401, 5, 344, 173, 2, 2398, 2401, 5, 214, 108, 2, 2399,
	2401, 7, 74, 2, 2, 2400, 2397, 3, 2, 2, 2, 2400, 2398, 3, 2, 2, 2, 2400,
	2399, 3, 2, 2, 2, 2401, 201, 3, 2, 2, 2, 2402, 2404, 5, 206, 104, 2, 2403,
	2402, 3, 2, 2, 2, 2403, 2404, 3, 2, 2, 2, 2404, 2410, 3, 2, 2, 2, 2405,
	2407, 5, 208, 105, 2, 2406, 2405, 3, 2, 2, 2, 2406, 2407, 3, 2, 2, 2, 2407,
	2408, 3, 2, 2, 2, 2408, 2411, 5, 204, 103, 2, 2409, 2411, 5, 208, 105,
	2, 2410, 2406, 3, 2, 2, 2, 2410, 2409, 3, 2, 2, 2, 2411, 203, 3, 2, 2,
	2, 2412, 2414, 5, 334, 168, 2, 2413, 2412, 3, 2, 2, 2, 2414, 2417, 3, 2,
	2, 2, 2415, 2413, 3, 2, 2, 2, 2415, 2416, 3, 2, 2, 2, 2416, 2419, 3, 2,
	2, 2, 2417, 2415, 3, 2, 2, 2, 2418, 2420, 5, 132, 67, 2, 2419, 2418, 3,
	2, 2, 2, 2419, 2420, 3, 2, 2, 2, 2420, 2424, 3, 2, 2, 2, 2421, 2423, 7,
	7, 2, 2, 2422, 2421, 3, 2, 2, 2, 2423, 2426, 3, 2, 2, 2, 2424, 2422, 3,
	2, 2, 2, 2424, 2425, 3, 2, 2, 2, 2425, 2427, 3, 2, 2, 2, 2426, 2424, 3,
	2, 2, 2, 2427, 2428, 5, 234, 118, 2, 2428, 205, 3, 2, 2, 2, 2429, 2433,
	7, 48, 2, 2, 2430, 2432, 7, 7, 2, 2, 2431, 2430, 3, 2, 2, 2, 2432, 2435,
	3, 2, 2, 2, 2433, 2431, 3, 2, 2, 2, 2433, 2434, 3, 2, 2, 2, 2434, 2436,
	3, 2, 2, 2, 2435, 2433, 3, 2, 2, 2, 2436, 2453, 5, 112, 57, 2, 2437, 2439,
	7, 7, 2, 2, 2438, 2437, 3, 2, 2, 2, 2439, 2442, 3, 2, 2, 2, 2440, 2438,
	3, 2, 2, 2, 2440, 2441, 3, 2, 2, 2, 2441, 2443, 3, 2, 2, 2, 2442, 2440,
	3, 2, 2, 2, 2443, 2447, 7, 10, 2, 2, 2444, 2446, 7, 7, 2, 2, 2445, 2444,
	3, 2, 2, 2, 2446, 2449, 3, 2, 2, 2, 2447, 2445, 3, 2, 2, 2, 2447, 2448,
	3, 2, 2, 2, 2448, 2450, 3, 2, 2, 2, 2449, 2447, 3, 2, 2, 2, 2450, 2452,
	5, 112, 57, 2, 2451, 2440, 3, 2, 2, 2, 2452, 2455, 3, 2, 2, 2, 2453, 2451,
	3, 2, 2, 2, 2453, 2454, 3, 2, 2, 2, 2454, 2463, 3, 2, 2, 2, 2455, 2453,
	3, 2, 2, 2, 2456, 2458, 7, 7, 2, 2, 2457, 2456, 3, 2, 2, 2, 2458, 2461,
	3, 2, 2, 2, 2459, 2457, 3, 2, 2, 2, 2459, 2460, 3, 2, 2, 2, 2460, 2462,
	3, 2, 2, 2, 2461, 2459, 3, 2, 2, 2, 2462, 2464, 7, 10, 2, 2, 2463, 2459,
	3, 2, 2, 2, 2463, 2464, 3, 2, 2, 2, 2464, 2468, 3, 2, 2, 2, 2465, 2467,
	7, 7, 2, 2, 2466, 2465, 3, 2, 2, 2, 2467, 2470, 3, 2, 2, 2, 2468, 2466,
	3, 2, 2, 2, 2468, 2469, 3, 2, 2, 2, 2469, 2471, 3, 2, 2, 2, 2470, 2468,
	3, 2, 2, 2, 2471, 2472, 7, 49, 2, 2, 2472, 207, 3, 2, 2, 2, 2473, 2477,
	7, 11, 2, 2, 2474, 2476, 7, 7, 2, 2, 2475, 2474, 3, 2, 2, 2, 2476, 2479,
	3, 2, 2, 2, 2477, 2475, 3, 2, 2, 2, 2477, 2478, 3, 2, 2, 2, 2478, 2515,
	3, 2, 2, 2, 2479, 2477, 3, 2, 2, 2, 2480, 2497, 5, 210, 106, 2, 2481, 2483,
	7, 7, 2, 2, 2482, 2481, 3, 2, 2, 2, 2483, 2486, 3, 2, 2, 2, 2484, 2482,
	3, 2, 2, 2, 2484, 2485, 3, 2, 2, 2, 2485, 2487, 3, 2, 2, 2, 2486, 2484,
	3, 2, 2, 2, 2487, 2491, 7, 10, 2, 2, 2488, 2490, 7, 7, 2, 2, 2489, 2488,
	3, 2, 2, 2, 2490, 2493, 3, 2, 2, 2, 2491, 2489, 3, 2, 2, 2, 2491, 2492,
	3, 2, 2, 2, 2492, 2494, 3, 2, 2, 2, 2493, 2491, 3, 2, 2, 2, 2494, 2496,
	5, 210, 106, 2, 2495, 2484, 3, 2, 2, 2, 2496, 2499, 3, 2, 2, 2, 2497, 2495,
	3, 2, 2, 2, 2497, 2498, 3, 2, 2, 2, 2498, 2507, 3, 2, 2, 2, 2499, 2497,
	3, 2, 2, 2, 2500, 2502, 7, 7, 2, 2, 2501, 2500, 3, 2, 2, 2, 2502, 2505,
	3, 2, 2, 2, 2503, 2501, 3, 2, 2, 2, 2503, 2504, 3, 2, 2, 2, 2504, 2506,
	3, 2, 2, 2, 2505, 2503, 3, 2, 2, 2, 2506, 2508, 7, 10, 2, 2, 2507, 2503,
	3, 2, 2, 2, 2507, 2508, 3, 2, 2, 2, 2508, 2512, 3, 2, 2, 2, 2509, 2511,
	7, 7, 2, 2, 2510, 2509, 3, 2, 2, 2, 2511, 2514, 3, 2, 2, 2, 2512, 2510,
	3, 2, 2, 2, 2512, 2513, 3, 2, 2, 2, 2513, 2516, 3, 2, 2, 2, 2514, 2512,
	3, 2, 2, 2, 2515, 2480, 3, 2, 2, 2, 2515, 2516, 3, 2, 2, 2, 2516, 2517,
	3, 2, 2, 2, 2517, 2518, 7, 12, 2, 2, 2518, 209, 3, 2, 2, 2, 2519, 2521,
	5, 334, 168, 2, 2520, 2519, 3, 2, 2, 2, 2520, 2521, 3, 2, 2, 2, 2521, 2525,
	3, 2, 2, 2, 2522, 2524, 7, 7, 2, 2, 2523, 2522, 3, 2, 2, 2, 2524, 2527,
	3, 2, 2, 2, 2525, 2523, 3, 2, 2, 2, 2525, 2526, 3, 2, 2, 2, 2526, 2542,
	3, 2, 2, 2, 2527, 2525, 3, 2, 2, 2, 2528, 2532, 5, 344, 173, 2, 2529, 2531,
	7, 7, 2, 2, 2530, 2529, 3, 2, 2, 2, 2531, 2534, 3, 2, 2, 2, 2532, 2530,
	3, 2, 2, 2, 2532, 2533, 3, 2, 2, 2, 2533, 2535, 3, 2, 2, 2, 2534, 2532,
	3, 2, 2, 2, 2535, 2539, 7, 30, 2, 2, 2536, 2538, 7, 7, 2, 2, 2537, 2536,
	3, 2, 2, 2, 2538, 2541, 3, 2, 2, 2, 2539, 2537, 3, 2, 2, 2, 2539, 2540,
	3, 2, 2, 2, 2540, 2543, 3, 2, 2, 2, 2541, 2539, 3, 2, 2, 2, 2542, 2528,
	3, 2, 2, 2, 2542, 2543, 3, 2, 2, 2, 2543, 2545, 3, 2, 2, 2, 2544, 2546,
	7, 17, 2, 2, 2545, 2544, 3, 2, 2, 2, 2545, 2546, 3, 2, 2, 2, 2546, 2550,
	3, 2, 2, 2, 2547, 2549, 7, 7, 2, 2, 2548, 2547, 3, 2, 2, 2, 2549, 2552,
	3, 2, 2, 2, 2550, 2548, 3, 2, 2, 2, 2550, 2551, 3, 2, 2, 2, 2551, 2553,
	3, 2, 2, 2, 2552, 2550, 3, 2, 2, 2, 2553, 2554, 5, 152, 77, 2, 2554, 211,
	3, 2, 2, 2, 2555, 2570, 5, 214, 108, 2, 2556, 2570, 5, 344, 173, 2, 2557,
	2570, 5, 218, 110, 2, 2558, 2570, 5, 220, 111, 2, 2559, 2570, 5, 272, 137,
	2, 2560, 2570, 5, 242, 122, 2, 2561, 2570, 5, 244, 123, 2, 2562, 2570,
	5, 216, 109, 2, 2563, 2570, 5, 246, 124, 2, 2564, 2570, 5, 248, 125, 2,
	2565, 2570, 5, 250, 126, 2, 2566, 2570, 5, 254, 128, 2, 2567, 2570, 5,
	264, 133, 2, 2568, 2570, 5, 270, 136, 2, 2569, 2555, 3, 2, 2, 2, 2569,
	2556, 3, 2, 2, 2, 2569, 2557, 3, 2, 2, 2, 2569, 2558, 3, 2, 2, 2, 2569,
	2559, 3, 2, 2, 2, 2569, 2560, 3, 2, 2, 2, 2569, 2561, 3, 2, 2, 2, 2569,
	2562, 3, 2, 2, 2, 2569, 2563, 3, 2, 2, 2, 2569, 2564, 3, 2, 2, 2, 2569,
	2565, 3, 2, 2, 2, 2569, 2566, 3, 2, 2, 2, 2569, 2567, 3, 2, 2, 2, 2569,
	2568, 3, 2, 2, 2, 2570, 213, 3, 2, 2, 2, 2571, 2575, 7, 11, 2, 2, 2572,
	2574, 7, 7, 2, 2, 2573, 2572, 3, 2, 2, 2, 2574, 2577, 3, 2, 2, 2, 2575,
	2573, 3, 2, 2, 2, 2575, 2576, 3, 2, 2, 2, 2576, 2578, 3, 2, 2, 2, 2577,
	2575, 3, 2, 2, 2, 2578, 2582, 5, 152, 77, 2, 2579, 2581, 7, 7, 2, 2, 2580,
	2579, 3, 2, 2, 2, 2581, 2584, 3, 2, 2, 2, 2582, 2580, 3, 2, 2, 2, 2582,
	2583, 3, 2, 2, 2, 2583, 2585, 3, 2, 2, 2, 2584, 2582, 3, 2, 2, 2, 2585,
	2586, 7, 12, 2, 2, 2586, 215, 3, 2, 2, 2, 2587, 2591, 7, 13, 2, 2, 2588,
	2590, 7, 7, 2, 2, 2589, 2588, 3, 2, 2, 2, 2590, 2593, 3, 2, 2, 2, 2591,
	2589, 3, 2, 2, 2, 2591, 2592, 3, 2, 2, 2, 2592, 2629, 3, 2, 2, 2, 2593,
	2591, 3, 2, 2, 2, 2594, 2611, 5, 152, 77, 2, 2595, 2597, 7, 7, 2, 2, 2596,
	2595, 3, 2, 2, 2, 2597, 2600, 3, 2, 2, 2, 2598, 2596, 3, 2, 2, 2, 2598,
	2599, 3, 2, 2, 2, 2599, 2601, 3, 2, 2, 2, 2600, 2598, 3, 2, 2, 2, 2601,
	2605, 7, 10, 2, 2, 2602, 2604, 7, 7, 2, 2, 2603, 2602, 3, 2, 2, 2, 2604,
	2607, 3, 2, 2, 2, 2605, 2603, 3, 2, 2, 2, 2605, 2606, 3, 2, 2, 2, 2606,
	2608, 3, 2, 2, 2, 2607, 2605, 3, 2, 2, 2, 2608, 2610, 5, 152, 77, 2, 2609,
	2598, 3, 2, 2, 2, 2610, 2613, 3, 2, 2, 2, 2611, 2609, 3, 2, 2, 2, 2611,
	2612, 3, 2, 2, 2, 2612, 2621, 3, 2, 2, 2, 2613, 2611, 3, 2, 2, 2, 2614,
	2616, 7, 7, 2, 2, 2615, 2614, 3, 2, 2, 2, 2616, 2619, 3, 2, 2, 2, 2617,
	2615, 3, 2, 2, 2, 2617, 2618, 3, 2, 2, 2, 2618, 2620, 3, 2, 2, 2, 2619,
	2617, 3, 2, 2, 2, 2620, 2622, 7, 10, 2, 2, 2621, 2617, 3, 2, 2, 2, 2621,
	2622, 3, 2, 2, 2, 2622, 2626, 3, 2, 2, 2, 2623, 2625, 7, 7, 2, 2, 2624,
	2623, 3, 2, 2, 2, 2625, 2628, 3, 2, 2, 2, 2626, 2624, 3, 2, 2, 2, 2626,
	2627, 3, 2, 2, 2, 2627, 2630, 3, 2, 2, 2, 2628, 2626, 3, 2, 2, 2, 2629,
	2594, 3, 2, 2, 2, 2629, 2630, 3, 2, 2, 2, 2630, 2631, 3, 2, 2, 2, 2631,
	2632, 7, 14, 2, 2, 2632, 217, 3, 2, 2, 2, 2633, 2634, 9, 8, 2, 2, 2634,
	219, 3, 2, 2, 2, 2635, 2638, 5, 222, 112, 2, 2636, 2638, 5, 224, 113, 2,
	2637, 2635, 3, 2, 2, 2, 2637, 2636, 3, 2, 2, 2, 2638, 221, 3, 2, 2, 2,
	2639, 2644, 7, 151, 2, 2, 2640, 2643, 5, 226, 114, 2, 2641, 2643, 5, 228,
	115, 2, 2642, 2640, 3, 2, 2, 2, 2642, 2641, 3, 2, 2, 2, 2643, 2646, 3,
	2, 2, 2, 2644, 2642, 3, 2, 2, 2, 2644, 2645, 3, 2, 2, 2, 2645, 2647, 3,
	2, 2, 2, 2646, 2644, 3, 2, 2, 2, 2647, 2648, 7, 160, 2, 2, 2648, 223, 3,
	2, 2, 2, 2649, 2655, 7, 152, 2, 2, 2650, 2654, 5, 230, 116, 2, 2651, 2654,
	5, 232, 117, 2, 2652, 2654, 7, 166, 2, 2, 2653, 2650, 3, 2, 2, 2, 2653,
	2651, 3, 2, 2, 2, 2653, 2652, 3, 2, 2, 2, 2654, 2657, 3, 2, 2, 2, 2655,
	2653, 3, 2, 2, 2, 2655, 2656, 3, 2, 2, 2, 2656, 2658, 3, 2, 2, 2, 2657,
	2655, 3, 2, 2, 2, 2658, 2659, 7, 165, 2, 2, 2659, 225, 3, 2, 2, 2, 2660,
	2661, 9, 9, 2, 2, 2661, 227, 3, 2, 2, 2, 2662, 2666, 7, 164, 2, 2, 2663,
	2665, 7, 7, 2, 2, 2664, 2663, 3, 2, 2, 2, 2665, 2668, 3, 2, 2, 2, 2666,
	2664, 3, 2, 2, 2, 2666, 2667, 3, 2, 2, 2, 2667, 2669, 3, 2, 2, 2, 2668,
	2666, 3, 2, 2, 2, 2669, 2673, 5, 152, 77, 2, 2670, 2672, 7, 7, 2, 2, 2671,
	2670, 3, 2, 2, 2, 2672, 2675, 3, 2, 2, 2, 2673, 2671, 3, 2, 2, 2, 2673,
	2674, 3, 2, 2, 2, 2674, 2676, 3, 2, 2, 2, 2675, 2673, 3, 2, 2, 2, 2676,
	2677, 7, 16, 2, 2, 2677, 229, 3, 2, 2, 2, 2678, 2679, 9, 10, 2, 2, 2679,
	231, 3, 2, 2, 2, 2680, 2684, 7, 169, 2, 2, 2681, 2683, 7, 7, 2, 2, 2682,
	2681, 3, 2, 2, 2, 2683, 2686, 3, 2, 2, 2, 2684, 2682, 3, 2, 2, 2, 2684,
	2685, 3, 2, 2, 2, 2685, 2687, 3, 2, 2, 2, 2686, 2684, 3, 2, 2, 2, 2687,
	2691, 5, 152, 77, 2, 2688, 2690, 7, 7, 2, 2, 2689, 2688, 3, 2, 2, 2, 2690,
	2693, 3, 2, 2, 2, 2691, 2689, 3, 2, 2, 2, 2691, 2692, 3, 2, 2, 2, 2692,
	2694, 3, 2, 2, 2, 2693, 2691, 3, 2, 2, 2, 2694, 2695, 7, 16, 2, 2, 2695,
	233, 3, 2, 2, 2, 2696, 2700, 7, 15, 2, 2, 2697, 2699, 7, 7, 2, 2, 2698,
	2697, 3, 2, 2, 2, 2699, 2702, 3, 2, 2, 2, 2700, 2698, 3, 2, 2, 2, 2700,
	2701, 3, 2, 2, 2, 2701, 2719, 3, 2, 2, 2, 2702, 2700, 3, 2, 2, 2, 2703,
	2705, 5, 236, 119, 2, 2704, 2703, 3, 2, 2, 2, 2704, 2705, 3, 2, 2, 2, 2705,
	2709, 3, 2, 2, 2, 2706, 2708, 7, 7, 2, 2, 2707, 2706, 3, 2, 2, 2, 2708,
	2711, 3, 2, 2, 2, 2709, 2707, 3, 2, 2, 2, 2709, 2710, 3, 2, 2, 2, 2710,
	2712, 3, 2, 2, 2, 2711, 2709, 3, 2, 2, 2, 2712, 2716, 7, 36, 2, 2, 2713,
	2715, 7, 7, 2, 2, 2714, 2713, 3, 2, 2, 2, 2715, 2718, 3, 2, 2, 2, 2716,
	2714, 3, 2, 2, 2, 2716, 2717, 3, 2, 2, 2, 2717, 2720, 3, 2, 2, 2, 2718,
	2716, 3, 2, 2, 2, 2719, 2704, 3, 2, 2, 2, 2719, 2720, 3, 2, 2, 2, 2720,
	2721, 3, 2, 2, 2, 2721, 2725, 5, 128, 65, 2, 2722, 2724, 7, 7, 2, 2, 2723,
	2722, 3, 2, 2, 2, 2724, 2727, 3, 2, 2, 2, 2725, 2723, 3, 2, 2, 2, 2725,
	2726, 3, 2, 2, 2, 2726, 2728, 3, 2, 2, 2, 2727, 2725, 3, 2, 2, 2, 2728,
	2729, 7, 16, 2, 2, 2729, 235, 3, 2, 2, 2, 2730, 2747, 5, 238, 120, 2, 2731,
	2733, 7, 7, 2, 2, 2732, 2731, 3, 2, 2, 2, 2733, 2736, 3, 2, 2, 2, 2734,
	2732, 3, 2, 2, 2, 2734, 2735, 3, 2, 2, 2, 2735, 2737, 3, 2, 2, 2, 2736,
	2734, 3, 2, 2, 2, 2737, 2741, 7, 10, 2, 2, 2738, 2740, 7, 7, 2, 2, 2739,
	2738, 3, 2, 2, 2, 2740, 2743, 3, 2, 2, 2, 2741, 2739, 3, 2, 2, 2, 2741,
	2742, 3, 2, 2, 2, 2742, 2744, 3, 2, 2, 2, 2743, 2741, 3, 2, 2, 2, 2744,
	2746, 5, 238, 120, 2, 2745, 2734, 3, 2, 2, 2, 2746, 2749, 3, 2, 2, 2, 2747,
	2745, 3, 2, 2, 2, 2747, 2748, 3, 2, 2, 2, 2748, 2757, 3, 2, 2, 2, 2749,
	2747, 3, 2, 2, 2, 2750, 2752, 7, 7, 2, 2, 2751, 2750, 3, 2, 2, 2, 2752,
	2755, 3, 2, 2, 2, 2753, 2751, 3, 2, 2, 2, 2753, 2754, 3, 2, 2, 2, 2754,
	2756, 3, 2, 2, 2, 2755, 2753, 3, 2, 2, 2, 2756, 2758, 7, 10, 2, 2, 2757,
	2753, 3, 2, 2, 2, 2757, 2758, 3, 2, 2, 2, 2758, 237, 3, 2, 2, 2, 2759,
	2778, 5, 68, 35, 2, 2760, 2775, 5, 70, 36, 2, 2761, 2763, 7, 7, 2, 2, 2762,
	2761, 3, 2, 2, 2, 2763, 2766, 3, 2, 2, 2, 2764, 2762, 3, 2, 2, 2, 2764,
	2765, 3, 2, 2, 2, 2765, 2767, 3, 2, 2, 2, 2766, 2764, 3, 2, 2, 2, 2767,
	2771, 7, 28, 2, 2, 2768, 2770, 7, 7, 2, 2, 2769, 2768, 3, 2, 2, 2, 2770,
	2773, 3, 2, 2, 2, 2771, 2769, 3, 2, 2, 2, 2771, 2772, 3, 2, 2, 2, 2772,
	2774, 3, 2, 2, 2, 2773, 2771, 3, 2, 2, 2, 2774, 2776, 5, 100, 51, 2, 2775,
	2764, 3, 2, 2, 2, 2775, 2776, 3, 2, 2, 2, 2776, 2778, 3, 2, 2, 2, 2777,
	2759, 3, 2, 2, 2, 2777, 2760, 3, 2, 2, 2, 2778, 239, 3, 2, 2, 2, 2779,
	2795, 7, 76, 2, 2, 2780, 2782, 7, 7, 2, 2, 2781, 2780, 3, 2, 2, 2, 2782,
	2785, 3, 2, 2, 2, 2783, 2781, 3, 2, 2, 2, 2783, 2784, 3, 2, 2, 2, 2784,
	2786, 3, 2, 2, 2, 2785, 2783, 3, 2, 2, 2, 2786, 2790, 5, 100, 51, 2, 2787,
	2789, 7, 7, 2, 2, 2788, 2787, 3, 2, 2, 2, 2789, 2792, 3, 2, 2, 2, 2790,
	2788, 3, 2, 2, 2, 2790, 2791, 3, 2, 2, 2, 2791, 2793, 3, 2, 2, 2, 2792,
	2790, 3, 2, 2, 2, 2793, 2794, 7, 9, 2, 2, 2794, 2796, 3, 2, 2, 2, 2795,
	2783, 3, 2, 2, 2, 2795, 2796, 3, 2, 2, 2, 2796, 2800, 3, 2, 2, 2, 2797,
	2799, 7, 7, 2, 2, 2798, 2797, 3, 2, 2, 2, 2799, 2802, 3, 2, 2, 2, 2800,
	2798, 3, 2, 2, 2, 2800, 2801, 3, 2, 2, 2, 2801, 2803, 3, 2, 2, 2, 2802,
	2800, 3, 2, 2, 2, 2803, 2818, 5, 80, 41, 2, 2804, 2806, 7, 7, 2, 2, 2805,
	2804, 3, 2, 2, 2, 2806, 2809, 3, 2, 2, 2, 2807, 2805, 3, 2, 2, 2, 2807,
	2808, 3, 2, 2, 2, 2808, 2810, 3, 2, 2, 2, 2809, 2807, 3, 2, 2, 2, 2810,
	2814, 7, 28, 2, 2, 2811, 2813, 7, 7, 2, 2, 2812, 2811, 3, 2, 2, 2, 2813,
	2816, 3, 2, 2, 2, 2814, 2812, 3, 2, 2, 2, 2814, 2815, 3, 2, 2, 2, 2815,
	2817, 3, 2, 2, 2, 2816, 2814, 3, 2, 2, 2, 2817, 2819, 5, 100, 51, 2, 2818,
	2807, 3, 2, 2, 2, 2818, 2819, 3, 2, 2, 2, 2819, 2827, 3, 2, 2, 2, 2820,
	2822, 7, 7, 2, 2, 2821, 2820, 3, 2, 2, 2, 2822, 2825, 3, 2, 2, 2, 2823,
	2821, 3, 2, 2, 2, 2823, 2824, 3, 2, 2, 2, 2824, 2826, 3, 2, 2, 2, 2825,
	2823, 3, 2, 2, 2, 2826, 2828, 5, 48, 25, 2, 2827, 2823, 3, 2, 2, 2, 2827,
	2828, 3, 2, 2, 2, 2828, 2836, 3, 2, 2, 2, 2829, 2831, 7, 7, 2, 2, 2830,
	2829, 3, 2, 2, 2, 2831, 2834, 3, 2, 2, 2, 2832, 2830, 3, 2, 2, 2, 2832,
	2833, 3, 2, 2, 2, 2833, 2835, 3, 2, 2, 2, 2834, 2832, 3, 2, 2, 2, 2835,
	2837, 5, 66, 34, 2, 2836, 2832, 3, 2, 2, 2, 2836, 2837, 3, 2, 2, 2, 2837,
	241, 3, 2, 2, 2, 2838, 2841, 5, 234, 118, 2, 2839, 2841, 5, 240, 121, 2,
	2840, 2838, 3, 2, 2, 2, 2840, 2839, 3, 2, 2, 2, 2841, 243, 3, 2, 2, 2,
	2842, 2863, 7, 77, 2, 2, 2843, 2845, 7, 7, 2, 2, 2844, 2843, 3, 2, 2, 2,
	2845, 2848, 3, 2, 2, 2, 2846, 2844, 3, 2, 2, 2, 2846, 2847, 3, 2, 2, 2,
	2847, 2849, 3, 2, 2, 2, 2848, 2846, 3, 2, 2, 2, 2849, 2853, 7, 28, 2, 2,
	2850, 2852, 7, 7, 2, 2, 2851, 2850, 3, 2, 2, 2, 2852, 2855, 3, 2, 2, 2,
	2853, 2851, 3, 2, 2, 2, 2853, 2854, 3, 2, 2, 2, 2854, 2856, 3, 2, 2, 2,
	2855, 2853, 3, 2, 2, 2, 2856, 2860, 5, 34, 18, 2, 2857, 2859, 7, 7, 2,
	2, 2858, 2857, 3, 2, 2, 2, 2859, 2862, 3, 2, 2, 2, 2860, 2858, 3, 2, 2,
	2, 2860, 2861, 3, 2, 2, 2, 2861, 2864, 3, 2, 2, 2, 2862, 2860, 3, 2, 2,
	2, 2863, 2846, 3, 2, 2, 2, 2863, 2864, 3, 2, 2, 2, 2864, 2872, 3, 2, 2,
	2, 2865, 2867, 7, 7, 2, 2, 2866, 2865, 3, 2, 2, 2, 2867, 2870, 3, 2, 2,
	2, 2868, 2866, 3, 2, 2, 2, 2868, 2869, 3, 2, 2, 2, 2869, 2871, 3, 2, 2,
	2, 2870, 2868, 3, 2, 2, 2, 2871, 2873, 5, 28, 15, 2, 2872, 2868, 3, 2,
	2, 2, 2872, 2873, 3, 2, 2, 2, 2873, 245, 3, 2, 2, 2, 2874, 2875, 9, 11,
	2, 2, 2875, 247, 3, 2, 2, 2, 2876, 2893, 7, 86, 2, 2, 2877, 2881, 7, 48,
	2, 2, 2878, 2880, 7, 7, 2, 2, 2879, 2878, 3, 2, 2, 2, 2880, 2883, 3, 2,
	2, 2, 2881, 2879, 3, 2, 2, 2, 2881, 2882, 3, 2, 2, 2, 2882, 2884, 3, 2,
	2, 2, 2883, 2881, 3, 2, 2, 2, 2884, 2888, 5, 100, 51, 2, 2885, 2887, 7,
	7, 2, 2, 2886, 2885, 3, 2, 2, 2, 2887, 2890, 3, 2, 2, 2, 2888, 2886, 3,
	2, 2, 2, 2888, 2889, 3, 2, 2, 2, 2889, 2891, 3, 2, 2, 2, 2890, 2888, 3,
	2, 2, 2, 2891, 2892, 7, 49, 2, 2, 2892, 2894, 3, 2, 2, 2, 2893, 2877, 3,
	2, 2, 2, 2893, 2894, 3, 2, 2, 2, 2894, 2897, 3, 2, 2, 2, 2895, 2896, 7,
	42, 2, 2, 2896, 2898, 5, 344, 173, 2, 2897, 2895, 3, 2, 2, 2, 2897, 2898,
	3, 2, 2, 2, 2898, 2901, 3, 2, 2, 2, 2899, 2901, 7, 62, 2, 2, 2900, 2876,
	3, 2, 2, 2, 2900, 2899, 3, 2, 2, 2, 2901, 249, 3, 2, 2, 2, 2902, 2906,
	7, 89, 2, 2, 2903, 2905, 7, 7, 2, 2, 2904, 2903, 3, 2, 2, 2, 2905, 2908,
	3, 2, 2, 2, 2906, 2904, 3, 2, 2, 2, 2906, 2907, 3, 2, 2, 2, 2907, 2909,
	3, 2, 2, 2, 2908, 2906, 3, 2, 2, 2, 2909, 2913, 7, 11, 2, 2, 2910, 2912,
	7, 7, 2, 2, 2911, 2910, 3, 2, 2, 2, 2912, 2915, 3, 2, 2, 2, 2913, 2911,
	3, 2, 2, 2, 2913, 2914, 3, 2, 2, 2, 2914, 2916, 3, 2, 2, 2, 2915, 2913,
	3, 2, 2, 2, 2916, 2920, 5, 152, 77, 2, 2917, 2919, 7, 7, 2, 2, 2918, 2917,
	3, 2, 2, 2, 2919, 2922, 3, 2, 2, 2, 2920, 2918, 3, 2, 2, 2, 2920, 2921,
	3, 2, 2, 2, 2921, 2923, 3, 2, 2, 2, 2922, 2920, 3, 2, 2, 2, 2923, 2927,
	7, 12, 2, 2, 2924, 2926, 7, 7, 2, 2, 2925, 2924, 3, 2, 2, 2, 2926, 2929,
	3, 2, 2, 2, 2927, 2925, 3, 2, 2, 2, 2927, 2928, 3, 2, 2, 2, 2928, 2961,
	3, 2, 2, 2, 2929, 2927, 3, 2, 2, 2, 2930, 2962, 5, 134, 68, 2, 2931, 2933,
	5, 134, 68, 2, 2932, 2931, 3, 2, 2, 2, 2932, 2933, 3, 2, 2, 2, 2933, 2937,
	3, 2, 2, 2, 2934, 2936, 7, 7, 2, 2, 2935, 2934, 3, 2, 2, 2, 2936, 2939,
	3, 2, 2, 2, 2937, 2935, 3, 2, 2, 2, 2937, 2938, 3, 2, 2, 2, 2938, 2941,
	3, 2, 2, 2, 2939, 2937, 3, 2, 2, 2, 2940, 2942, 7, 29, 2, 2, 2941, 2940,
	3, 2, 2, 2, 2941, 2942, 3, 2, 2, 2, 2942, 2946, 3, 2, 2, 2, 2943, 2945,
	7, 7, 2, 2, 2944, 2943, 3, 2, 2, 2, 2945, 2948, 3, 2, 2, 2, 2946, 2944,
	3, 2, 2, 2, 2946, 2947, 3, 2, 2, 2, 2947, 2949, 3, 2, 2, 2, 2948, 2946,
	3, 2, 2, 2, 2949, 2953, 7, 90, 2, 2, 2950, 2952, 7, 7, 2, 2, 2951, 2950,
	3, 2, 2, 2, 2952, 2955, 3, 2, 2, 2, 2953, 2951, 3, 2, 2, 2, 2953, 2954,
	3, 2, 2, 2, 2954, 2958, 3, 2, 2, 2, 2955, 2953, 3, 2, 2, 2, 2956, 2959,
	5, 134, 68, 2, 2957, 2959, 7, 29, 2, 2, 2958, 2956, 3, 2, 2, 2, 2958, 2957,
	3, 2, 2, 2, 2959, 2962, 3, 2, 2, 2, 2960, 2962, 7, 29, 2, 2, 2961, 2930,
	3, 2, 2, 2, 2961, 2932, 3, 2, 2, 2, 2961, 2960, 3, 2, 2, 2, 2962, 251,
	3, 2, 2, 2, 2963, 2997, 7, 11, 2, 2, 2964, 2966, 5, 334, 168, 2, 2965,
	2964, 3, 2, 2, 2, 2966, 2969, 3, 2, 2, 2, 2967, 2965, 3, 2, 2, 2, 2967,
	2968, 3, 2, 2, 2, 2968, 2973, 3, 2, 2, 2, 2969, 2967, 3, 2, 2, 2, 2970,
	2972, 7, 7, 2, 2, 2971, 2970, 3, 2, 2, 2, 2972, 2975, 3, 2, 2, 2, 2973,
	2971, 3, 2, 2, 2, 2973, 2974, 3, 2, 2, 2, 2974, 2976, 3, 2, 2, 2, 2975,
	2973, 3, 2, 2, 2, 2976, 2980, 7, 78, 2, 2, 2977, 2979, 7, 7, 2, 2, 2978,
	2977, 3, 2, 2, 2, 2979, 2982, 3, 2, 2, 2, 2980, 2978, 3, 2, 2, 2, 2980,
	2981, 3, 2, 2, 2, 2981, 2983, 3, 2, 2, 2, 2982, 2980, 3, 2, 2, 2, 2983,
	2987, 5, 68, 35, 2, 2984, 2986, 7, 7, 2, 2, 2985, 2984, 3, 2, 2, 2, 2986,
	2989, 3, 2, 2, 2, 2987, 2985, 3, 2, 2, 2, 2987, 2988, 3, 2, 2, 2, 2988,
	2990, 3, 2, 2, 2, 2989, 2987, 3, 2, 2, 2, 2990, 2994, 7, 30, 2, 2, 2991,
	2993, 7, 7, 2, 2, 2992, 2991, 3, 2, 2, 2, 2993, 2996, 3, 2, 2, 2, 2994,
	2992, 3, 2, 2, 2, 2994, 2995, 3, 2, 2, 2, 2995, 2998, 3, 2, 2, 2, 2996,
	2994, 3, 2, 2, 2, 2997, 2967, 3, 2, 2, 2, 2997, 2998, 3, 2, 2, 2, 2998,
	2999, 3, 2, 2, 2, 2999, 3000, 5, 152, 77, 2, 3000, 3001, 7, 12, 2, 2, 3001,
	253, 3, 2, 2, 2, 3002, 3006, 7, 91, 2, 2, 3003, 3005, 7, 7, 2, 2, 3004,
	3003, 3, 2, 2, 2, 3005, 3008, 3, 2, 2, 2, 3006, 3004, 3, 2, 2, 2, 3006,
	3007, 3, 2, 2, 2, 3007, 3010, 3, 2, 2, 2, 3008, 3006, 3, 2, 2, 2, 3009,
	3011, 5, 252, 127, 2, 3010, 3009, 3, 2, 2, 2, 3010, 3011, 3, 2, 2, 2, 3011,
	3015, 3, 2, 2, 2, 3012, 3014, 7, 7, 2, 2, 3013, 3012, 3, 2, 2, 2, 3014,
	3017, 3, 2, 2, 2, 3015, 3013, 3, 2, 2, 2, 3015, 3016, 3, 2, 2, 2, 3016,
	3018, 3, 2, 2, 2, 3017, 3015, 3, 2, 2, 2, 3018, 3022, 7, 15, 2, 2, 3019,
	3021, 7, 7, 2, 2, 3020, 3019, 3, 2, 2, 2, 3021, 3024, 3, 2, 2, 2, 3022,
	3020, 3, 2, 2, 2, 3022, 3023, 3, 2, 2, 2, 3023, 3034, 3, 2, 2, 2, 3024,
	3022, 3, 2, 2, 2, 3025, 3029, 5, 256, 129, 2, 3026, 3028, 7, 7, 2, 2, 3027,
	3026, 3, 2, 2, 2, 3028, 3031, 3, 2, 2, 2, 3029, 3027, 3, 2, 2, 2, 3029,
	3030, 3, 2, 2, 2, 3030, 3033, 3, 2, 2, 2, 3031, 3029, 3, 2, 2, 2, 3032,
	3025, 3, 2, 2, 2, 3033, 3036, 3, 2, 2, 2, 3034, 3032, 3, 2, 2, 2, 3034,
	3035, 3, 2, 2, 2, 3035, 3040, 3, 2, 2, 2, 3036, 3034, 3, 2, 2, 2, 3037,
	3039, 7, 7, 2, 2, 3038, 3037, 3, 2, 2, 2, 3039, 3042, 3, 2, 2, 2, 3040,
	3038, 3, 2, 2, 2, 3040, 3041, 3, 2, 2, 2, 3041, 3043, 3, 2, 2, 2, 3042,
	3040, 3, 2, 2, 2, 3043, 3044, 7, 16, 2, 2, 3044, 255, 3, 2, 2, 2, 3045,
	3062, 5, 258, 130, 2, 3046, 3048, 7, 7, 2, 2, 3047, 3046, 3, 2, 2, 2, 3048,
	3051, 3, 2, 2, 2, 3049, 3047, 3, 2, 2, 2, 3049, 3050, 3, 2, 2, 2, 3050,
	3052, 3, 2, 2, 2, 3051, 3049, 3, 2, 2, 2, 3052, 3056, 7, 10, 2, 2, 3053,
	3055, 7, 7, 2, 2, 3054, 3053, 3, 2, 2, 2, 3055, 3058, 3, 2, 2, 2, 3056,
	3054, 3, 2, 2, 2, 3056, 3057, 3, 2, 2, 2, 3057, 3059, 3, 2, 2, 2, 3058,
	3056, 3, 2, 2, 2, 3059, 3061, 5, 258, 130, 2, 3060, 3049, 3, 2, 2, 2, 3061,
	3064, 3, 2, 2, 2, 3062, 3060, 3, 2, 2, 2, 3062, 3063, 3, 2, 2, 2, 3063,
	3072, 3, 2, 2, 2, 3064, 3062, 3, 2, 2, 2, 3065, 3067, 7, 7, 2, 2, 3066,
	3065, 3, 2, 2, 2, 3067, 3070, 3, 2, 2, 2, 3068, 3066, 3, 2, 2, 2, 3068,
	3069, 3, 2, 2, 2, 3069, 3071, 3, 2, 2, 2, 3070, 3068, 3, 2, 2, 2, 3071,
	3073, 7, 10, 2, 2, 3072, 3068, 3, 2, 2, 2, 3072, 3073, 3, 2, 2, 2, 3073,
	3077, 3, 2, 2, 2, 3074, 3076, 7, 7, 2, 2, 3075, 3074, 3, 2, 2, 2, 3076,
	3079, 3, 2, 2, 2, 3077, 3075, 3, 2, 2, 2, 3077, 3078, 3, 2, 2, 2, 3078,
	3080, 3, 2, 2, 2, 3079, 3077, 3, 2, 2, 2, 3080, 3084, 7, 36, 2, 2, 3081,
	3083, 7, 7, 2, 2, 3082, 3081, 3, 2, 2, 2, 3083, 3086, 3, 2, 2, 2, 3084,
	3082, 3, 2, 2, 2, 3084, 3085, 3, 2, 2, 2, 3085, 3087, 3, 2, 2, 2, 3086,
	3084, 3, 2, 2, 2, 3087, 3089, 5, 134, 68, 2, 3088, 3090, 5, 148, 75, 2,
	3089, 3088, 3, 2, 2, 2, 3089, 3090, 3, 2, 2, 2, 3090, 3110, 3, 2, 2, 2,
	3091, 3095, 7, 90, 2, 2, 3092, 3094, 7, 7, 2, 2, 3093, 3092, 3, 2, 2, 2,
	3094, 3097, 3, 2, 2, 2, 3095, 3093, 3, 2, 2, 2, 3095, 3096, 3, 2, 2, 2,
	3096, 3098, 3, 2, 2, 2, 3097, 3095, 3, 2, 2, 2, 3098, 3102, 7, 36, 2, 2,
	3099, 3101, 7, 7, 2, 2, 3100, 3099, 3, 2, 2, 2, 3101, 3104, 3, 2, 2, 2,
	3102, 3100, 3, 2, 2, 2, 3102, 3103, 3, 2, 2, 2, 3103, 3105, 3, 2, 2, 2,
	3104, 3102, 3, 2, 2, 2, 3105, 3107, 5, 134, 68, 2, 3106, 3108, 5, 148,
	75, 2, 3107, 3106, 3, 2, 2, 2, 3107, 3108, 3, 2, 2, 2, 3108, 3110, 3, 2,
	2, 2, 3109, 3045, 3, 2, 2, 2, 3109, 3091, 3, 2, 2, 2, 3110, 257, 3, 2,
	2, 2, 3111, 3115, 5, 152, 77, 2, 3112, 3115, 5, 260, 131, 2, 3113, 3115,
	5, 262, 132, 2, 3114, 3111, 3, 2, 2, 2, 3114, 3112, 3, 2, 2, 2, 3114, 3113,
	3, 2, 2, 2, 3115, 259, 3, 2, 2, 2, 3116, 3120, 5, 280, 141, 2, 3117, 3119,
	7, 7, 2, 2, 3118, 3117, 3, 2, 2, 2, 3119, 3122, 3, 2, 2, 2, 3120, 3118,
	3, 2, 2, 2, 3120, 3121, 3, 2, 2, 2, 3121, 3123, 3, 2, 2, 2, 3122, 3120,
	3, 2, 2, 2, 3123, 3124, 5, 152, 77, 2, 3124, 261, 3, 2, 2, 2, 3125, 3129,
	5, 282, 142, 2, 3126, 3128, 7, 7, 2, 2, 3127, 3126, 3, 2, 2, 2, 3128, 3131,
	3, 2, 2, 2, 3129, 3127, 3, 2, 2, 2, 3129, 3130, 3, 2, 2, 2, 3130, 3132,
	3, 2, 2, 2, 3131, 3129, 3, 2, 2, 2, 3132, 3133, 5, 100, 51, 2, 3133, 263,
	3, 2, 2, 2, 3134, 3138, 7, 92, 2, 2, 3135, 3137, 7, 7, 2, 2, 3136, 3135,
	3, 2, 2, 2, 3137, 3140, 3, 2, 2, 2, 3138, 3136, 3, 2, 2, 2, 3138, 3139,
	3, 2, 2, 2, 3139, 3141, 3, 2, 2, 2, 3140, 3138, 3, 2, 2, 2, 3141, 3169,
	5, 136, 69, 2, 3142, 3144, 7, 7, 2, 2, 3143, 3142, 3, 2, 2, 2, 3144, 3147,
	3, 2, 2, 2, 3145, 3143, 3, 2, 2, 2, 3145, 3146, 3, 2, 2, 2, 3146, 3148,
	3, 2, 2, 2, 3147, 3145, 3, 2, 2, 2, 3148, 3150, 5, 266, 134, 2, 3149, 3145,
	3, 2, 2, 2, 3150, 3151, 3, 2, 2, 2, 3151, 3149, 3, 2, 2, 2, 3151, 3152,
	3, 2, 2, 2, 3152, 3160, 3, 2, 2, 2, 3153, 3155, 7, 7, 2, 2, 3154, 3153,
	3, 2, 2, 2, 3155, 3158, 3, 2, 2, 2, 3156, 3154, 3, 2, 2, 2, 3156, 3157,
	3, 2, 2, 2, 3157, 3159, 3, 2, 2, 2, 3158, 3156, 3, 2, 2, 2, 3159, 3161,
	5, 268, 135, 2, 3160, 3156, 3, 2, 2, 2, 3160, 3161, 3, 2, 2, 2, 3161, 3170,
	3, 2, 2, 2, 3162, 3164, 7, 7, 2, 2, 3163, 3162, 3, 2, 2, 2, 3164, 3167,
	3, 2, 2, 2, 3165, 3163, 3, 2, 2, 2, 3165, 3166, 3, 2, 2, 2, 3166, 3168,
	3, 2, 2, 2, 3167, 3165, 3, 2, 2, 2, 3168, 3170, 5, 268, 135, 2, 3169, 3149,
	3, 2, 2, 2, 3169, 3165, 3, 2, 2, 2, 3170, 265, 3, 2, 2, 2, 3171, 3175,
	7, 93, 2, 2, 3172, 3174, 7, 7, 2, 2, 3173, 3172, 3, 2, 2, 2, 3174, 3177,
	3, 2, 2, 2, 3175, 3173, 3, 2, 2, 2, 3175, 3176, 3, 2, 2, 2, 3176, 3178,
	3, 2, 2, 2, 3177, 3175, 3, 2, 2, 2, 3178, 3182, 7, 11, 2, 2, 3179, 3181,
	5, 334, 168, 2, 3180, 3179, 3, 2, 2, 2, 3181, 3184, 3, 2, 2, 2, 3182, 3180,
	3, 2, 2, 2, 3182, 3183, 3, 2, 2, 2, 3183, 3185, 3, 2, 2, 2, 3184, 3182,
	3, 2, 2, 2, 3185, 3186, 5, 344, 173, 2, 3186, 3187, 7, 28, 2, 2, 3187,
	3195, 5, 100, 51, 2, 3188, 3190, 7, 7, 2, 2, 3189, 3188, 3, 2, 2, 2, 3190,
	3193, 3, 2, 2, 2, 3191, 3189, 3, 2, 2, 2, 3191, 3192, 3, 2, 2, 2, 3192,
	3194, 3, 2, 2, 2, 3193, 3191, 3, 2, 2, 2, 3194, 3196, 7, 10, 2, 2, 3195,
	3191, 3, 2, 2, 2, 3195, 3196, 3, 2, 2, 2, 3196, 3197, 3, 2, 2, 2, 3197,
	3201, 7, 12, 2, 2, 3198, 3200, 7, 7, 2, 2, 3199, 3198, 3, 2, 2, 2, 3200,
	3203, 3, 2, 2, 2, 3201, 3199, 3, 2, 2, 2, 3201, 3202, 3, 2, 2, 2, 3202,
	3204, 3, 2, 2, 2, 3203, 3201, 3, 2, 2, 2, 3204, 3205, 5, 136, 69, 2, 3205,
	267, 3, 2, 2, 2, 3206, 3210, 7, 94, 2, 2, 3207, 3209, 7, 7, 2, 2, 3208,
	3207, 3, 2, 2, 2, 3209, 3212, 3, 2, 2, 2, 3210, 3208, 3, 2, 2, 2, 3210,
	3211, 3, 2, 2, 2, 3211, 3213, 3, 2, 2, 2, 3212, 3210, 3, 2, 2, 2, 3213,
	3214, 5, 136, 69, 2, 3214, 269, 3, 2, 2, 2, 3215, 3219, 7, 98, 2, 2, 3216,
	3218, 7, 7, 2, 2, 3217, 3216, 3, 2, 2, 2, 3218, 3221, 3, 2, 2, 2, 3219,
	3217, 3, 2, 2, 2, 3219, 3220, 3, 2, 2, 2, 3220, 3222, 3, 2, 2, 2, 3221,
	3219, 3, 2, 2, 2, 3222, 3232, 5, 152, 77, 2, 3223, 3225, 9, 12, 2, 2, 3224,
	3226, 5, 152, 77, 2, 3225, 3224, 3, 2, 2, 2, 3225, 3226, 3, 2, 2, 2, 3226,
	3232, 3, 2, 2, 2, 3227, 3232, 7, 100, 2, 2, 3228, 3232, 7, 59, 2, 2, 3229,
	3232, 7, 101, 2, 2, 3230, 3232, 7, 60, 2, 2, 3231, 3215, 3, 2, 2, 2, 3231,
	3223, 3, 2, 2, 2, 3231, 3227, 3, 2, 2, 2, 3231, 3228, 3, 2, 2, 2, 3231,
	3229, 3, 2, 2, 2, 3231, 3230, 3, 2, 2, 2, 3232, 271, 3, 2, 2, 2, 3233,
	3235, 5, 124, 63, 2, 3234, 3233, 3, 2, 2, 2, 3234, 3235, 3, 2, 2, 2, 3235,
	3236, 3, 2, 2, 2, 3236, 3240, 7, 39, 2, 2, 3237, 3239, 7, 7, 2, 2, 3238,
	3237, 3, 2, 2, 2, 3239, 3242, 3, 2, 2, 2, 3240, 3238, 3, 2, 2, 2, 3240,
	3241, 3, 2, 2, 2, 3241, 3245, 3, 2, 2, 2, 3242, 3240, 3, 2, 2, 2, 3243,
	3246, 5, 344, 173, 2, 3244, 3246, 7, 74, 2, 2, 3245, 3243, 3, 2, 2, 2,
	3245, 3244, 3, 2, 2, 2, 3246, 273, 3, 2, 2, 2, 3247, 3248, 9, 13, 2, 2,
	3248, 275, 3, 2, 2, 2, 3249, 3250, 9, 14, 2, 2, 3250, 277, 3, 2, 2, 2,
	3251, 3252, 9, 15, 2, 2, 3252, 279, 3, 2, 2, 2, 3253, 3254, 9, 16, 2, 2,
	3254, 281, 3, 2, 2, 2, 3255, 3256, 9, 17, 2, 2, 3256, 283, 3, 2, 2, 2,
	3257, 3258, 9, 18, 2, 2, 3258, 285, 3, 2, 2, 2, 3259, 3260, 9, 19, 2, 2,
	3260, 287, 3, 2, 2, 2, 3261, 3262, 9, 20, 2, 2, 3262, 289, 3, 2, 2, 2,
	3263, 3269, 7, 22, 2, 2, 3264, 3269, 7, 23, 2, 2, 3265, 3269, 7, 21, 2,
	2, 3266, 3269, 7, 20, 2, 2, 3267, 3269, 5, 294, 148, 2, 3268, 3263, 3,
	2, 2, 2, 3268, 3264, 3, 2, 2, 2, 3268, 3265, 3, 2, 2, 2, 3268, 3266, 3,
	2, 2, 2, 3268, 3267, 3, 2, 2, 2, 3269, 291, 3, 2, 2, 2, 3270, 3275, 7,
	22, 2, 2, 3271, 3275, 7, 23, 2, 2, 3272, 3273, 7, 27, 2, 2, 3273, 3275,
	5, 294, 148, 2, 3274, 3270, 3, 2, 2, 2, 3274, 3271, 3, 2, 2, 2, 3274, 3272,
	3, 2, 2, 2, 3275, 293, 3, 2, 2, 2, 3276, 3277, 9, 21, 2, 2, 3277, 295,
	3, 2, 2, 2, 3278, 3280, 7, 7, 2, 2, 3279, 3278, 3, 2, 2, 2, 3280, 3283,
	3, 2, 2, 2, 3281, 3279, 3, 2, 2, 2, 3281, 3282, 3, 2, 2, 2, 3282, 3284,
	3, 2, 2, 2, 3283, 3281, 3, 2, 2, 2, 3284, 3294, 7, 9, 2, 2, 3285, 3287,
	7, 7, 2, 2, 3286, 3285, 3, 2, 2, 2, 3287, 3290, 3, 2, 2, 2, 3288, 3286,
	3, 2, 2, 2, 3288, 3289, 3, 2, 2, 2, 3289, 3291, 3, 2, 2, 2, 3290, 3288,
	3, 2, 2, 2, 3291, 3294, 5, 298, 150, 2, 3292, 3294, 7, 39, 2, 2, 3293,
	3281, 3, 2, 2, 2, 3293, 3288, 3, 2, 2, 2, 3293, 3292, 3, 2, 2, 2, 3294,
	297, 3, 2, 2, 2, 3295, 3296, 7, 47, 2, 2, 3296, 3297, 7, 9, 2, 2, 3297,
	299, 3, 2, 2, 2, 3298, 3301, 5, 334, 168, 2, 3299, 3301, 5, 304, 153, 2,
	3300, 3298, 3, 2, 2, 2, 3300, 3299, 3, 2, 2, 2, 3301, 3302, 3, 2, 2, 2,
	3302, 3300, 3, 2, 2, 2, 3302, 3303, 3, 2, 2, 2, 3303, 301, 3, 2, 2, 2,
	3304, 3307, 5, 334, 168, 2, 3305, 3307, 5, 328, 165, 2, 3306, 3304, 3,
	2, 2, 2, 3306, 3305, 3, 2, 2, 2, 3307, 3308, 3, 2, 2, 2, 3308, 3306, 3,
	2, 2, 2, 3308, 3309, 3, 2, 2, 2, 3309, 303, 3, 2, 2, 2, 3310, 3319, 5,
	310, 156, 2, 3311, 3319, 5, 312, 157, 2, 3312, 3319, 5, 314, 158, 2, 3313,
	3319, 5, 322, 162, 2, 3314, 3319, 5, 324, 163, 2, 3315, 3319, 5, 326, 164,
	2, 3316, 3319, 5, 328, 165, 2, 3317, 3319, 5, 332, 167, 2, 3318, 3310,
	3, 2, 2, 2, 3318, 3311, 3, 2, 2, 2, 3318, 3312, 3, 2, 2, 2, 3318, 3313,
	3, 2, 2, 2, 3318, 3314, 3, 2, 2, 2, 3318, 3315, 3, 2, 2, 2, 3318, 3316,
	3, 2, 2, 2, 3318, 3317, 3, 2, 2, 2, 3319, 3323, 3, 2, 2, 2, 3320, 3322,
	7, 7, 2, 2, 3321, 3320, 3, 2, 2, 2, 3322, 3325, 3, 2, 2, 2, 3323, 3321,
	3, 2, 2, 2, 3323, 3324, 3, 2, 2, 2, 3324, 305, 3, 2, 2, 2, 3325, 3323,
	3, 2, 2, 2, 3326, 3328, 5, 308, 155, 2, 3327, 3326, 3, 2, 2, 2, 3328, 3329,
	3, 2, 2, 2, 3329, 3327, 3, 2, 2, 2, 3329, 3330, 3, 2, 2, 2, 3330, 307,
	3, 2, 2, 2, 3331, 3340, 5, 334, 168, 2, 3332, 3336, 7, 124, 2, 2, 3333,
	3335, 7, 7, 2, 2, 3334, 3333, 3, 2, 2, 2, 3335, 3338, 3, 2, 2, 2, 3336,
	3334, 3, 2, 2, 2, 3336, 3337, 3, 2, 2, 2, 3337, 3340, 3, 2, 2, 2, 3338,
	3336, 3, 2, 2, 2, 3339, 3331, 3, 2, 2, 2, 3339, 3332, 3, 2, 2, 2, 3340,
	309, 3, 2, 2, 2, 3341, 3342, 9, 22, 2, 2, 3342, 311, 3, 2, 2, 2, 3343,
	3344, 9, 23, 2, 2, 3344, 313, 3, 2, 2, 2, 3345, 3346, 9, 24, 2, 2, 3346,
	315, 3, 2, 2, 2, 3347, 3348, 9, 25, 2, 2, 3348, 317, 3, 2, 2, 2, 3349,
	3351, 5, 320, 161, 2, 3350, 3349, 3, 2, 2, 2, 3351, 3352, 3, 2, 2, 2, 3352,
	3350, 3, 2, 2, 2, 3352, 3353, 3, 2, 2, 2, 3353, 319, 3, 2, 2, 2, 3354,
	3358, 5, 330, 166, 2, 3355, 3357, 7, 7, 2, 2, 3356, 3355, 3, 2, 2, 2, 3357,
	3360, 3, 2, 2, 2, 3358, 3356, 3, 2, 2, 2, 3358, 3359, 3, 2, 2, 2, 3359,
	3370, 3, 2, 2, 2, 3360, 3358, 3, 2, 2, 2, 3361, 3365, 5, 316, 159, 2, 3362,
	3364, 7, 7, 2, 2, 3363, 3362, 3, 2, 2, 2, 3364, 3367, 3, 2, 2, 2, 3365,
	3363, 3, 2, 2, 2, 3365, 3366, 3, 2, 2, 2, 3366, 3370, 3, 2, 2, 2, 3367,
	3365, 3, 2, 2, 2, 3368, 3370, 5, 334, 168, 2, 3369, 3354, 3, 2, 2, 2, 3369,
	3361, 3, 2, 2, 2, 3369, 3368, 3, 2, 2, 2, 3370, 321, 3, 2, 2, 2, 3371,
	3372, 9, 26, 2, 2, 3372, 323, 3, 2, 2, 2, 3373, 3374, 7, 129, 2, 2, 3374,
	325, 3, 2, 2, 2, 3375, 3376, 9, 27, 2, 2, 3376, 327, 3, 2, 2, 2, 3377,
	3378, 9, 28, 2, 2, 3378, 329, 3, 2, 2, 2, 3379, 3380, 7, 134, 2, 2, 3380,
	331, 3, 2, 2, 2, 3381, 3382, 9, 29, 2, 2, 3382, 333, 3, 2, 2, 2, 3383,
	3386, 5, 336, 169, 2, 3384, 3386, 5, 338, 170, 2, 3385, 3383, 3, 2, 2,
	2, 3385, 3384, 3, 2, 2, 2, 3386, 3390, 3, 2, 2, 2, 3387, 3389, 7, 7, 2,
	2, 3388, 3387, 3, 2, 2, 2, 3389, 3392, 3, 2, 2, 2, 3390, 3388, 3, 2, 2,
	2, 3390, 3391, 3, 2, 2, 2, 3391, 335, 3, 2, 2, 2, 3392, 3390, 3, 2, 2,
	2, 3393, 3397, 5, 340, 171, 2, 3394, 3396, 7, 7, 2, 2, 3395, 3394, 3, 2,
	2, 2, 3396, 3399, 3, 2, 2, 2, 3397, 3395, 3, 2, 2, 2, 3397, 3398, 3, 2,
	2, 2, 3398, 3403, 3, 2, 2, 2, 3399, 3397, 3, 2, 2, 2, 3400, 3403, 7, 42,
	2, 2, 3401, 3403, 7, 44, 2, 2, 3402, 3393, 3, 2, 2, 2, 3402, 3400, 3, 2,
	2, 2, 3402, 3401, 3, 2, 2, 2, 3403, 3404, 3, 2, 2, 2, 3404, 3405, 5, 342,
	172, 2, 3405, 337, 3, 2, 2, 2, 3406, 3410, 5, 340, 171, 2, 3407, 3409,
	7, 7, 2, 2, 3408, 3407, 3, 2, 2, 2, 3409, 3412, 3, 2, 2, 2, 3410, 3408,
	3, 2, 2, 2, 3410, 3411, 3, 2, 2, 2, 3411, 3416, 3, 2, 2, 2, 3412, 3410,
	3, 2, 2, 2, 3413, 3416, 7, 42, 2, 2, 3414, 3416, 7, 44, 2, 2, 3415, 3406,
	3, 2, 2, 2, 3415, 3413, 3, 2, 2, 2, 3415, 3414, 3, 2, 2, 2, 3416, 3417,
	3, 2, 2, 2, 3417, 3419, 7, 13, 2, 2, 3418, 3420, 5, 342, 172, 2, 3419,
	3418, 3, 2, 2, 2, 3420, 3421, 3, 2, 2, 2, 3421, 3419, 3, 2, 2, 2, 3421,
	3422, 3, 2, 2, 2, 3422, 3423, 3, 2, 2, 2, 3423, 3424, 7, 14, 2, 2, 3424,
	339, 3, 2, 2, 2, 3425, 3426, 9, 2, 2, 2, 3426, 3430, 9, 30, 2, 2, 3427,
	3429, 7, 7, 2, 2, 3428, 3427, 3, 2, 2, 2, 3429, 3432, 3, 2, 2, 2, 3430,
	3428, 3, 2, 2, 2, 3430, 3431, 3, 2, 2, 2, 3431, 3433, 3, 2, 2, 2, 3432,
	3430, 3, 2, 2, 2, 3433, 3434, 7, 28, 2, 2, 3434, 341, 3, 2, 2, 2, 3435,
	3438, 5, 38, 20, 2, 3436, 3438, 5, 108, 55, 2, 3437, 3435, 3, 2, 2, 2,
	3437, 3436, 3, 2, 2, 2, 3438, 343, 3, 2, 2, 2, 3439, 3440, 9, 31, 2, 2,
	3440, 345, 3, 2, 2, 2, 3441, 3452, 5, 344, 173, 2, 3442, 3444, 7, 7, 2,
	2, 3443, 3442, 3, 2, 2, 2, 3444, 3447, 3, 2, 2, 2, 3445, 3443, 3, 2, 2,
	2, 3445, 3446, 3, 2, 2, 2, 3446, 3448, 3, 2, 2, 2, 3447, 3445, 3, 2, 2,
	2, 3448, 3449, 7, 9, 2, 2, 3449, 3451, 5, 344, 173, 2, 3450, 3445, 3, 2,
	2, 2, 3451, 3454, 3, 2, 2, 2, 3452, 3450, 3, 2, 2, 2, 3452, 3453, 3, 2,
	2, 2, 3453, 347, 3, 2, 2, 2, 3454, 3452, 3, 2, 2, 2, 532, 349, 354, 360,
	368, 374, 379, 385, 395, 404, 411, 418, 425, 430, 435, 441, 443, 448, 456,
	459, 466, 469, 475, 482, 486, 491, 498, 508, 511, 518, 521, 524, 529, 536,
	540, 545, 549, 554, 561, 565, 570, 574, 579, 586, 590, 593, 599, 602, 610,
	617, 626, 633, 640, 646, 652, 656, 658, 663, 669, 672, 677, 685, 692, 699,
	703, 709, 716, 722, 729, 737, 743, 750, 755, 762, 771, 778, 785, 791, 797,
	801, 806, 812, 817, 824, 831, 835, 841, 848, 855, 861, 867, 874, 881, 888,
	892, 899, 905, 911, 917, 924, 928, 933, 940, 944, 949, 953, 959, 966, 973,
	979, 985, 989, 991, 996, 1002, 1008, 1015, 1019, 1022, 1028, 1032, 1037,
	1044, 1049, 1054, 1061, 1068, 1075, 1079, 1084, 1088, 1093, 1097, 1104,
	1108, 1113, 1119, 1126, 1133, 1137, 1143, 1150, 1157, 1163, 1169, 1173,
	1178, 1184, 1190, 1194, 1199, 1206, 1211, 1216, 1221, 1226, 1230, 1235,
	1242, 1247, 1249, 1254, 1257, 1262, 1266, 1271, 1275, 1278, 1281, 1286,
	1290, 1293, 1295, 1301, 1307, 1313, 1320, 1327, 1334, 1338, 1343, 1347,
	1350, 1356, 1363, 1370, 1374, 1379, 1386, 1393, 1397, 1402, 1407, 1413,
	1420, 1427, 1433, 1439, 1443, 1445, 1450, 1456, 1462, 1469, 1473, 1479,
	1486, 1490, 1496, 1503, 1509, 1515, 1522, 1529, 1533, 1538, 1542, 1545,
	1551, 1558, 1565, 1569, 1574, 1578, 1584, 1593, 1597, 1602, 1609, 1613,
	1618, 1627, 1634, 1640, 1646, 1650, 1656, 1659, 1665, 1669, 1674, 1678,
	1681, 1687, 1691, 1695, 1700, 1706, 1714, 1721, 1727, 1734, 1738, 1741,
	1745, 1750, 1756, 1760, 1766, 1773, 1776, 1782, 1789, 1798, 1803, 1808,
	1815, 1820, 1824, 1830, 1834, 1839, 1848, 1855, 1861, 1866, 1872, 1877,
	1882, 1893, 1896, 1899, 1903, 1905, 1912, 1919, 1924, 1930, 1937, 1945,
	1951, 1958, 1963, 1971, 1975, 1981, 1990, 1995, 2001, 2005, 2010, 2017,
	2030, 2035, 2044, 2048, 2053, 2056, 2064, 2071, 2077, 2084, 2091, 2097,
	2105, 2112, 2120, 2127, 2134, 2142, 2151, 2156, 2158, 2165, 2172, 2179,
	2190, 2197, 2205, 2211, 2219, 2226, 2234, 2241, 2248, 2255, 2262, 2268,
	2279, 2282, 2288, 2296, 2303, 2309, 2316, 2323, 2329, 2336, 2344, 2350,
	2357, 2364, 2370, 2376, 2380, 2385, 2394, 2400, 2403, 2406, 2410, 2415,
	2419, 2424, 2433, 2440, 2447, 2453, 2459, 2463, 2468, 2477, 2484, 2491,
	2497, 2503, 2507, 2512, 2515, 2520, 2525, 2532, 2539, 2542, 2545, 2550,
	2569, 2575, 2582, 2591, 2598, 2605, 2611, 2617, 2621, 2626, 2629, 2637,
	2642, 2644, 2653, 2655, 2666, 2673, 2684, 2691, 2700, 2704, 2709, 2716,
	2719, 2725, 2734, 2741, 2747, 2753, 2757, 2764, 2771, 2775, 2777, 2783,
	2790, 2795, 2800, 2807, 2814, 2818, 2823, 2827, 2832, 2836, 2840, 2846,
	2853, 2860, 2863, 2868, 2872, 2881, 2888, 2893, 2897, 2900, 2906, 2913,
	2920, 2927, 2932, 2937, 2941, 2946, 2953, 2958, 2961, 2967, 2973, 2980,
	2987, 2994, 2997, 3006, 3010, 3015, 3022, 3029, 3034, 3040, 3049, 3056,
	3062, 3068, 3072, 3077, 3084, 3089, 3095, 3102, 3107, 3109, 3114, 3120,
	3129, 3138, 3145, 3151, 3156, 3160, 3165, 3169, 3175, 3182, 3191, 3195,
	3201, 3210, 3219, 3225, 3231, 3234, 3240, 3245, 3268, 3274, 3281, 3288,
	3293, 3300, 3302, 3306, 3308, 3318, 3323, 3329, 3336, 3339, 3352, 3358,
	3365, 3369, 3385, 3390, 3397, 3402, 3410, 3415, 3421, 3430, 3437, 3445,
	3452,
}
var literalNames = []string{
	"", "", "", "", "", "", "'...'", "'.'", "','", "'('", "')'", "'['", "']'",
	"'{'", "'}'", "'*'", "'%'", "'/'", "'+'", "'-'", "'++'", "'--'", "'&&'",
	"'||'", "", "'!'", "':'", "';'", "'='", "'+='", "'-='", "'*='", "'/='",
	"'%='", "'->'", "'=>'", "'..'", "'::'", "';;'", "'#'", "'@'", "", "", "",
	"", "'?'", "'<'", "'>'", "'<='", "'>='", "'!='", "'!=='", "'as?'", "'=='",
	"'==='", "'''", "", "", "", "", "", "'file'", "'field'", "'property'",
	"'get'", "'set'", "'receiver'", "'param'", "'setparam'", "'delegate'",
	"'package'", "'import'", "'class'", "'interface'", "'fun'", "'object'",
	"'val'", "'var'", "'typealias'", "'constructor'", "'by'", "'companion'",
	"'init'", "'this'", "'super'", "'typeof'", "'where'", "'if'", "'else'",
	"'when'", "'try'", "'catch'", "'finally'", "'for'", "'do'", "'while'",
	"'throw'", "'return'", "'continue'", "'break'", "'as'", "'is'", "'in'",
	"", "", "'out'", "'dynamic'", "'public'", "'private'", "'protected'", "'internal'",
	"'enum'", "'sealed'", "'annotation'", "'data'", "'inner'", "'value'", "'tailrec'",
	"'operator'", "'inline'", "'infix'", "'external'", "'suspend'", "'override'",
	"'abstract'", "'final'", "'open'", "'const'", "'lateinit'", "'vararg'",
	"'noinline'", "'crossinline'", "'reified'", "'expect'", "'actual'", "",
	"", "", "", "", "", "", "", "", "'null'", "", "", "", "", "", "'\"\"\"'",
}
var symbolicNames = []string{
	"", "ShebangLine", "DelimitedComment", "LineComment", "WS", "NL", "RESERVED",
	"DOT", "COMMA", "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", "LCURL", "RCURL",
	"MULT", "MOD", "DIV", "ADD", "SUB", "INCR", "DECR", "CONJ", "DISJ", "EXCL_WS",
	"EXCL_NO_WS", "COLON", "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT", "SUB_ASSIGNMENT",
	"MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT", "ARROW", "DOUBLE_ARROW",
	"RANGE", "COLONCOLON", "DOUBLE_SEMICOLON", "HASH", "AT_NO_WS", "AT_POST_WS",
	"AT_PRE_WS", "AT_BOTH_WS", "QUEST_WS", "QUEST_NO_WS", "LANGLE", "RANGLE",
	"LE", "GE", "EXCL_EQ", "EXCL_EQEQ", "AS_SAFE", "EQEQ", "EQEQEQ", "SINGLE_QUOTE",
	"RETURN_AT", "CONTINUE_AT", "BREAK_AT", "THIS_AT", "SUPER_AT", "FILE",
	"FIELD", "PROPERTY", "GET", "SET", "RECEIVER", "PARAM", "SETPARAM", "DELEGATE",
	"PACKAGE", "IMPORT", "CLASS", "INTERFACE", "FUN", "OBJECT", "VAL", "VAR",
	"TYPE_ALIAS", "CONSTRUCTOR", "BY", "COMPANION", "INIT", "THIS", "SUPER",
	"TYPEOF", "WHERE", "IF", "ELSE", "WHEN", "TRY", "CATCH", "FINALLY", "FOR",
	"DO", "WHILE", "THROW", "RETURN", "CONTINUE", "BREAK", "AS", "IS", "IN",
	"NOT_IS", "NOT_IN", "OUT", "DYNAMIC", "PUBLIC", "PRIVATE", "PROTECTED",
	"INTERNAL", "ENUM", "SEALED", "ANNOTATION", "DATA", "INNER", "VALUE", "TAILREC",
	"OPERATOR", "INLINE", "INFIX", "EXTERNAL", "SUSPEND", "OVERRIDE", "ABSTRACT",
	"FINAL", "OPEN", "CONST", "LATEINIT", "VARARG", "NOINLINE", "CROSSINLINE",
	"REIFIED", "EXPECT", "ACTUAL", "RealLiteral", "FloatLiteral", "DoubleLiteral",
	"IntegerLiteral", "HexLiteral", "BinLiteral", "UnsignedLiteral", "LongLiteral",
	"BooleanLiteral", "NullLiteral", "CharacterLiteral", "Identifier", "IdentifierOrSoftKey",
	"FieldIdentifier", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN", "UNICODE_CLASS_LL",
	"UNICODE_CLASS_LM", "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", "UNICODE_CLASS_LU",
	"UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "QUOTE_CLOSE", "LineStrRef", "LineStrText",
	"LineStrEscapedChar", "LineStrExprStart", "TRIPLE_QUOTE_CLOSE", "MultiLineStringQuote",
	"MultiLineStrRef", "MultiLineStrText", "MultiLineStrExprStart", "Inside_Comment",
	"Inside_WS", "Inside_NL", "ErrorCharacter",
}

var ruleNames = []string{
	"kotlinFile", "script", "shebangLine", "fileAnnotation", "packageHeader",
	"importList", "importHeader", "importAlias", "topLevelObject", "typeAlias",
	"declaration", "classDeclaration", "primaryConstructor", "classBody", "classParameters",
	"classParameter", "delegationSpecifiers", "delegationSpecifier", "constructorInvocation",
	"annotatedDelegationSpecifier", "explicitDelegation", "typeParameters",
	"typeParameter", "typeConstraints", "typeConstraint", "classMemberDeclarations",
	"classMemberDeclaration", "anonymousInitializer", "companionObject", "functionValueParameters",
	"functionValueParameter", "functionDeclaration", "functionBody", "variableDeclaration",
	"multiVariableDeclaration", "propertyDeclaration", "propertyDelegate",
	"getter", "setter", "parametersWithOptionalType", "functionValueParameterWithOptionalType",
	"parameterWithOptionalType", "parameter", "objectDeclaration", "secondaryConstructor",
	"constructorDelegationCall", "enumClassBody", "enumEntries", "enumEntry",
	"dataType", "typeReference", "nullableType", "quest", "userType", "simpleUserType",
	"typeProjection", "typeProjectionModifiers", "typeProjectionModifier",
	"functionType", "functionTypeParameters", "parenthesizedType", "receiverType",
	"parenthesizedUserType", "statements", "statement", "label", "controlStructureBody",
	"block", "loopStatement", "forStatement", "whileStatement", "doWhileStatement",
	"assignment", "semi", "semis", "expression", "disjunction", "conjunction",
	"equality", "comparison", "genericCallLikeComparison", "infixOperation",
	"elvisExpression", "elvis", "infixFunctionCall", "rangeExpression", "additiveExpression",
	"multiplicativeExpression", "asExpression", "prefixUnaryExpression", "unaryPrefix",
	"postfixUnaryExpression", "postfixUnarySuffix", "directlyAssignableExpression",
	"parenthesizedDirectlyAssignableExpression", "assignableExpression", "parenthesizedAssignableExpression",
	"assignableSuffix", "indexingSuffix", "navigationSuffix", "callSuffix",
	"annotatedLambda", "typeArguments", "valueArguments", "valueArgument",
	"primaryExpression", "parenthesizedExpression", "collectionLiteral", "literalConstant",
	"stringLiteral", "lineStringLiteral", "multiLineStringLiteral", "lineStringContent",
	"lineStringExpression", "multiLineStringContent", "multiLineStringExpression",
	"lambdaLiteral", "lambdaParameters", "lambdaParameter", "anonymousFunction",
	"functionLiteral", "objectLiteral", "thisExpression", "superExpression",
	"ifExpression", "whenSubject", "whenExpression", "whenEntry", "whenCondition",
	"rangeTest", "typeTest", "tryExpression", "catchBlock", "finallyBlock",
	"jumpExpression", "callableReference", "assignmentAndOperator", "equalityOperator",
	"comparisonOperator", "inOperator", "isOperator", "additiveOperator", "multiplicativeOperator",
	"asOperator", "prefixUnaryOperator", "postfixUnaryOperator", "excl", "memberAccessOperator",
	"safeNav", "modifiers", "parameterModifiers", "modifier", "typeModifiers",
	"typeModifier", "classModifier", "memberModifier", "visibilityModifier",
	"varianceModifier", "typeParameterModifiers", "typeParameterModifier",
	"functionModifier", "propertyModifier", "inheritanceModifier", "parameterModifier",
	"reificationModifier", "platformModifier", "annotation", "singleAnnotation",
	"multiAnnotation", "annotationUseSiteTarget", "unescapedAnnotation", "simpleIdentifier",
	"identifier",
}

type KotlinParser struct {
	*antlr.BaseParser
}

// NewKotlinParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *KotlinParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewKotlinParser(input antlr.TokenStream) *KotlinParser {
	this := new(KotlinParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "KotlinParser.g4"

	return this
}

// KotlinParser tokens.
const (
	KotlinParserEOF                   = antlr.TokenEOF
	KotlinParserShebangLine           = 1
	KotlinParserDelimitedComment      = 2
	KotlinParserLineComment           = 3
	KotlinParserWS                    = 4
	KotlinParserNL                    = 5
	KotlinParserRESERVED              = 6
	KotlinParserDOT                   = 7
	KotlinParserCOMMA                 = 8
	KotlinParserLPAREN                = 9
	KotlinParserRPAREN                = 10
	KotlinParserLSQUARE               = 11
	KotlinParserRSQUARE               = 12
	KotlinParserLCURL                 = 13
	KotlinParserRCURL                 = 14
	KotlinParserMULT                  = 15
	KotlinParserMOD                   = 16
	KotlinParserDIV                   = 17
	KotlinParserADD                   = 18
	KotlinParserSUB                   = 19
	KotlinParserINCR                  = 20
	KotlinParserDECR                  = 21
	KotlinParserCONJ                  = 22
	KotlinParserDISJ                  = 23
	KotlinParserEXCL_WS               = 24
	KotlinParserEXCL_NO_WS            = 25
	KotlinParserCOLON                 = 26
	KotlinParserSEMICOLON             = 27
	KotlinParserASSIGNMENT            = 28
	KotlinParserADD_ASSIGNMENT        = 29
	KotlinParserSUB_ASSIGNMENT        = 30
	KotlinParserMULT_ASSIGNMENT       = 31
	KotlinParserDIV_ASSIGNMENT        = 32
	KotlinParserMOD_ASSIGNMENT        = 33
	KotlinParserARROW                 = 34
	KotlinParserDOUBLE_ARROW          = 35
	KotlinParserRANGE                 = 36
	KotlinParserCOLONCOLON            = 37
	KotlinParserDOUBLE_SEMICOLON      = 38
	KotlinParserHASH                  = 39
	KotlinParserAT_NO_WS              = 40
	KotlinParserAT_POST_WS            = 41
	KotlinParserAT_PRE_WS             = 42
	KotlinParserAT_BOTH_WS            = 43
	KotlinParserQUEST_WS              = 44
	KotlinParserQUEST_NO_WS           = 45
	KotlinParserLANGLE                = 46
	KotlinParserRANGLE                = 47
	KotlinParserLE                    = 48
	KotlinParserGE                    = 49
	KotlinParserEXCL_EQ               = 50
	KotlinParserEXCL_EQEQ             = 51
	KotlinParserAS_SAFE               = 52
	KotlinParserEQEQ                  = 53
	KotlinParserEQEQEQ                = 54
	KotlinParserSINGLE_QUOTE          = 55
	KotlinParserRETURN_AT             = 56
	KotlinParserCONTINUE_AT           = 57
	KotlinParserBREAK_AT              = 58
	KotlinParserTHIS_AT               = 59
	KotlinParserSUPER_AT              = 60
	KotlinParserFILE                  = 61
	KotlinParserFIELD                 = 62
	KotlinParserPROPERTY              = 63
	KotlinParserGET                   = 64
	KotlinParserSET                   = 65
	KotlinParserRECEIVER              = 66
	KotlinParserPARAM                 = 67
	KotlinParserSETPARAM              = 68
	KotlinParserDELEGATE              = 69
	KotlinParserPACKAGE               = 70
	KotlinParserIMPORT                = 71
	KotlinParserCLASS                 = 72
	KotlinParserINTERFACE             = 73
	KotlinParserFUN                   = 74
	KotlinParserOBJECT                = 75
	KotlinParserVAL                   = 76
	KotlinParserVAR                   = 77
	KotlinParserTYPE_ALIAS            = 78
	KotlinParserCONSTRUCTOR           = 79
	KotlinParserBY                    = 80
	KotlinParserCOMPANION             = 81
	KotlinParserINIT                  = 82
	KotlinParserTHIS                  = 83
	KotlinParserSUPER                 = 84
	KotlinParserTYPEOF                = 85
	KotlinParserWHERE                 = 86
	KotlinParserIF                    = 87
	KotlinParserELSE                  = 88
	KotlinParserWHEN                  = 89
	KotlinParserTRY                   = 90
	KotlinParserCATCH                 = 91
	KotlinParserFINALLY               = 92
	KotlinParserFOR                   = 93
	KotlinParserDO                    = 94
	KotlinParserWHILE                 = 95
	KotlinParserTHROW                 = 96
	KotlinParserRETURN                = 97
	KotlinParserCONTINUE              = 98
	KotlinParserBREAK                 = 99
	KotlinParserAS                    = 100
	KotlinParserIS                    = 101
	KotlinParserIN                    = 102
	KotlinParserNOT_IS                = 103
	KotlinParserNOT_IN                = 104
	KotlinParserOUT                   = 105
	KotlinParserDYNAMIC               = 106
	KotlinParserPUBLIC                = 107
	KotlinParserPRIVATE               = 108
	KotlinParserPROTECTED             = 109
	KotlinParserINTERNAL              = 110
	KotlinParserENUM                  = 111
	KotlinParserSEALED                = 112
	KotlinParserANNOTATION            = 113
	KotlinParserDATA                  = 114
	KotlinParserINNER                 = 115
	KotlinParserVALUE                 = 116
	KotlinParserTAILREC               = 117
	KotlinParserOPERATOR              = 118
	KotlinParserINLINE                = 119
	KotlinParserINFIX                 = 120
	KotlinParserEXTERNAL              = 121
	KotlinParserSUSPEND               = 122
	KotlinParserOVERRIDE              = 123
	KotlinParserABSTRACT              = 124
	KotlinParserFINAL                 = 125
	KotlinParserOPEN                  = 126
	KotlinParserCONST                 = 127
	KotlinParserLATEINIT              = 128
	KotlinParserVARARG                = 129
	KotlinParserNOINLINE              = 130
	KotlinParserCROSSINLINE           = 131
	KotlinParserREIFIED               = 132
	KotlinParserEXPECT                = 133
	KotlinParserACTUAL                = 134
	KotlinParserRealLiteral           = 135
	KotlinParserFloatLiteral          = 136
	KotlinParserDoubleLiteral         = 137
	KotlinParserIntegerLiteral        = 138
	KotlinParserHexLiteral            = 139
	KotlinParserBinLiteral            = 140
	KotlinParserUnsignedLiteral       = 141
	KotlinParserLongLiteral           = 142
	KotlinParserBooleanLiteral        = 143
	KotlinParserNullLiteral           = 144
	KotlinParserCharacterLiteral      = 145
	KotlinParserIdentifier            = 146
	KotlinParserIdentifierOrSoftKey   = 147
	KotlinParserFieldIdentifier       = 148
	KotlinParserQUOTE_OPEN            = 149
	KotlinParserTRIPLE_QUOTE_OPEN     = 150
	KotlinParserUNICODE_CLASS_LL      = 151
	KotlinParserUNICODE_CLASS_LM      = 152
	KotlinParserUNICODE_CLASS_LO      = 153
	KotlinParserUNICODE_CLASS_LT      = 154
	KotlinParserUNICODE_CLASS_LU      = 155
	KotlinParserUNICODE_CLASS_ND      = 156
	KotlinParserUNICODE_CLASS_NL      = 157
	KotlinParserQUOTE_CLOSE           = 158
	KotlinParserLineStrRef            = 159
	KotlinParserLineStrText           = 160
	KotlinParserLineStrEscapedChar    = 161
	KotlinParserLineStrExprStart      = 162
	KotlinParserTRIPLE_QUOTE_CLOSE    = 163
	KotlinParserMultiLineStringQuote  = 164
	KotlinParserMultiLineStrRef       = 165
	KotlinParserMultiLineStrText      = 166
	KotlinParserMultiLineStrExprStart = 167
	KotlinParserInside_Comment        = 168
	KotlinParserInside_WS             = 169
	KotlinParserInside_NL             = 170
	KotlinParserErrorCharacter        = 171
)

// KotlinParser rules.
const (
	KotlinParserRULE_kotlinFile                                = 0
	KotlinParserRULE_script                                    = 1
	KotlinParserRULE_shebangLine                               = 2
	KotlinParserRULE_fileAnnotation                            = 3
	KotlinParserRULE_packageHeader                             = 4
	KotlinParserRULE_importList                                = 5
	KotlinParserRULE_importHeader                              = 6
	KotlinParserRULE_importAlias                               = 7
	KotlinParserRULE_topLevelObject                            = 8
	KotlinParserRULE_typeAlias                                 = 9
	KotlinParserRULE_declaration                               = 10
	KotlinParserRULE_classDeclaration                          = 11
	KotlinParserRULE_primaryConstructor                        = 12
	KotlinParserRULE_classBody                                 = 13
	KotlinParserRULE_classParameters                           = 14
	KotlinParserRULE_classParameter                            = 15
	KotlinParserRULE_delegationSpecifiers                      = 16
	KotlinParserRULE_delegationSpecifier                       = 17
	KotlinParserRULE_constructorInvocation                     = 18
	KotlinParserRULE_annotatedDelegationSpecifier              = 19
	KotlinParserRULE_explicitDelegation                        = 20
	KotlinParserRULE_typeParameters                            = 21
	KotlinParserRULE_typeParameter                             = 22
	KotlinParserRULE_typeConstraints                           = 23
	KotlinParserRULE_typeConstraint                            = 24
	KotlinParserRULE_classMemberDeclarations                   = 25
	KotlinParserRULE_classMemberDeclaration                    = 26
	KotlinParserRULE_anonymousInitializer                      = 27
	KotlinParserRULE_companionObject                           = 28
	KotlinParserRULE_functionValueParameters                   = 29
	KotlinParserRULE_functionValueParameter                    = 30
	KotlinParserRULE_functionDeclaration                       = 31
	KotlinParserRULE_functionBody                              = 32
	KotlinParserRULE_variableDeclaration                       = 33
	KotlinParserRULE_multiVariableDeclaration                  = 34
	KotlinParserRULE_propertyDeclaration                       = 35
	KotlinParserRULE_propertyDelegate                          = 36
	KotlinParserRULE_getter                                    = 37
	KotlinParserRULE_setter                                    = 38
	KotlinParserRULE_parametersWithOptionalType                = 39
	KotlinParserRULE_functionValueParameterWithOptionalType    = 40
	KotlinParserRULE_parameterWithOptionalType                 = 41
	KotlinParserRULE_parameter                                 = 42
	KotlinParserRULE_objectDeclaration                         = 43
	KotlinParserRULE_secondaryConstructor                      = 44
	KotlinParserRULE_constructorDelegationCall                 = 45
	KotlinParserRULE_enumClassBody                             = 46
	KotlinParserRULE_enumEntries                               = 47
	KotlinParserRULE_enumEntry                                 = 48
	KotlinParserRULE_dataType                                  = 49
	KotlinParserRULE_typeReference                             = 50
	KotlinParserRULE_nullableType                              = 51
	KotlinParserRULE_quest                                     = 52
	KotlinParserRULE_userType                                  = 53
	KotlinParserRULE_simpleUserType                            = 54
	KotlinParserRULE_typeProjection                            = 55
	KotlinParserRULE_typeProjectionModifiers                   = 56
	KotlinParserRULE_typeProjectionModifier                    = 57
	KotlinParserRULE_functionType                              = 58
	KotlinParserRULE_functionTypeParameters                    = 59
	KotlinParserRULE_parenthesizedType                         = 60
	KotlinParserRULE_receiverType                              = 61
	KotlinParserRULE_parenthesizedUserType                     = 62
	KotlinParserRULE_statements                                = 63
	KotlinParserRULE_statement                                 = 64
	KotlinParserRULE_label                                     = 65
	KotlinParserRULE_controlStructureBody                      = 66
	KotlinParserRULE_block                                     = 67
	KotlinParserRULE_loopStatement                             = 68
	KotlinParserRULE_forStatement                              = 69
	KotlinParserRULE_whileStatement                            = 70
	KotlinParserRULE_doWhileStatement                          = 71
	KotlinParserRULE_assignment                                = 72
	KotlinParserRULE_semi                                      = 73
	KotlinParserRULE_semis                                     = 74
	KotlinParserRULE_expression                                = 75
	KotlinParserRULE_disjunction                               = 76
	KotlinParserRULE_conjunction                               = 77
	KotlinParserRULE_equality                                  = 78
	KotlinParserRULE_comparison                                = 79
	KotlinParserRULE_genericCallLikeComparison                 = 80
	KotlinParserRULE_infixOperation                            = 81
	KotlinParserRULE_elvisExpression                           = 82
	KotlinParserRULE_elvis                                     = 83
	KotlinParserRULE_infixFunctionCall                         = 84
	KotlinParserRULE_rangeExpression                           = 85
	KotlinParserRULE_additiveExpression                        = 86
	KotlinParserRULE_multiplicativeExpression                  = 87
	KotlinParserRULE_asExpression                              = 88
	KotlinParserRULE_prefixUnaryExpression                     = 89
	KotlinParserRULE_unaryPrefix                               = 90
	KotlinParserRULE_postfixUnaryExpression                    = 91
	KotlinParserRULE_postfixUnarySuffix                        = 92
	KotlinParserRULE_directlyAssignableExpression              = 93
	KotlinParserRULE_parenthesizedDirectlyAssignableExpression = 94
	KotlinParserRULE_assignableExpression                      = 95
	KotlinParserRULE_parenthesizedAssignableExpression         = 96
	KotlinParserRULE_assignableSuffix                          = 97
	KotlinParserRULE_indexingSuffix                            = 98
	KotlinParserRULE_navigationSuffix                          = 99
	KotlinParserRULE_callSuffix                                = 100
	KotlinParserRULE_annotatedLambda                           = 101
	KotlinParserRULE_typeArguments                             = 102
	KotlinParserRULE_valueArguments                            = 103
	KotlinParserRULE_valueArgument                             = 104
	KotlinParserRULE_primaryExpression                         = 105
	KotlinParserRULE_parenthesizedExpression                   = 106
	KotlinParserRULE_collectionLiteral                         = 107
	KotlinParserRULE_literalConstant                           = 108
	KotlinParserRULE_stringLiteral                             = 109
	KotlinParserRULE_lineStringLiteral                         = 110
	KotlinParserRULE_multiLineStringLiteral                    = 111
	KotlinParserRULE_lineStringContent                         = 112
	KotlinParserRULE_lineStringExpression                      = 113
	KotlinParserRULE_multiLineStringContent                    = 114
	KotlinParserRULE_multiLineStringExpression                 = 115
	KotlinParserRULE_lambdaLiteral                             = 116
	KotlinParserRULE_lambdaParameters                          = 117
	KotlinParserRULE_lambdaParameter                           = 118
	KotlinParserRULE_anonymousFunction                         = 119
	KotlinParserRULE_functionLiteral                           = 120
	KotlinParserRULE_objectLiteral                             = 121
	KotlinParserRULE_thisExpression                            = 122
	KotlinParserRULE_superExpression                           = 123
	KotlinParserRULE_ifExpression                              = 124
	KotlinParserRULE_whenSubject                               = 125
	KotlinParserRULE_whenExpression                            = 126
	KotlinParserRULE_whenEntry                                 = 127
	KotlinParserRULE_whenCondition                             = 128
	KotlinParserRULE_rangeTest                                 = 129
	KotlinParserRULE_typeTest                                  = 130
	KotlinParserRULE_tryExpression                             = 131
	KotlinParserRULE_catchBlock                                = 132
	KotlinParserRULE_finallyBlock                              = 133
	KotlinParserRULE_jumpExpression                            = 134
	KotlinParserRULE_callableReference                         = 135
	KotlinParserRULE_assignmentAndOperator                     = 136
	KotlinParserRULE_equalityOperator                          = 137
	KotlinParserRULE_comparisonOperator                        = 138
	KotlinParserRULE_inOperator                                = 139
	KotlinParserRULE_isOperator                                = 140
	KotlinParserRULE_additiveOperator                          = 141
	KotlinParserRULE_multiplicativeOperator                    = 142
	KotlinParserRULE_asOperator                                = 143
	KotlinParserRULE_prefixUnaryOperator                       = 144
	KotlinParserRULE_postfixUnaryOperator                      = 145
	KotlinParserRULE_excl                                      = 146
	KotlinParserRULE_memberAccessOperator                      = 147
	KotlinParserRULE_safeNav                                   = 148
	KotlinParserRULE_modifiers                                 = 149
	KotlinParserRULE_parameterModifiers                        = 150
	KotlinParserRULE_modifier                                  = 151
	KotlinParserRULE_typeModifiers                             = 152
	KotlinParserRULE_typeModifier                              = 153
	KotlinParserRULE_classModifier                             = 154
	KotlinParserRULE_memberModifier                            = 155
	KotlinParserRULE_visibilityModifier                        = 156
	KotlinParserRULE_varianceModifier                          = 157
	KotlinParserRULE_typeParameterModifiers                    = 158
	KotlinParserRULE_typeParameterModifier                     = 159
	KotlinParserRULE_functionModifier                          = 160
	KotlinParserRULE_propertyModifier                          = 161
	KotlinParserRULE_inheritanceModifier                       = 162
	KotlinParserRULE_parameterModifier                         = 163
	KotlinParserRULE_reificationModifier                       = 164
	KotlinParserRULE_platformModifier                          = 165
	KotlinParserRULE_annotation                                = 166
	KotlinParserRULE_singleAnnotation                          = 167
	KotlinParserRULE_multiAnnotation                           = 168
	KotlinParserRULE_annotationUseSiteTarget                   = 169
	KotlinParserRULE_unescapedAnnotation                       = 170
	KotlinParserRULE_simpleIdentifier                          = 171
	KotlinParserRULE_identifier                                = 172
)

// IKotlinFileContext is an interface to support dynamic dispatch.
type IKotlinFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKotlinFileContext differentiates from other interfaces.
	IsKotlinFileContext()
}

type KotlinFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKotlinFileContext() *KotlinFileContext {
	var p = new(KotlinFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_kotlinFile
	return p
}

func (*KotlinFileContext) IsKotlinFileContext() {}

func NewKotlinFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KotlinFileContext {
	var p = new(KotlinFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_kotlinFile

	return p
}

func (s *KotlinFileContext) GetParser() antlr.Parser { return s.parser }

func (s *KotlinFileContext) PackageHeader() IPackageHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *KotlinFileContext) ImportList() IImportListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *KotlinFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *KotlinFileContext) ShebangLine() IShebangLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShebangLineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShebangLineContext)
}

func (s *KotlinFileContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *KotlinFileContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *KotlinFileContext) AllFileAnnotation() []IFileAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileAnnotationContext)(nil)).Elem())
	var tst = make([]IFileAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileAnnotationContext)
		}
	}

	return tst
}

func (s *KotlinFileContext) FileAnnotation(i int) IFileAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *KotlinFileContext) AllTopLevelObject() []ITopLevelObjectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopLevelObjectContext)(nil)).Elem())
	var tst = make([]ITopLevelObjectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopLevelObjectContext)
		}
	}

	return tst
}

func (s *KotlinFileContext) TopLevelObject(i int) ITopLevelObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopLevelObjectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopLevelObjectContext)
}

func (s *KotlinFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KotlinFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KotlinFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterKotlinFile(s)
	}
}

func (s *KotlinFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitKotlinFile(s)
	}
}

func (p *KotlinParser) KotlinFile() (localctx IKotlinFileContext) {
	localctx = NewKotlinFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KotlinParserRULE_kotlinFile)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserShebangLine {
		{
			p.SetState(346)
			p.ShebangLine()
		}

	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(349)
			p.Match(KotlinParserNL)
		}

		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(355)
				p.FileAnnotation()
			}

		}
		p.SetState(360)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}
	{
		p.SetState(361)
		p.PackageHeader()
	}
	{
		p.SetState(362)
		p.ImportList()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(KotlinParserCLASS-72))|(1<<(KotlinParserINTERFACE-72))|(1<<(KotlinParserFUN-72))|(1<<(KotlinParserOBJECT-72))|(1<<(KotlinParserVAL-72))|(1<<(KotlinParserVAR-72))|(1<<(KotlinParserTYPE_ALIAS-72)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(363)
			p.TopLevelObject()
		}

		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(369)
		p.Match(KotlinParserEOF)
	}

	return localctx
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_script
	return p
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) PackageHeader() IPackageHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *ScriptContext) ImportList() IImportListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *ScriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *ScriptContext) ShebangLine() IShebangLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShebangLineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShebangLineContext)
}

func (s *ScriptContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ScriptContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ScriptContext) AllFileAnnotation() []IFileAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileAnnotationContext)(nil)).Elem())
	var tst = make([]IFileAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileAnnotationContext)
		}
	}

	return tst
}

func (s *ScriptContext) FileAnnotation(i int) IFileAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *ScriptContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ScriptContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScriptContext) AllSemi() []ISemiContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISemiContext)(nil)).Elem())
	var tst = make([]ISemiContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISemiContext)
		}
	}

	return tst
}

func (s *ScriptContext) Semi(i int) ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitScript(s)
	}
}

func (p *KotlinParser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KotlinParserRULE_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserShebangLine {
		{
			p.SetState(371)
			p.ShebangLine()
		}

	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(374)
			p.Match(KotlinParserNL)
		}

		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(380)
				p.FileAnnotation()
			}

		}
		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}
	{
		p.SetState(386)
		p.PackageHeader()
	}
	{
		p.SetState(387)
		p.ImportList()
	}
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL_WS)|(1<<KotlinParserEXCL_NO_WS))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(KotlinParserCOLONCOLON-37))|(1<<(KotlinParserAT_NO_WS-37))|(1<<(KotlinParserAT_PRE_WS-37))|(1<<(KotlinParserRETURN_AT-37))|(1<<(KotlinParserCONTINUE_AT-37))|(1<<(KotlinParserBREAK_AT-37))|(1<<(KotlinParserTHIS_AT-37))|(1<<(KotlinParserSUPER_AT-37))|(1<<(KotlinParserFILE-37))|(1<<(KotlinParserFIELD-37))|(1<<(KotlinParserPROPERTY-37))|(1<<(KotlinParserGET-37))|(1<<(KotlinParserSET-37))|(1<<(KotlinParserRECEIVER-37))|(1<<(KotlinParserPARAM-37))|(1<<(KotlinParserSETPARAM-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KotlinParserDELEGATE-69))|(1<<(KotlinParserIMPORT-69))|(1<<(KotlinParserCLASS-69))|(1<<(KotlinParserINTERFACE-69))|(1<<(KotlinParserFUN-69))|(1<<(KotlinParserOBJECT-69))|(1<<(KotlinParserVAL-69))|(1<<(KotlinParserVAR-69))|(1<<(KotlinParserTYPE_ALIAS-69))|(1<<(KotlinParserCONSTRUCTOR-69))|(1<<(KotlinParserBY-69))|(1<<(KotlinParserCOMPANION-69))|(1<<(KotlinParserINIT-69))|(1<<(KotlinParserTHIS-69))|(1<<(KotlinParserSUPER-69))|(1<<(KotlinParserWHERE-69))|(1<<(KotlinParserIF-69))|(1<<(KotlinParserWHEN-69))|(1<<(KotlinParserTRY-69))|(1<<(KotlinParserCATCH-69))|(1<<(KotlinParserFINALLY-69))|(1<<(KotlinParserFOR-69))|(1<<(KotlinParserDO-69))|(1<<(KotlinParserWHILE-69))|(1<<(KotlinParserTHROW-69))|(1<<(KotlinParserRETURN-69))|(1<<(KotlinParserCONTINUE-69))|(1<<(KotlinParserBREAK-69)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105))|(1<<(KotlinParserRealLiteral-105)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(KotlinParserIntegerLiteral-138))|(1<<(KotlinParserHexLiteral-138))|(1<<(KotlinParserBinLiteral-138))|(1<<(KotlinParserUnsignedLiteral-138))|(1<<(KotlinParserLongLiteral-138))|(1<<(KotlinParserBooleanLiteral-138))|(1<<(KotlinParserNullLiteral-138))|(1<<(KotlinParserCharacterLiteral-138))|(1<<(KotlinParserIdentifier-138))|(1<<(KotlinParserQUOTE_OPEN-138))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-138)))) != 0) {
		{
			p.SetState(388)
			p.Statement()
		}
		{
			p.SetState(389)
			p.Semi()
		}

		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(396)
		p.Match(KotlinParserEOF)
	}

	return localctx
}

// IShebangLineContext is an interface to support dynamic dispatch.
type IShebangLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShebangLineContext differentiates from other interfaces.
	IsShebangLineContext()
}

type ShebangLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShebangLineContext() *ShebangLineContext {
	var p = new(ShebangLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_shebangLine
	return p
}

func (*ShebangLineContext) IsShebangLineContext() {}

func NewShebangLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShebangLineContext {
	var p = new(ShebangLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_shebangLine

	return p
}

func (s *ShebangLineContext) GetParser() antlr.Parser { return s.parser }

func (s *ShebangLineContext) ShebangLine() antlr.TerminalNode {
	return s.GetToken(KotlinParserShebangLine, 0)
}

func (s *ShebangLineContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ShebangLineContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ShebangLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShebangLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShebangLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterShebangLine(s)
	}
}

func (s *ShebangLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitShebangLine(s)
	}
}

func (p *KotlinParser) ShebangLine() (localctx IShebangLineContext) {
	localctx = NewShebangLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KotlinParserRULE_shebangLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(398)
		p.Match(KotlinParserShebangLine)
	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(399)
				p.Match(KotlinParserNL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IFileAnnotationContext is an interface to support dynamic dispatch.
type IFileAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileAnnotationContext differentiates from other interfaces.
	IsFileAnnotationContext()
}

type FileAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileAnnotationContext() *FileAnnotationContext {
	var p = new(FileAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_fileAnnotation
	return p
}

func (*FileAnnotationContext) IsFileAnnotationContext() {}

func NewFileAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileAnnotationContext {
	var p = new(FileAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_fileAnnotation

	return p
}

func (s *FileAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *FileAnnotationContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *FileAnnotationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FileAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *FileAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *FileAnnotationContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *FileAnnotationContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *FileAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem())
	var tst = make([]IUnescapedAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnescapedAnnotationContext)
		}
	}

	return tst
}

func (s *FileAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *FileAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FileAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FileAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFileAnnotation(s)
	}
}

func (s *FileAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFileAnnotation(s)
	}
}

func (p *KotlinParser) FileAnnotation() (localctx IFileAnnotationContext) {
	localctx = NewFileAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KotlinParserRULE_fileAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(405)
		p.Match(KotlinParserFILE)
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(406)
			p.Match(KotlinParserNL)
		}

		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(412)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(413)
			p.Match(KotlinParserNL)
		}

		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLSQUARE:
		{
			p.SetState(419)
			p.Match(KotlinParserLSQUARE)
		}
		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(KotlinParserFILE-61))|(1<<(KotlinParserFIELD-61))|(1<<(KotlinParserPROPERTY-61))|(1<<(KotlinParserGET-61))|(1<<(KotlinParserSET-61))|(1<<(KotlinParserRECEIVER-61))|(1<<(KotlinParserPARAM-61))|(1<<(KotlinParserSETPARAM-61))|(1<<(KotlinParserDELEGATE-61))|(1<<(KotlinParserIMPORT-61))|(1<<(KotlinParserCONSTRUCTOR-61))|(1<<(KotlinParserBY-61))|(1<<(KotlinParserCOMPANION-61))|(1<<(KotlinParserINIT-61))|(1<<(KotlinParserWHERE-61))|(1<<(KotlinParserCATCH-61))|(1<<(KotlinParserFINALLY-61)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105)))) != 0) || _la == KotlinParserIdentifier {
			{
				p.SetState(420)
				p.UnescapedAnnotation()
			}

			p.SetState(423)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(425)
			p.Match(KotlinParserRSQUARE)
		}

	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(427)
			p.UnescapedAnnotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(430)
			p.Match(KotlinParserNL)
		}

		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPackageHeaderContext is an interface to support dynamic dispatch.
type IPackageHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageHeaderContext differentiates from other interfaces.
	IsPackageHeaderContext()
}

type PackageHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageHeaderContext() *PackageHeaderContext {
	var p = new(PackageHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_packageHeader
	return p
}

func (*PackageHeaderContext) IsPackageHeaderContext() {}

func NewPackageHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageHeaderContext {
	var p = new(PackageHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_packageHeader

	return p
}

func (s *PackageHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageHeaderContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPACKAGE, 0)
}

func (s *PackageHeaderContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageHeaderContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PackageHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPackageHeader(s)
	}
}

func (s *PackageHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPackageHeader(s)
	}
}

func (p *KotlinParser) PackageHeader() (localctx IPackageHeaderContext) {
	localctx = NewPackageHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KotlinParserRULE_packageHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserPACKAGE {
		{
			p.SetState(436)
			p.Match(KotlinParserPACKAGE)
		}
		{
			p.SetState(437)
			p.Identifier()
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(438)
				p.Semi()
			}

		}

	}

	return localctx
}

// IImportListContext is an interface to support dynamic dispatch.
type IImportListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportListContext differentiates from other interfaces.
	IsImportListContext()
}

type ImportListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportListContext() *ImportListContext {
	var p = new(ImportListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importList
	return p
}

func (*ImportListContext) IsImportListContext() {}

func NewImportListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportListContext {
	var p = new(ImportListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importList

	return p
}

func (s *ImportListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportListContext) AllImportHeader() []IImportHeaderContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportHeaderContext)(nil)).Elem())
	var tst = make([]IImportHeaderContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportHeaderContext)
		}
	}

	return tst
}

func (s *ImportListContext) ImportHeader(i int) IImportHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportHeaderContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportHeaderContext)
}

func (s *ImportListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportList(s)
	}
}

func (s *ImportListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportList(s)
	}
}

func (p *KotlinParser) ImportList() (localctx IImportListContext) {
	localctx = NewImportListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KotlinParserRULE_importList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(443)
				p.ImportHeader()
			}

		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IImportHeaderContext is an interface to support dynamic dispatch.
type IImportHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportHeaderContext differentiates from other interfaces.
	IsImportHeaderContext()
}

type ImportHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportHeaderContext() *ImportHeaderContext {
	var p = new(ImportHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importHeader
	return p
}

func (*ImportHeaderContext) IsImportHeaderContext() {}

func NewImportHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportHeaderContext {
	var p = new(ImportHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importHeader

	return p
}

func (s *ImportHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportHeaderContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *ImportHeaderContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportHeaderContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *ImportHeaderContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ImportHeaderContext) ImportAlias() IImportAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportAliasContext)
}

func (s *ImportHeaderContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ImportHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportHeader(s)
	}
}

func (s *ImportHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportHeader(s)
	}
}

func (p *KotlinParser) ImportHeader() (localctx IImportHeaderContext) {
	localctx = NewImportHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KotlinParserRULE_importHeader)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(KotlinParserIMPORT)
	}
	{
		p.SetState(450)
		p.Identifier()
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserDOT:
		{
			p.SetState(451)
			p.Match(KotlinParserDOT)
		}
		{
			p.SetState(452)
			p.Match(KotlinParserMULT)
		}

	case KotlinParserAS:
		{
			p.SetState(453)
			p.ImportAlias()
		}

	case KotlinParserEOF, KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserSEMICOLON, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:

	default:
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(456)
			p.Semi()
		}

	}

	return localctx
}

// IImportAliasContext is an interface to support dynamic dispatch.
type IImportAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportAliasContext differentiates from other interfaces.
	IsImportAliasContext()
}

type ImportAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasContext() *ImportAliasContext {
	var p = new(ImportAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importAlias
	return p
}

func (*ImportAliasContext) IsImportAliasContext() {}

func NewImportAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasContext {
	var p = new(ImportAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importAlias

	return p
}

func (s *ImportAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *ImportAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ImportAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportAlias(s)
	}
}

func (s *ImportAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportAlias(s)
	}
}

func (p *KotlinParser) ImportAlias() (localctx IImportAliasContext) {
	localctx = NewImportAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KotlinParserRULE_importAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		p.Match(KotlinParserAS)
	}
	{
		p.SetState(460)
		p.SimpleIdentifier()
	}

	return localctx
}

// ITopLevelObjectContext is an interface to support dynamic dispatch.
type ITopLevelObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopLevelObjectContext differentiates from other interfaces.
	IsTopLevelObjectContext()
}

type TopLevelObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelObjectContext() *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_topLevelObject
	return p
}

func (*TopLevelObjectContext) IsTopLevelObjectContext() {}

func NewTopLevelObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_topLevelObject

	return p
}

func (s *TopLevelObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelObjectContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *TopLevelObjectContext) Semis() ISemisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *TopLevelObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTopLevelObject(s)
	}
}

func (s *TopLevelObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTopLevelObject(s)
	}
}

func (p *KotlinParser) TopLevelObject() (localctx ITopLevelObjectContext) {
	localctx = NewTopLevelObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KotlinParserRULE_topLevelObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Declaration()
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(463)
			p.Semis()
		}

	}

	return localctx
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeAlias
	return p
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) TYPE_ALIAS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTYPE_ALIAS, 0)
}

func (s *TypeAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeAliasContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *TypeAliasContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeAliasContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *TypeAliasContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeAliasContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeAliasContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (p *KotlinParser) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KotlinParserRULE_typeAlias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(466)
			p.Modifiers()
		}

	}
	{
		p.SetState(469)
		p.Match(KotlinParserTYPE_ALIAS)
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(470)
			p.Match(KotlinParserNL)
		}

		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(476)
		p.SimpleIdentifier()
	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(477)
				p.Match(KotlinParserNL)
			}

			p.SetState(482)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(483)
			p.TypeParameters()
		}

	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(486)
			p.Match(KotlinParserNL)
		}

		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(492)
		p.Match(KotlinParserASSIGNMENT)
	}
	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(493)
			p.Match(KotlinParserNL)
		}

		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(499)
		p.DataType()
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) ObjectDeclaration() IObjectDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *DeclarationContext) TypeAlias() ITypeAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *KotlinParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KotlinParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.ObjectDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(503)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(504)
			p.PropertyDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(505)
			p.TypeAlias()
		}

	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) PrimaryConstructor() IPrimaryConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryConstructorContext)
}

func (s *ClassDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ClassDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EnumClassBody() IEnumClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumClassBodyContext)
}

func (s *ClassDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *KotlinParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KotlinParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(508)
			p.Modifiers()
		}

	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserCLASS:
		{
			p.SetState(511)
			p.Match(KotlinParserCLASS)
		}

	case KotlinParserINTERFACE, KotlinParserFUN:
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserFUN {
			{
				p.SetState(512)
				p.Match(KotlinParserFUN)
			}
			p.SetState(516)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(513)
					p.Match(KotlinParserNL)
				}

				p.SetState(518)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(521)
			p.Match(KotlinParserINTERFACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(524)
			p.Match(KotlinParserNL)
		}

		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(530)
		p.SimpleIdentifier()
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		p.SetState(534)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(531)
				p.Match(KotlinParserNL)
			}

			p.SetState(536)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(537)
			p.TypeParameters()
		}

	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(540)
				p.Match(KotlinParserNL)
			}

			p.SetState(545)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(546)
			p.PrimaryConstructor()
		}

	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(549)
				p.Match(KotlinParserNL)
			}

			p.SetState(554)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(555)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(556)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(561)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
		}
		{
			p.SetState(562)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(565)
				p.Match(KotlinParserNL)
			}

			p.SetState(570)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(571)
			p.TypeConstraints()
		}

	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(574)
				p.Match(KotlinParserNL)
			}

			p.SetState(579)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(580)
			p.ClassBody()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 2 {
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(581)
				p.Match(KotlinParserNL)
			}

			p.SetState(586)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(587)
			p.EnumClassBody()
		}

	}

	return localctx
}

// IPrimaryConstructorContext is an interface to support dynamic dispatch.
type IPrimaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryConstructorContext differentiates from other interfaces.
	IsPrimaryConstructorContext()
}

type PrimaryConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryConstructorContext() *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryConstructor
	return p
}

func (*PrimaryConstructorContext) IsPrimaryConstructorContext() {}

func NewPrimaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryConstructor

	return p
}

func (s *PrimaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryConstructorContext) ClassParameters() IClassParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassParametersContext)
}

func (s *PrimaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *PrimaryConstructorContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *PrimaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PrimaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PrimaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryConstructor(s)
	}
}

func (s *PrimaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryConstructor(s)
	}
}

func (p *KotlinParser) PrimaryConstructor() (localctx IPrimaryConstructorContext) {
	localctx = NewPrimaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KotlinParserRULE_primaryConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(KotlinParserCONSTRUCTOR-79))|(1<<(KotlinParserPUBLIC-79))|(1<<(KotlinParserPRIVATE-79))|(1<<(KotlinParserPROTECTED-79))|(1<<(KotlinParserINTERNAL-79)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(KotlinParserENUM-111))|(1<<(KotlinParserSEALED-111))|(1<<(KotlinParserANNOTATION-111))|(1<<(KotlinParserDATA-111))|(1<<(KotlinParserINNER-111))|(1<<(KotlinParserVALUE-111))|(1<<(KotlinParserTAILREC-111))|(1<<(KotlinParserOPERATOR-111))|(1<<(KotlinParserINLINE-111))|(1<<(KotlinParserINFIX-111))|(1<<(KotlinParserEXTERNAL-111))|(1<<(KotlinParserSUSPEND-111))|(1<<(KotlinParserOVERRIDE-111))|(1<<(KotlinParserABSTRACT-111))|(1<<(KotlinParserFINAL-111))|(1<<(KotlinParserOPEN-111))|(1<<(KotlinParserCONST-111))|(1<<(KotlinParserLATEINIT-111))|(1<<(KotlinParserVARARG-111))|(1<<(KotlinParserNOINLINE-111))|(1<<(KotlinParserCROSSINLINE-111))|(1<<(KotlinParserEXPECT-111))|(1<<(KotlinParserACTUAL-111)))) != 0) {
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
			{
				p.SetState(590)
				p.Modifiers()
			}

		}
		{
			p.SetState(593)
			p.Match(KotlinParserCONSTRUCTOR)
		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(594)
				p.Match(KotlinParserNL)
			}

			p.SetState(599)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(602)
		p.ClassParameters()
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *ClassBodyContext) ClassMemberDeclarations() IClassMemberDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDeclarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationsContext)
}

func (s *ClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *ClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *KotlinParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KotlinParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(605)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}
	{
		p.SetState(611)
		p.ClassMemberDeclarations()
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(612)
			p.Match(KotlinParserNL)
		}

		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(618)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IClassParametersContext is an interface to support dynamic dispatch.
type IClassParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParametersContext differentiates from other interfaces.
	IsClassParametersContext()
}

type ClassParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParametersContext() *ClassParametersContext {
	var p = new(ClassParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameters
	return p
}

func (*ClassParametersContext) IsClassParametersContext() {}

func NewClassParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParametersContext {
	var p = new(ClassParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameters

	return p
}

func (s *ClassParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ClassParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ClassParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassParametersContext) AllClassParameter() []IClassParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassParameterContext)(nil)).Elem())
	var tst = make([]IClassParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassParameterContext)
		}
	}

	return tst
}

func (s *ClassParametersContext) ClassParameter(i int) IClassParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassParameterContext)
}

func (s *ClassParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ClassParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ClassParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameters(s)
	}
}

func (s *ClassParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameters(s)
	}
}

func (p *KotlinParser) ClassParameters() (localctx IClassParametersContext) {
	localctx = NewClassParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KotlinParserRULE_classParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(620)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(621)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(627)
			p.ClassParameter()
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(631)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(628)
						p.Match(KotlinParserNL)
					}

					p.SetState(633)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(634)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(638)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(635)
							p.Match(KotlinParserNL)
						}

					}
					p.SetState(640)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
				}
				{
					p.SetState(641)
					p.ClassParameter()
				}

			}
			p.SetState(646)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(647)
					p.Match(KotlinParserNL)
				}

				p.SetState(652)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(653)
				p.Match(KotlinParserCOMMA)
			}

		}

	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(658)
			p.Match(KotlinParserNL)
		}

		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(664)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IClassParameterContext is an interface to support dynamic dispatch.
type IClassParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParameterContext differentiates from other interfaces.
	IsClassParameterContext()
}

type ClassParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParameterContext() *ClassParameterContext {
	var p = new(ClassParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameter
	return p
}

func (*ClassParameterContext) IsClassParameterContext() {}

func NewClassParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParameterContext {
	var p = new(ClassParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameter

	return p
}

func (s *ClassParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassParameterContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ClassParameterContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ClassParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassParameterContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *ClassParameterContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *ClassParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameter(s)
	}
}

func (s *ClassParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameter(s)
	}
}

func (p *KotlinParser) ClassParameter() (localctx IClassParameterContext) {
	localctx = NewClassParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KotlinParserRULE_classParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(667)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(666)
			p.Modifiers()
		}

	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserVAL || _la == KotlinParserVAR {
		{
			p.SetState(669)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(672)
			p.Match(KotlinParserNL)
		}

		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(678)
		p.SimpleIdentifier()
	}
	{
		p.SetState(679)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(680)
			p.Match(KotlinParserNL)
		}

		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(686)
		p.DataType()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(687)
				p.Match(KotlinParserNL)
			}

			p.SetState(692)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(693)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(694)
				p.Match(KotlinParserNL)
			}

			p.SetState(699)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(700)
			p.Expression()
		}

	}

	return localctx
}

// IDelegationSpecifiersContext is an interface to support dynamic dispatch.
type IDelegationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelegationSpecifiersContext differentiates from other interfaces.
	IsDelegationSpecifiersContext()
}

type DelegationSpecifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifiersContext() *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers
	return p
}

func (*DelegationSpecifiersContext) IsDelegationSpecifiersContext() {}

func NewDelegationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers

	return p
}

func (s *DelegationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifiersContext) AllAnnotatedDelegationSpecifier() []IAnnotatedDelegationSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotatedDelegationSpecifierContext)(nil)).Elem())
	var tst = make([]IAnnotatedDelegationSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotatedDelegationSpecifierContext)
		}
	}

	return tst
}

func (s *DelegationSpecifiersContext) AnnotatedDelegationSpecifier(i int) IAnnotatedDelegationSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotatedDelegationSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotatedDelegationSpecifierContext)
}

func (s *DelegationSpecifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *DelegationSpecifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *DelegationSpecifiersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DelegationSpecifiersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DelegationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifiers(s)
	}
}

func (s *DelegationSpecifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifiers(s)
	}
}

func (p *KotlinParser) DelegationSpecifiers() (localctx IDelegationSpecifiersContext) {
	localctx = NewDelegationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KotlinParserRULE_delegationSpecifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.AnnotatedDelegationSpecifier()
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(707)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(704)
					p.Match(KotlinParserNL)
				}

				p.SetState(709)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(710)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(714)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(711)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(716)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
			}
			{
				p.SetState(717)
				p.AnnotatedDelegationSpecifier()
			}

		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}

	return localctx
}

// IDelegationSpecifierContext is an interface to support dynamic dispatch.
type IDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelegationSpecifierContext differentiates from other interfaces.
	IsDelegationSpecifierContext()
}

type DelegationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifierContext() *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifier
	return p
}

func (*DelegationSpecifierContext) IsDelegationSpecifierContext() {}

func NewDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifier

	return p
}

func (s *DelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifierContext) ConstructorInvocation() IConstructorInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *DelegationSpecifierContext) ExplicitDelegation() IExplicitDelegationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitDelegationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitDelegationContext)
}

func (s *DelegationSpecifierContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *DelegationSpecifierContext) FunctionType() IFunctionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *DelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifier(s)
	}
}

func (s *DelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifier(s)
	}
}

func (p *KotlinParser) DelegationSpecifier() (localctx IDelegationSpecifierContext) {
	localctx = NewDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KotlinParserRULE_delegationSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(724)
			p.ExplicitDelegation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(725)
			p.UserType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(726)
			p.FunctionType()
		}

	}

	return localctx
}

// IConstructorInvocationContext is an interface to support dynamic dispatch.
type IConstructorInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorInvocationContext differentiates from other interfaces.
	IsConstructorInvocationContext()
}

type ConstructorInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorInvocationContext() *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorInvocation
	return p
}

func (*ConstructorInvocationContext) IsConstructorInvocationContext() {}

func NewConstructorInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorInvocation

	return p
}

func (s *ConstructorInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorInvocationContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ConstructorInvocationContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorInvocation(s)
	}
}

func (s *ConstructorInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorInvocation(s)
	}
}

func (p *KotlinParser) ConstructorInvocation() (localctx IConstructorInvocationContext) {
	localctx = NewConstructorInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KotlinParserRULE_constructorInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.UserType()
	}
	{
		p.SetState(730)
		p.ValueArguments()
	}

	return localctx
}

// IAnnotatedDelegationSpecifierContext is an interface to support dynamic dispatch.
type IAnnotatedDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotatedDelegationSpecifierContext differentiates from other interfaces.
	IsAnnotatedDelegationSpecifierContext()
}

type AnnotatedDelegationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedDelegationSpecifierContext() *AnnotatedDelegationSpecifierContext {
	var p = new(AnnotatedDelegationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier
	return p
}

func (*AnnotatedDelegationSpecifierContext) IsAnnotatedDelegationSpecifierContext() {}

func NewAnnotatedDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedDelegationSpecifierContext {
	var p = new(AnnotatedDelegationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier

	return p
}

func (s *AnnotatedDelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedDelegationSpecifierContext) DelegationSpecifier() IDelegationSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifierContext)
}

func (s *AnnotatedDelegationSpecifierContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotatedDelegationSpecifierContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotatedDelegationSpecifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedDelegationSpecifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedDelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedDelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedDelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedDelegationSpecifier(s)
	}
}

func (s *AnnotatedDelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedDelegationSpecifier(s)
	}
}

func (p *KotlinParser) AnnotatedDelegationSpecifier() (localctx IAnnotatedDelegationSpecifierContext) {
	localctx = NewAnnotatedDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KotlinParserRULE_annotatedDelegationSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(732)
				p.Annotation()
			}

		}
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(738)
			p.Match(KotlinParserNL)
		}

		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(744)
		p.DelegationSpecifier()
	}

	return localctx
}

// IExplicitDelegationContext is an interface to support dynamic dispatch.
type IExplicitDelegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitDelegationContext differentiates from other interfaces.
	IsExplicitDelegationContext()
}

type ExplicitDelegationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitDelegationContext() *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_explicitDelegation
	return p
}

func (*ExplicitDelegationContext) IsExplicitDelegationContext() {}

func NewExplicitDelegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_explicitDelegation

	return p
}

func (s *ExplicitDelegationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitDelegationContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *ExplicitDelegationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExplicitDelegationContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ExplicitDelegationContext) FunctionType() IFunctionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *ExplicitDelegationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ExplicitDelegationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ExplicitDelegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitDelegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitDelegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExplicitDelegation(s)
	}
}

func (s *ExplicitDelegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExplicitDelegation(s)
	}
}

func (p *KotlinParser) ExplicitDelegation() (localctx IExplicitDelegationContext) {
	localctx = NewExplicitDelegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KotlinParserRULE_explicitDelegation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(746)
			p.UserType()
		}

	case 2:
		{
			p.SetState(747)
			p.FunctionType()
		}

	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(750)
			p.Match(KotlinParserNL)
		}

		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(756)
		p.Match(KotlinParserBY)
	}
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(757)
			p.Match(KotlinParserNL)
		}

		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(763)
		p.Expression()
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *KotlinParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KotlinParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.Match(KotlinParserLANGLE)
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(766)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
	}
	{
		p.SetState(772)
		p.TypeParameter()
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(776)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(773)
					p.Match(KotlinParserNL)
				}

				p.SetState(778)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(779)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(783)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(780)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(785)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
			}
			{
				p.SetState(786)
				p.TypeParameter()
			}

		}
		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(792)
				p.Match(KotlinParserNL)
			}

			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(798)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(804)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(801)
			p.Match(KotlinParserNL)
		}

		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(807)
		p.Match(KotlinParserRANGLE)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeParameterContext) TypeParameterModifiers() ITypeParameterModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifiersContext)
}

func (s *TypeParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeParameterContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *KotlinParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KotlinParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(810)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(809)
			p.TypeParameterModifiers()
		}

	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(812)
			p.Match(KotlinParserNL)
		}

		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(818)
		p.SimpleIdentifier()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(819)
				p.Match(KotlinParserNL)
			}

			p.SetState(824)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(825)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(826)
				p.Match(KotlinParserNL)
			}

			p.SetState(831)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(832)
			p.DataType()
		}

	}

	return localctx
}

// ITypeConstraintsContext is an interface to support dynamic dispatch.
type ITypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeConstraintsContext differentiates from other interfaces.
	IsTypeConstraintsContext()
}

type TypeConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintsContext() *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraints
	return p
}

func (*TypeConstraintsContext) IsTypeConstraintsContext() {}

func NewTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraints

	return p
}

func (s *TypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *TypeConstraintsContext) AllTypeConstraint() []ITypeConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeConstraintContext)(nil)).Elem())
	var tst = make([]ITypeConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeConstraintContext)
		}
	}

	return tst
}

func (s *TypeConstraintsContext) TypeConstraint(i int) ITypeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintContext)
}

func (s *TypeConstraintsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraints(s)
	}
}

func (s *TypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraints(s)
	}
}

func (p *KotlinParser) TypeConstraints() (localctx ITypeConstraintsContext) {
	localctx = NewTypeConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KotlinParserRULE_typeConstraints)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(835)
		p.Match(KotlinParserWHERE)
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(836)
			p.Match(KotlinParserNL)
		}

		p.SetState(841)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(842)
		p.TypeConstraint()
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(846)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(843)
					p.Match(KotlinParserNL)
				}

				p.SetState(848)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(849)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(853)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(850)
					p.Match(KotlinParserNL)
				}

				p.SetState(855)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(856)
				p.TypeConstraint()
			}

		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeConstraintContext is an interface to support dynamic dispatch.
type ITypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeConstraintContext differentiates from other interfaces.
	IsTypeConstraintContext()
}

type TypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintContext() *TypeConstraintContext {
	var p = new(TypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraint
	return p
}

func (*TypeConstraintContext) IsTypeConstraintContext() {}

func NewTypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintContext {
	var p = new(TypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraint

	return p
}

func (s *TypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeConstraintContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeConstraintContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeConstraintContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *TypeConstraintContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeConstraintContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraint(s)
	}
}

func (s *TypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraint(s)
	}
}

func (p *KotlinParser) TypeConstraint() (localctx ITypeConstraintContext) {
	localctx = NewTypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KotlinParserRULE_typeConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(862)
			p.Annotation()
		}

		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(868)
		p.SimpleIdentifier()
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(869)
			p.Match(KotlinParserNL)
		}

		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(875)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(876)
			p.Match(KotlinParserNL)
		}

		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(882)
		p.DataType()
	}

	return localctx
}

// IClassMemberDeclarationsContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMemberDeclarationsContext differentiates from other interfaces.
	IsClassMemberDeclarationsContext()
}

type ClassMemberDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationsContext() *ClassMemberDeclarationsContext {
	var p = new(ClassMemberDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations
	return p
}

func (*ClassMemberDeclarationsContext) IsClassMemberDeclarationsContext() {}

func NewClassMemberDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationsContext {
	var p = new(ClassMemberDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations

	return p
}

func (s *ClassMemberDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationsContext) AllClassMemberDeclaration() []IClassMemberDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem())
	var tst = make([]IClassMemberDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassMemberDeclarationContext)
		}
	}

	return tst
}

func (s *ClassMemberDeclarationsContext) ClassMemberDeclaration(i int) IClassMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *ClassMemberDeclarationsContext) AllSemis() []ISemisContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISemisContext)(nil)).Elem())
	var tst = make([]ISemisContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISemisContext)
		}
	}

	return tst
}

func (s *ClassMemberDeclarationsContext) Semis(i int) ISemisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemisContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *ClassMemberDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclarations(s)
	}
}

func (s *ClassMemberDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclarations(s)
	}
}

func (p *KotlinParser) ClassMemberDeclarations() (localctx IClassMemberDeclarationsContext) {
	localctx = NewClassMemberDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KotlinParserRULE_classMemberDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(KotlinParserCLASS-72))|(1<<(KotlinParserINTERFACE-72))|(1<<(KotlinParserFUN-72))|(1<<(KotlinParserOBJECT-72))|(1<<(KotlinParserVAL-72))|(1<<(KotlinParserVAR-72))|(1<<(KotlinParserTYPE_ALIAS-72))|(1<<(KotlinParserCONSTRUCTOR-72))|(1<<(KotlinParserCOMPANION-72))|(1<<(KotlinParserINIT-72)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(884)
			p.ClassMemberDeclaration()
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(885)
				p.Semis()
			}

		}

		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClassMemberDeclarationContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMemberDeclarationContext differentiates from other interfaces.
	IsClassMemberDeclarationContext()
}

type ClassMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationContext() *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration
	return p
}

func (*ClassMemberDeclarationContext) IsClassMemberDeclarationContext() {}

func NewClassMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration

	return p
}

func (s *ClassMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ClassMemberDeclarationContext) CompanionObject() ICompanionObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompanionObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompanionObjectContext)
}

func (s *ClassMemberDeclarationContext) AnonymousInitializer() IAnonymousInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousInitializerContext)
}

func (s *ClassMemberDeclarationContext) SecondaryConstructor() ISecondaryConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondaryConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecondaryConstructorContext)
}

func (s *ClassMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclaration(s)
	}
}

func (p *KotlinParser) ClassMemberDeclaration() (localctx IClassMemberDeclarationContext) {
	localctx = NewClassMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KotlinParserRULE_classMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)
			p.CompanionObject()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(895)
			p.AnonymousInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(896)
			p.SecondaryConstructor()
		}

	}

	return localctx
}

// IAnonymousInitializerContext is an interface to support dynamic dispatch.
type IAnonymousInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousInitializerContext differentiates from other interfaces.
	IsAnonymousInitializerContext()
}

type AnonymousInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousInitializerContext() *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousInitializer
	return p
}

func (*AnonymousInitializerContext) IsAnonymousInitializerContext() {}

func NewAnonymousInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousInitializer

	return p
}

func (s *AnonymousInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInitializerContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *AnonymousInitializerContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *AnonymousInitializerContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousInitializerContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousInitializer(s)
	}
}

func (s *AnonymousInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousInitializer(s)
	}
}

func (p *KotlinParser) AnonymousInitializer() (localctx IAnonymousInitializerContext) {
	localctx = NewAnonymousInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KotlinParserRULE_anonymousInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(899)
		p.Match(KotlinParserINIT)
	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(900)
			p.Match(KotlinParserNL)
		}

		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(906)
		p.Block()
	}

	return localctx
}

// ICompanionObjectContext is an interface to support dynamic dispatch.
type ICompanionObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompanionObjectContext differentiates from other interfaces.
	IsCompanionObjectContext()
}

type CompanionObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompanionObjectContext() *CompanionObjectContext {
	var p = new(CompanionObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_companionObject
	return p
}

func (*CompanionObjectContext) IsCompanionObjectContext() {}

func NewCompanionObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompanionObjectContext {
	var p = new(CompanionObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_companionObject

	return p
}

func (s *CompanionObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *CompanionObjectContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *CompanionObjectContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *CompanionObjectContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *CompanionObjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CompanionObjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CompanionObjectContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CompanionObjectContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CompanionObjectContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *CompanionObjectContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *CompanionObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompanionObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompanionObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCompanionObject(s)
	}
}

func (s *CompanionObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCompanionObject(s)
	}
}

func (p *KotlinParser) CompanionObject() (localctx ICompanionObjectContext) {
	localctx = NewCompanionObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KotlinParserRULE_companionObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(908)
			p.Modifiers()
		}

	}
	{
		p.SetState(911)
		p.Match(KotlinParserCOMPANION)
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(912)
			p.Match(KotlinParserNL)
		}

		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(918)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(919)
				p.Match(KotlinParserNL)
			}

			p.SetState(924)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(925)
			p.SimpleIdentifier()
		}

	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(928)
				p.Match(KotlinParserNL)
			}

			p.SetState(933)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(934)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(935)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(940)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())
		}
		{
			p.SetState(941)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(944)
				p.Match(KotlinParserNL)
			}

			p.SetState(949)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(950)
			p.ClassBody()
		}

	}

	return localctx
}

// IFunctionValueParametersContext is an interface to support dynamic dispatch.
type IFunctionValueParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionValueParametersContext differentiates from other interfaces.
	IsFunctionValueParametersContext()
}

type FunctionValueParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParametersContext() *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameters
	return p
}

func (*FunctionValueParametersContext) IsFunctionValueParametersContext() {}

func NewFunctionValueParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameters

	return p
}

func (s *FunctionValueParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionValueParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionValueParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParametersContext) AllFunctionValueParameter() []IFunctionValueParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionValueParameterContext)(nil)).Elem())
	var tst = make([]IFunctionValueParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionValueParameterContext)
		}
	}

	return tst
}

func (s *FunctionValueParametersContext) FunctionValueParameter(i int) IFunctionValueParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterContext)
}

func (s *FunctionValueParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionValueParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionValueParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameters(s)
	}
}

func (s *FunctionValueParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameters(s)
	}
}

func (p *KotlinParser) FunctionValueParameters() (localctx IFunctionValueParametersContext) {
	localctx = NewFunctionValueParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KotlinParserRULE_functionValueParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(954)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT_NO_WS-40))|(1<<(KotlinParserAT_PRE_WS-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserFIELD-40))|(1<<(KotlinParserPROPERTY-40))|(1<<(KotlinParserGET-40))|(1<<(KotlinParserSET-40))|(1<<(KotlinParserRECEIVER-40))|(1<<(KotlinParserPARAM-40))|(1<<(KotlinParserSETPARAM-40))|(1<<(KotlinParserDELEGATE-40))|(1<<(KotlinParserIMPORT-40)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(KotlinParserCONSTRUCTOR-79))|(1<<(KotlinParserBY-79))|(1<<(KotlinParserCOMPANION-79))|(1<<(KotlinParserINIT-79))|(1<<(KotlinParserWHERE-79))|(1<<(KotlinParserCATCH-79))|(1<<(KotlinParserFINALLY-79))|(1<<(KotlinParserOUT-79))|(1<<(KotlinParserDYNAMIC-79))|(1<<(KotlinParserPUBLIC-79))|(1<<(KotlinParserPRIVATE-79))|(1<<(KotlinParserPROTECTED-79))|(1<<(KotlinParserINTERNAL-79)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(KotlinParserENUM-111))|(1<<(KotlinParserSEALED-111))|(1<<(KotlinParserANNOTATION-111))|(1<<(KotlinParserDATA-111))|(1<<(KotlinParserINNER-111))|(1<<(KotlinParserVALUE-111))|(1<<(KotlinParserTAILREC-111))|(1<<(KotlinParserOPERATOR-111))|(1<<(KotlinParserINLINE-111))|(1<<(KotlinParserINFIX-111))|(1<<(KotlinParserEXTERNAL-111))|(1<<(KotlinParserSUSPEND-111))|(1<<(KotlinParserOVERRIDE-111))|(1<<(KotlinParserABSTRACT-111))|(1<<(KotlinParserFINAL-111))|(1<<(KotlinParserOPEN-111))|(1<<(KotlinParserCONST-111))|(1<<(KotlinParserLATEINIT-111))|(1<<(KotlinParserVARARG-111))|(1<<(KotlinParserNOINLINE-111))|(1<<(KotlinParserCROSSINLINE-111))|(1<<(KotlinParserREIFIED-111))|(1<<(KotlinParserEXPECT-111))|(1<<(KotlinParserACTUAL-111)))) != 0) || _la == KotlinParserIdentifier {
		{
			p.SetState(960)
			p.FunctionValueParameter()
		}
		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(964)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(961)
						p.Match(KotlinParserNL)
					}

					p.SetState(966)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(967)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(971)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(968)
						p.Match(KotlinParserNL)
					}

					p.SetState(973)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(974)
					p.FunctionValueParameter()
				}

			}
			p.SetState(979)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext())
		}
		p.SetState(987)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			p.SetState(983)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(980)
					p.Match(KotlinParserNL)
				}

				p.SetState(985)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(986)
				p.Match(KotlinParserCOMMA)
			}

		}

	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(991)
			p.Match(KotlinParserNL)
		}

		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(997)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IFunctionValueParameterContext is an interface to support dynamic dispatch.
type IFunctionValueParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionValueParameterContext differentiates from other interfaces.
	IsFunctionValueParameterContext()
}

type FunctionValueParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterContext() *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameter
	return p
}

func (*FunctionValueParameterContext) IsFunctionValueParameterContext() {}

func NewFunctionValueParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameter

	return p
}

func (s *FunctionValueParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionValueParameterContext) ParameterModifiers() IParameterModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterModifiersContext)
}

func (s *FunctionValueParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameter(s)
	}
}

func (s *FunctionValueParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameter(s)
	}
}

func (p *KotlinParser) FunctionValueParameter() (localctx IFunctionValueParameterContext) {
	localctx = NewFunctionValueParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KotlinParserRULE_functionValueParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(999)
			p.ParameterModifiers()
		}

	}
	{
		p.SetState(1002)
		p.Parameter()
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1003)
				p.Match(KotlinParserNL)
			}

			p.SetState(1008)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1009)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1010)
				p.Match(KotlinParserNL)
			}

			p.SetState(1015)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1016)
			p.Expression()
		}

	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *FunctionDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *FunctionDeclarationContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *FunctionDeclarationContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *FunctionDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionDeclarationContext) ReceiverType() IReceiverTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *FunctionDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FunctionDeclarationContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *KotlinParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KotlinParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(1019)
			p.Modifiers()
		}

	}
	{
		p.SetState(1022)
		p.Match(KotlinParserFUN)
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1023)
				p.Match(KotlinParserNL)
			}

			p.SetState(1028)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1029)
			p.TypeParameters()
		}

	}
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1032)
				p.Match(KotlinParserNL)
			}

			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1038)
			p.ReceiverType()
		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1039)
				p.Match(KotlinParserNL)
			}

			p.SetState(1044)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1045)
			p.Match(KotlinParserDOT)
		}

	}
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1049)
			p.Match(KotlinParserNL)
		}

		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1055)
		p.SimpleIdentifier()
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1056)
			p.Match(KotlinParserNL)
		}

		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1062)
		p.FunctionValueParameters()
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1063)
				p.Match(KotlinParserNL)
			}

			p.SetState(1068)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1069)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1070)
				p.Match(KotlinParserNL)
			}

			p.SetState(1075)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1076)
			p.DataType()
		}

	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1079)
				p.Match(KotlinParserNL)
			}

			p.SetState(1084)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1085)
			p.TypeConstraints()
		}

	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1088)
				p.Match(KotlinParserNL)
			}

			p.SetState(1093)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1094)
			p.FunctionBody()
		}

	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionBodyContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *KotlinParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KotlinParserRULE_functionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1106)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1097)
			p.Block()
		}

	case KotlinParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1098)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1099)
				p.Match(KotlinParserNL)
			}

			p.SetState(1104)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1105)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *VariableDeclarationContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *VariableDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *VariableDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *VariableDeclarationContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *KotlinParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KotlinParserRULE_variableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(1108)
			p.Annotation()
		}

		p.SetState(1113)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1114)
			p.Match(KotlinParserNL)
		}

		p.SetState(1119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1120)
		p.SimpleIdentifier()
	}
	p.SetState(1135)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1121)
				p.Match(KotlinParserNL)
			}

			p.SetState(1126)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1127)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1128)
				p.Match(KotlinParserNL)
			}

			p.SetState(1133)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1134)
			p.DataType()
		}

	}

	return localctx
}

// IMultiVariableDeclarationContext is an interface to support dynamic dispatch.
type IMultiVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiVariableDeclarationContext differentiates from other interfaces.
	IsMultiVariableDeclarationContext()
}

type MultiVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiVariableDeclarationContext() *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration
	return p
}

func (*MultiVariableDeclarationContext) IsMultiVariableDeclarationContext() {}

func NewMultiVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration

	return p
}

func (s *MultiVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiVariableDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllVariableDeclaration() []IVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclarationContext)
		}
	}

	return tst
}

func (s *MultiVariableDeclarationContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *MultiVariableDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiVariableDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiVariableDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *MultiVariableDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *MultiVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiVariableDeclaration(s)
	}
}

func (s *MultiVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiVariableDeclaration(s)
	}
}

func (p *KotlinParser) MultiVariableDeclaration() (localctx IMultiVariableDeclarationContext) {
	localctx = NewMultiVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KotlinParserRULE_multiVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1141)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1138)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}
	{
		p.SetState(1144)
		p.VariableDeclaration()
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1148)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1145)
					p.Match(KotlinParserNL)
				}

				p.SetState(1150)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1151)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1155)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1152)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1157)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
			}
			{
				p.SetState(1158)
				p.VariableDeclaration()
			}

		}
		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1164)
				p.Match(KotlinParserNL)
			}

			p.SetState(1169)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1170)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1173)
			p.Match(KotlinParserNL)
		}

		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1179)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDeclaration
	return p
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *PropertyDeclarationContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *PropertyDeclarationContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *PropertyDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *PropertyDeclarationContext) ReceiverType() IReceiverTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *PropertyDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *PropertyDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *PropertyDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *PropertyDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDeclarationContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *PropertyDeclarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDeclarationContext) PropertyDelegate() IPropertyDelegateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDelegateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyDelegateContext)
}

func (s *PropertyDeclarationContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyDeclarationContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyDeclarationContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (p *KotlinParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KotlinParserRULE_propertyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(1181)
			p.Modifiers()
		}

	}
	{
		p.SetState(1184)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1185)
				p.Match(KotlinParserNL)
			}

			p.SetState(1190)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1191)
			p.TypeParameters()
		}

	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1194)
				p.Match(KotlinParserNL)
			}

			p.SetState(1199)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1200)
			p.ReceiverType()
		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1201)
				p.Match(KotlinParserNL)
			}

			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1207)
			p.Match(KotlinParserDOT)
		}

	}

	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1211)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN:
		{
			p.SetState(1217)
			p.MultiVariableDeclaration()
		}

	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1218)
			p.VariableDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	p.SetState(1228)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1221)
				p.Match(KotlinParserNL)
			}

			p.SetState(1226)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1227)
			p.TypeConstraints()
		}

	}
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		p.SetState(1233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1230)
				p.Match(KotlinParserNL)
			}

			p.SetState(1235)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserASSIGNMENT:
			{
				p.SetState(1236)
				p.Match(KotlinParserASSIGNMENT)
			}
			p.SetState(1240)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1237)
					p.Match(KotlinParserNL)
				}

				p.SetState(1242)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1243)
				p.Expression()
			}

		case KotlinParserBY:
			{
				p.SetState(1244)
				p.PropertyDelegate()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KotlinParserNL {
			{
				p.SetState(1249)
				p.Match(KotlinParserNL)
			}

			p.SetState(1252)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1254)
			p.Match(KotlinParserSEMICOLON)
		}

	}
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1257)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())
	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1264)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1263)
				p.Getter()
			}

		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
			p.SetState(1269)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1266)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1271)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())
			}
			p.SetState(1273)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(KotlinParserEOF - -1))|(1<<(KotlinParserNL - -1))|(1<<(KotlinParserSEMICOLON - -1)))) != 0 {
				{
					p.SetState(1272)
					p.Semi()
				}

			}
			{
				p.SetState(1275)
				p.Setter()
			}

		}

	case 2:
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1278)
				p.Setter()
			}

		}
		p.SetState(1291)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			p.SetState(1284)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1281)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1286)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())
			}
			p.SetState(1288)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(KotlinParserEOF - -1))|(1<<(KotlinParserNL - -1))|(1<<(KotlinParserSEMICOLON - -1)))) != 0 {
				{
					p.SetState(1287)
					p.Semi()
				}

			}
			{
				p.SetState(1290)
				p.Getter()
			}

		}

	}

	return localctx
}

// IPropertyDelegateContext is an interface to support dynamic dispatch.
type IPropertyDelegateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyDelegateContext differentiates from other interfaces.
	IsPropertyDelegateContext()
}

type PropertyDelegateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDelegateContext() *PropertyDelegateContext {
	var p = new(PropertyDelegateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDelegate
	return p
}

func (*PropertyDelegateContext) IsPropertyDelegateContext() {}

func NewPropertyDelegateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDelegateContext {
	var p = new(PropertyDelegateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDelegate

	return p
}

func (s *PropertyDelegateContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDelegateContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *PropertyDelegateContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDelegateContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDelegateContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDelegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDelegateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDelegateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDelegate(s)
	}
}

func (s *PropertyDelegateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDelegate(s)
	}
}

func (p *KotlinParser) PropertyDelegate() (localctx IPropertyDelegateContext) {
	localctx = NewPropertyDelegateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KotlinParserRULE_propertyDelegate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		p.Match(KotlinParserBY)
	}
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1296)
			p.Match(KotlinParserNL)
		}

		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1302)
		p.Expression()
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *GetterContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *GetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *GetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *GetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *GetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *GetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *GetterContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (p *KotlinParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KotlinParserRULE_getter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(1304)
			p.Modifiers()
		}

	}
	{
		p.SetState(1307)
		p.Match(KotlinParserGET)
	}
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
		p.SetState(1311)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1308)
				p.Match(KotlinParserNL)
			}

			p.SetState(1313)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1314)
			p.Match(KotlinParserLPAREN)
		}
		p.SetState(1318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1315)
				p.Match(KotlinParserNL)
			}

			p.SetState(1320)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1321)
			p.Match(KotlinParserRPAREN)
		}
		p.SetState(1336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			p.SetState(1325)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1322)
					p.Match(KotlinParserNL)
				}

				p.SetState(1327)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1328)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(1332)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1329)
					p.Match(KotlinParserNL)
				}

				p.SetState(1334)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1335)
				p.DataType()
			}

		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1338)
				p.Match(KotlinParserNL)
			}

			p.SetState(1343)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1344)
			p.FunctionBody()
		}

	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *SetterContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *SetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *SetterContext) FunctionValueParameterWithOptionalType() IFunctionValueParameterWithOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParameterWithOptionalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterWithOptionalTypeContext)
}

func (s *SetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *SetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *SetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SetterContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *SetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SetterContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (p *KotlinParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KotlinParserRULE_setter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(1347)
			p.Modifiers()
		}

	}
	{
		p.SetState(1350)
		p.Match(KotlinParserSET)
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1351)
				p.Match(KotlinParserNL)
			}

			p.SetState(1356)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1357)
			p.Match(KotlinParserLPAREN)
		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1358)
				p.Match(KotlinParserNL)
			}

			p.SetState(1363)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1364)
			p.FunctionValueParameterWithOptionalType()
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			p.SetState(1368)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1365)
					p.Match(KotlinParserNL)
				}

				p.SetState(1370)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1371)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1374)
				p.Match(KotlinParserNL)
			}

			p.SetState(1379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1380)
			p.Match(KotlinParserRPAREN)
		}
		p.SetState(1395)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext()) == 1 {
			p.SetState(1384)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1381)
					p.Match(KotlinParserNL)
				}

				p.SetState(1386)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1387)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(1391)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1388)
					p.Match(KotlinParserNL)
				}

				p.SetState(1393)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1394)
				p.DataType()
			}

		}
		p.SetState(1400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1397)
				p.Match(KotlinParserNL)
			}

			p.SetState(1402)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1403)
			p.FunctionBody()
		}

	}

	return localctx
}

// IParametersWithOptionalTypeContext is an interface to support dynamic dispatch.
type IParametersWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParametersWithOptionalTypeContext differentiates from other interfaces.
	IsParametersWithOptionalTypeContext()
}

type ParametersWithOptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersWithOptionalTypeContext() *ParametersWithOptionalTypeContext {
	var p = new(ParametersWithOptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType
	return p
}

func (*ParametersWithOptionalTypeContext) IsParametersWithOptionalTypeContext() {}

func NewParametersWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersWithOptionalTypeContext {
	var p = new(ParametersWithOptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType

	return p
}

func (s *ParametersWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersWithOptionalTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParametersWithOptionalTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParametersWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParametersWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParametersWithOptionalTypeContext) AllFunctionValueParameterWithOptionalType() []IFunctionValueParameterWithOptionalTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionValueParameterWithOptionalTypeContext)(nil)).Elem())
	var tst = make([]IFunctionValueParameterWithOptionalTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionValueParameterWithOptionalTypeContext)
		}
	}

	return tst
}

func (s *ParametersWithOptionalTypeContext) FunctionValueParameterWithOptionalType(i int) IFunctionValueParameterWithOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParameterWithOptionalTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterWithOptionalTypeContext)
}

func (s *ParametersWithOptionalTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ParametersWithOptionalTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ParametersWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParametersWithOptionalType(s)
	}
}

func (s *ParametersWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParametersWithOptionalType(s)
	}
}

func (p *KotlinParser) ParametersWithOptionalType() (localctx IParametersWithOptionalTypeContext) {
	localctx = NewParametersWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KotlinParserRULE_parametersWithOptionalType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1411)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1408)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1413)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext())
	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT_NO_WS-40))|(1<<(KotlinParserAT_PRE_WS-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserFIELD-40))|(1<<(KotlinParserPROPERTY-40))|(1<<(KotlinParserGET-40))|(1<<(KotlinParserSET-40))|(1<<(KotlinParserRECEIVER-40))|(1<<(KotlinParserPARAM-40))|(1<<(KotlinParserSETPARAM-40))|(1<<(KotlinParserDELEGATE-40))|(1<<(KotlinParserIMPORT-40)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(KotlinParserCONSTRUCTOR-79))|(1<<(KotlinParserBY-79))|(1<<(KotlinParserCOMPANION-79))|(1<<(KotlinParserINIT-79))|(1<<(KotlinParserWHERE-79))|(1<<(KotlinParserCATCH-79))|(1<<(KotlinParserFINALLY-79))|(1<<(KotlinParserOUT-79))|(1<<(KotlinParserDYNAMIC-79))|(1<<(KotlinParserPUBLIC-79))|(1<<(KotlinParserPRIVATE-79))|(1<<(KotlinParserPROTECTED-79))|(1<<(KotlinParserINTERNAL-79)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(KotlinParserENUM-111))|(1<<(KotlinParserSEALED-111))|(1<<(KotlinParserANNOTATION-111))|(1<<(KotlinParserDATA-111))|(1<<(KotlinParserINNER-111))|(1<<(KotlinParserVALUE-111))|(1<<(KotlinParserTAILREC-111))|(1<<(KotlinParserOPERATOR-111))|(1<<(KotlinParserINLINE-111))|(1<<(KotlinParserINFIX-111))|(1<<(KotlinParserEXTERNAL-111))|(1<<(KotlinParserSUSPEND-111))|(1<<(KotlinParserOVERRIDE-111))|(1<<(KotlinParserABSTRACT-111))|(1<<(KotlinParserFINAL-111))|(1<<(KotlinParserOPEN-111))|(1<<(KotlinParserCONST-111))|(1<<(KotlinParserLATEINIT-111))|(1<<(KotlinParserVARARG-111))|(1<<(KotlinParserNOINLINE-111))|(1<<(KotlinParserCROSSINLINE-111))|(1<<(KotlinParserREIFIED-111))|(1<<(KotlinParserEXPECT-111))|(1<<(KotlinParserACTUAL-111)))) != 0) || _la == KotlinParserIdentifier {
		{
			p.SetState(1414)
			p.FunctionValueParameterWithOptionalType()
		}
		p.SetState(1431)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1418)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1415)
						p.Match(KotlinParserNL)
					}

					p.SetState(1420)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1421)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(1425)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1422)
						p.Match(KotlinParserNL)
					}

					p.SetState(1427)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1428)
					p.FunctionValueParameterWithOptionalType()
				}

			}
			p.SetState(1433)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext())
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
			p.SetState(1437)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1434)
					p.Match(KotlinParserNL)
				}

				p.SetState(1439)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1440)
				p.Match(KotlinParserCOMMA)
			}

		}

	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1445)
			p.Match(KotlinParserNL)
		}

		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1451)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IFunctionValueParameterWithOptionalTypeContext is an interface to support dynamic dispatch.
type IFunctionValueParameterWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionValueParameterWithOptionalTypeContext differentiates from other interfaces.
	IsFunctionValueParameterWithOptionalTypeContext()
}

type FunctionValueParameterWithOptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterWithOptionalTypeContext() *FunctionValueParameterWithOptionalTypeContext {
	var p = new(FunctionValueParameterWithOptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType
	return p
}

func (*FunctionValueParameterWithOptionalTypeContext) IsFunctionValueParameterWithOptionalTypeContext() {
}

func NewFunctionValueParameterWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterWithOptionalTypeContext {
	var p = new(FunctionValueParameterWithOptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType

	return p
}

func (s *FunctionValueParameterWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterWithOptionalTypeContext) ParameterWithOptionalType() IParameterWithOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterWithOptionalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterWithOptionalTypeContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) ParameterModifiers() IParameterModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterModifiersContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterWithOptionalTypeContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParameterWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParameterWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameterWithOptionalType(s)
	}
}

func (s *FunctionValueParameterWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameterWithOptionalType(s)
	}
}

func (p *KotlinParser) FunctionValueParameterWithOptionalType() (localctx IFunctionValueParameterWithOptionalTypeContext) {
	localctx = NewFunctionValueParameterWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KotlinParserRULE_functionValueParameterWithOptionalType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1454)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1453)
			p.ParameterModifiers()
		}

	}
	{
		p.SetState(1456)
		p.ParameterWithOptionalType()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		p.SetState(1460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1457)
				p.Match(KotlinParserNL)
			}

			p.SetState(1462)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1463)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1464)
				p.Match(KotlinParserNL)
			}

			p.SetState(1469)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1470)
			p.Expression()
		}

	}

	return localctx
}

// IParameterWithOptionalTypeContext is an interface to support dynamic dispatch.
type IParameterWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterWithOptionalTypeContext differentiates from other interfaces.
	IsParameterWithOptionalTypeContext()
}

type ParameterWithOptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterWithOptionalTypeContext() *ParameterWithOptionalTypeContext {
	var p = new(ParameterWithOptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType
	return p
}

func (*ParameterWithOptionalTypeContext) IsParameterWithOptionalTypeContext() {}

func NewParameterWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterWithOptionalTypeContext {
	var p = new(ParameterWithOptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType

	return p
}

func (s *ParameterWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterWithOptionalTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParameterWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParameterWithOptionalTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterWithOptionalTypeContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ParameterWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterWithOptionalType(s)
	}
}

func (s *ParameterWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterWithOptionalType(s)
	}
}

func (p *KotlinParser) ParameterWithOptionalType() (localctx IParameterWithOptionalTypeContext) {
	localctx = NewParameterWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KotlinParserRULE_parameterWithOptionalType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.SimpleIdentifier()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1474)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1479)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())
	}
	p.SetState(1488)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOLON {
		{
			p.SetState(1480)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1481)
				p.Match(KotlinParserNL)
			}

			p.SetState(1486)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1487)
			p.DataType()
		}

	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *KotlinParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KotlinParserRULE_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1490)
		p.SimpleIdentifier()
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1491)
			p.Match(KotlinParserNL)
		}

		p.SetState(1496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1497)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1498)
			p.Match(KotlinParserNL)
		}

		p.SetState(1503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1504)
		p.DataType()
	}

	return localctx
}

// IObjectDeclarationContext is an interface to support dynamic dispatch.
type IObjectDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectDeclarationContext differentiates from other interfaces.
	IsObjectDeclarationContext()
}

type ObjectDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDeclarationContext() *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_objectDeclaration
	return p
}

func (*ObjectDeclarationContext) IsObjectDeclarationContext() {}

func NewObjectDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectDeclaration

	return p
}

func (s *ObjectDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDeclarationContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ObjectDeclarationContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ObjectDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectDeclaration(s)
	}
}

func (s *ObjectDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectDeclaration(s)
	}
}

func (p *KotlinParser) ObjectDeclaration() (localctx IObjectDeclarationContext) {
	localctx = NewObjectDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KotlinParserRULE_objectDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(1506)
			p.Modifiers()
		}

	}
	{
		p.SetState(1509)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(1513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1510)
			p.Match(KotlinParserNL)
		}

		p.SetState(1515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1516)
		p.SimpleIdentifier()
	}
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1517)
				p.Match(KotlinParserNL)
			}

			p.SetState(1522)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1523)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1524)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1529)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())
		}
		{
			p.SetState(1530)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
		p.SetState(1536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1533)
				p.Match(KotlinParserNL)
			}

			p.SetState(1538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1539)
			p.ClassBody()
		}

	}

	return localctx
}

// ISecondaryConstructorContext is an interface to support dynamic dispatch.
type ISecondaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondaryConstructorContext differentiates from other interfaces.
	IsSecondaryConstructorContext()
}

type SecondaryConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondaryConstructorContext() *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_secondaryConstructor
	return p
}

func (*SecondaryConstructorContext) IsSecondaryConstructorContext() {}

func NewSecondaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_secondaryConstructor

	return p
}

func (s *SecondaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *SecondaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SecondaryConstructorContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *SecondaryConstructorContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *SecondaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SecondaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SecondaryConstructorContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SecondaryConstructorContext) ConstructorDelegationCall() IConstructorDelegationCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorDelegationCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorDelegationCallContext)
}

func (s *SecondaryConstructorContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SecondaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecondaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecondaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSecondaryConstructor(s)
	}
}

func (s *SecondaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSecondaryConstructor(s)
	}
}

func (p *KotlinParser) SecondaryConstructor() (localctx ISecondaryConstructorContext) {
	localctx = NewSecondaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KotlinParserRULE_secondaryConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107))|(1<<(KotlinParserENUM-107))|(1<<(KotlinParserSEALED-107))|(1<<(KotlinParserANNOTATION-107))|(1<<(KotlinParserDATA-107))|(1<<(KotlinParserINNER-107))|(1<<(KotlinParserVALUE-107))|(1<<(KotlinParserTAILREC-107))|(1<<(KotlinParserOPERATOR-107))|(1<<(KotlinParserINLINE-107))|(1<<(KotlinParserINFIX-107))|(1<<(KotlinParserEXTERNAL-107))|(1<<(KotlinParserSUSPEND-107))|(1<<(KotlinParserOVERRIDE-107))|(1<<(KotlinParserABSTRACT-107))|(1<<(KotlinParserFINAL-107))|(1<<(KotlinParserOPEN-107))|(1<<(KotlinParserCONST-107))|(1<<(KotlinParserLATEINIT-107))|(1<<(KotlinParserVARARG-107))|(1<<(KotlinParserNOINLINE-107))|(1<<(KotlinParserCROSSINLINE-107))|(1<<(KotlinParserEXPECT-107))|(1<<(KotlinParserACTUAL-107)))) != 0) {
		{
			p.SetState(1542)
			p.Modifiers()
		}

	}
	{
		p.SetState(1545)
		p.Match(KotlinParserCONSTRUCTOR)
	}
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1546)
			p.Match(KotlinParserNL)
		}

		p.SetState(1551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1552)
		p.FunctionValueParameters()
	}
	p.SetState(1567)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		p.SetState(1556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1553)
				p.Match(KotlinParserNL)
			}

			p.SetState(1558)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1559)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1560)
				p.Match(KotlinParserNL)
			}

			p.SetState(1565)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1566)
			p.ConstructorDelegationCall()
		}

	}
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1569)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1574)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext())
	}
	p.SetState(1576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLCURL {
		{
			p.SetState(1575)
			p.Block()
		}

	}

	return localctx
}

// IConstructorDelegationCallContext is an interface to support dynamic dispatch.
type IConstructorDelegationCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorDelegationCallContext differentiates from other interfaces.
	IsConstructorDelegationCallContext()
}

type ConstructorDelegationCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDelegationCallContext() *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall
	return p
}

func (*ConstructorDelegationCallContext) IsConstructorDelegationCallContext() {}

func NewConstructorDelegationCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall

	return p
}

func (s *ConstructorDelegationCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDelegationCallContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorDelegationCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ConstructorDelegationCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *ConstructorDelegationCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConstructorDelegationCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConstructorDelegationCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDelegationCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDelegationCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorDelegationCall(s)
	}
}

func (s *ConstructorDelegationCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorDelegationCall(s)
	}
}

func (p *KotlinParser) ConstructorDelegationCall() (localctx IConstructorDelegationCallContext) {
	localctx = NewConstructorDelegationCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KotlinParserRULE_constructorDelegationCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1578)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserTHIS || _la == KotlinParserSUPER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1579)
			p.Match(KotlinParserNL)
		}

		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1585)
		p.ValueArguments()
	}

	return localctx
}

// IEnumClassBodyContext is an interface to support dynamic dispatch.
type IEnumClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumClassBodyContext differentiates from other interfaces.
	IsEnumClassBodyContext()
}

type EnumClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumClassBodyContext() *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumClassBody
	return p
}

func (*EnumClassBodyContext) IsEnumClassBodyContext() {}

func NewEnumClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumClassBody

	return p
}

func (s *EnumClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *EnumClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *EnumClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumClassBodyContext) EnumEntries() IEnumEntriesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumEntriesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumEntriesContext)
}

func (s *EnumClassBodyContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *EnumClassBodyContext) ClassMemberDeclarations() IClassMemberDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDeclarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationsContext)
}

func (s *EnumClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumClassBody(s)
	}
}

func (s *EnumClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumClassBody(s)
	}
}

func (p *KotlinParser) EnumClassBody() (localctx IEnumClassBodyContext) {
	localctx = NewEnumClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KotlinParserRULE_enumClassBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(1591)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1588)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())
	}
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT_NO_WS-40))|(1<<(KotlinParserAT_PRE_WS-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserFIELD-40))|(1<<(KotlinParserPROPERTY-40))|(1<<(KotlinParserGET-40))|(1<<(KotlinParserSET-40))|(1<<(KotlinParserRECEIVER-40))|(1<<(KotlinParserPARAM-40))|(1<<(KotlinParserSETPARAM-40))|(1<<(KotlinParserDELEGATE-40))|(1<<(KotlinParserIMPORT-40)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(KotlinParserCONSTRUCTOR-79))|(1<<(KotlinParserBY-79))|(1<<(KotlinParserCOMPANION-79))|(1<<(KotlinParserINIT-79))|(1<<(KotlinParserWHERE-79))|(1<<(KotlinParserCATCH-79))|(1<<(KotlinParserFINALLY-79))|(1<<(KotlinParserOUT-79))|(1<<(KotlinParserDYNAMIC-79))|(1<<(KotlinParserPUBLIC-79))|(1<<(KotlinParserPRIVATE-79))|(1<<(KotlinParserPROTECTED-79))|(1<<(KotlinParserINTERNAL-79)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(KotlinParserENUM-111))|(1<<(KotlinParserSEALED-111))|(1<<(KotlinParserANNOTATION-111))|(1<<(KotlinParserDATA-111))|(1<<(KotlinParserINNER-111))|(1<<(KotlinParserVALUE-111))|(1<<(KotlinParserTAILREC-111))|(1<<(KotlinParserOPERATOR-111))|(1<<(KotlinParserINLINE-111))|(1<<(KotlinParserINFIX-111))|(1<<(KotlinParserEXTERNAL-111))|(1<<(KotlinParserSUSPEND-111))|(1<<(KotlinParserOVERRIDE-111))|(1<<(KotlinParserABSTRACT-111))|(1<<(KotlinParserFINAL-111))|(1<<(KotlinParserOPEN-111))|(1<<(KotlinParserCONST-111))|(1<<(KotlinParserLATEINIT-111))|(1<<(KotlinParserVARARG-111))|(1<<(KotlinParserNOINLINE-111))|(1<<(KotlinParserCROSSINLINE-111))|(1<<(KotlinParserREIFIED-111))|(1<<(KotlinParserEXPECT-111))|(1<<(KotlinParserACTUAL-111)))) != 0) || _la == KotlinParserIdentifier {
		{
			p.SetState(1594)
			p.EnumEntries()
		}

	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext()) == 1 {
		p.SetState(1600)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1597)
				p.Match(KotlinParserNL)
			}

			p.SetState(1602)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1603)
			p.Match(KotlinParserSEMICOLON)
		}
		p.SetState(1607)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1604)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1609)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext())
		}
		{
			p.SetState(1610)
			p.ClassMemberDeclarations()
		}

	}
	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1613)
			p.Match(KotlinParserNL)
		}

		p.SetState(1618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1619)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IEnumEntriesContext is an interface to support dynamic dispatch.
type IEnumEntriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumEntriesContext differentiates from other interfaces.
	IsEnumEntriesContext()
}

type EnumEntriesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntriesContext() *EnumEntriesContext {
	var p = new(EnumEntriesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntries
	return p
}

func (*EnumEntriesContext) IsEnumEntriesContext() {}

func NewEnumEntriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntriesContext {
	var p = new(EnumEntriesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntries

	return p
}

func (s *EnumEntriesContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntriesContext) AllEnumEntry() []IEnumEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumEntryContext)(nil)).Elem())
	var tst = make([]IEnumEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumEntryContext)
		}
	}

	return tst
}

func (s *EnumEntriesContext) EnumEntry(i int) IEnumEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumEntryContext)
}

func (s *EnumEntriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *EnumEntriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *EnumEntriesContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntriesContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntries(s)
	}
}

func (s *EnumEntriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntries(s)
	}
}

func (p *KotlinParser) EnumEntries() (localctx IEnumEntriesContext) {
	localctx = NewEnumEntriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KotlinParserRULE_enumEntries)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1621)
		p.EnumEntry()
	}
	p.SetState(1638)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1625)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1622)
					p.Match(KotlinParserNL)
				}

				p.SetState(1627)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1628)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1632)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1629)
					p.Match(KotlinParserNL)
				}

				p.SetState(1634)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1635)
				p.EnumEntry()
			}

		}
		p.SetState(1640)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext())
	}
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1641)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1646)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext())
	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOMMA {
		{
			p.SetState(1647)
			p.Match(KotlinParserCOMMA)
		}

	}

	return localctx
}

// IEnumEntryContext is an interface to support dynamic dispatch.
type IEnumEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumEntryContext differentiates from other interfaces.
	IsEnumEntryContext()
}

type EnumEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntryContext() *EnumEntryContext {
	var p = new(EnumEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntry
	return p
}

func (*EnumEntryContext) IsEnumEntryContext() {}

func NewEnumEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntryContext {
	var p = new(EnumEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntry

	return p
}

func (s *EnumEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntryContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *EnumEntryContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *EnumEntryContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *EnumEntryContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntry(s)
	}
}

func (s *EnumEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntry(s)
	}
}

func (p *KotlinParser) EnumEntry() (localctx IEnumEntryContext) {
	localctx = NewEnumEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KotlinParserRULE_enumEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1657)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1650)
			p.Modifiers()
		}
		p.SetState(1654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1651)
				p.Match(KotlinParserNL)
			}

			p.SetState(1656)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1659)
		p.SimpleIdentifier()
	}
	p.SetState(1667)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		p.SetState(1663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1660)
				p.Match(KotlinParserNL)
			}

			p.SetState(1665)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1666)
			p.ValueArguments()
		}

	}
	p.SetState(1676)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1669)
				p.Match(KotlinParserNL)
			}

			p.SetState(1674)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1675)
			p.ClassBody()
		}

	}

	return localctx
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_dataType
	return p
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *DataTypeContext) NullableType() INullableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *DataTypeContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *DataTypeContext) FunctionType() IFunctionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *DataTypeContext) TypeModifiers() ITypeModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (p *KotlinParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KotlinParserRULE_dataType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1679)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1678)
			p.TypeModifiers()
		}

	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1681)
			p.ParenthesizedType()
		}

	case 2:
		{
			p.SetState(1682)
			p.NullableType()
		}

	case 3:
		{
			p.SetState(1683)
			p.TypeReference()
		}

	case 4:
		{
			p.SetState(1684)
			p.FunctionType()
		}

	}

	return localctx
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeReference
	return p
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *TypeReferenceContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeReference(s)
	}
}

func (s *TypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeReference(s)
	}
}

func (p *KotlinParser) TypeReference() (localctx ITypeReferenceContext) {
	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KotlinParserRULE_typeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1687)
			p.UserType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1688)
			p.Match(KotlinParserDYNAMIC)
		}

	}

	return localctx
}

// INullableTypeContext is an interface to support dynamic dispatch.
type INullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullableTypeContext differentiates from other interfaces.
	IsNullableTypeContext()
}

type NullableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullableTypeContext() *NullableTypeContext {
	var p = new(NullableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_nullableType
	return p
}

func (*NullableTypeContext) IsNullableTypeContext() {}

func NewNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullableTypeContext {
	var p = new(NullableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_nullableType

	return p
}

func (s *NullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NullableTypeContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *NullableTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *NullableTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NullableTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NullableTypeContext) AllQuest() []IQuestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuestContext)(nil)).Elem())
	var tst = make([]IQuestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuestContext)
		}
	}

	return tst
}

func (s *NullableTypeContext) Quest(i int) IQuestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuestContext)
}

func (s *NullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNullableType(s)
	}
}

func (s *NullableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNullableType(s)
	}
}

func (p *KotlinParser) NullableType() (localctx INullableTypeContext) {
	localctx = NewNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KotlinParserRULE_nullableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1691)
			p.TypeReference()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1692)
			p.ParenthesizedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1695)
			p.Match(KotlinParserNL)
		}

		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1701)
				p.Quest()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1704)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext())
	}

	return localctx
}

// IQuestContext is an interface to support dynamic dispatch.
type IQuestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuestContext differentiates from other interfaces.
	IsQuestContext()
}

type QuestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuestContext() *QuestContext {
	var p = new(QuestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_quest
	return p
}

func (*QuestContext) IsQuestContext() {}

func NewQuestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuestContext {
	var p = new(QuestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_quest

	return p
}

func (s *QuestContext) GetParser() antlr.Parser { return s.parser }

func (s *QuestContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *QuestContext) QUEST_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_WS, 0)
}

func (s *QuestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterQuest(s)
	}
}

func (s *QuestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitQuest(s)
	}
}

func (p *KotlinParser) Quest() (localctx IQuestContext) {
	localctx = NewQuestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KotlinParserRULE_quest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1706)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserQUEST_WS || _la == KotlinParserQUEST_NO_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUserTypeContext is an interface to support dynamic dispatch.
type IUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserTypeContext differentiates from other interfaces.
	IsUserTypeContext()
}

type UserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserTypeContext() *UserTypeContext {
	var p = new(UserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_userType
	return p
}

func (*UserTypeContext) IsUserTypeContext() {}

func NewUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserTypeContext {
	var p = new(UserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_userType

	return p
}

func (s *UserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UserTypeContext) AllSimpleUserType() []ISimpleUserTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleUserTypeContext)(nil)).Elem())
	var tst = make([]ISimpleUserTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleUserTypeContext)
		}
	}

	return tst
}

func (s *UserTypeContext) SimpleUserType(i int) ISimpleUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleUserTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleUserTypeContext)
}

func (s *UserTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *UserTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *UserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUserType(s)
	}
}

func (s *UserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUserType(s)
	}
}

func (p *KotlinParser) UserType() (localctx IUserTypeContext) {
	localctx = NewUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KotlinParserRULE_userType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1708)
		p.SimpleUserType()
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1709)
					p.Match(KotlinParserNL)
				}

				p.SetState(1714)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1715)
				p.Match(KotlinParserDOT)
			}
			p.SetState(1719)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1716)
					p.Match(KotlinParserNL)
				}

				p.SetState(1721)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1722)
				p.SimpleUserType()
			}

		}
		p.SetState(1727)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleUserTypeContext is an interface to support dynamic dispatch.
type ISimpleUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleUserTypeContext differentiates from other interfaces.
	IsSimpleUserTypeContext()
}

type SimpleUserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleUserTypeContext() *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleUserType
	return p
}

func (*SimpleUserTypeContext) IsSimpleUserTypeContext() {}

func NewSimpleUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleUserType

	return p
}

func (s *SimpleUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUserTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleUserTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *SimpleUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SimpleUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SimpleUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleUserType(s)
	}
}

func (s *SimpleUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleUserType(s)
	}
}

func (p *KotlinParser) SimpleUserType() (localctx ISimpleUserTypeContext) {
	localctx = NewSimpleUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KotlinParserRULE_simpleUserType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1728)
		p.SimpleIdentifier()
	}
	p.SetState(1736)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext()) == 1 {
		p.SetState(1732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1729)
				p.Match(KotlinParserNL)
			}

			p.SetState(1734)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1735)
			p.TypeArguments()
		}

	}

	return localctx
}

// ITypeProjectionContext is an interface to support dynamic dispatch.
type ITypeProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeProjectionContext differentiates from other interfaces.
	IsTypeProjectionContext()
}

type TypeProjectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionContext() *TypeProjectionContext {
	var p = new(TypeProjectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjection
	return p
}

func (*TypeProjectionContext) IsTypeProjectionContext() {}

func NewTypeProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionContext {
	var p = new(TypeProjectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjection

	return p
}

func (s *TypeProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeProjectionContext) TypeProjectionModifiers() ITypeProjectionModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeProjectionModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifiersContext)
}

func (s *TypeProjectionContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *TypeProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjection(s)
	}
}

func (s *TypeProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjection(s)
	}
}

func (p *KotlinParser) TypeProjection() (localctx ITypeProjectionContext) {
	localctx = NewTypeProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KotlinParserRULE_typeProjection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1743)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserIN, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1739)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1738)
				p.TypeProjectionModifiers()
			}

		}
		{
			p.SetState(1741)
			p.DataType()
		}

	case KotlinParserMULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1742)
			p.Match(KotlinParserMULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeProjectionModifiersContext is an interface to support dynamic dispatch.
type ITypeProjectionModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeProjectionModifiersContext differentiates from other interfaces.
	IsTypeProjectionModifiersContext()
}

type TypeProjectionModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifiersContext() *TypeProjectionModifiersContext {
	var p = new(TypeProjectionModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers
	return p
}

func (*TypeProjectionModifiersContext) IsTypeProjectionModifiersContext() {}

func NewTypeProjectionModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifiersContext {
	var p = new(TypeProjectionModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers

	return p
}

func (s *TypeProjectionModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifiersContext) AllTypeProjectionModifier() []ITypeProjectionModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeProjectionModifierContext)(nil)).Elem())
	var tst = make([]ITypeProjectionModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeProjectionModifierContext)
		}
	}

	return tst
}

func (s *TypeProjectionModifiersContext) TypeProjectionModifier(i int) ITypeProjectionModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeProjectionModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifierContext)
}

func (s *TypeProjectionModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifiers(s)
	}
}

func (s *TypeProjectionModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifiers(s)
	}
}

func (p *KotlinParser) TypeProjectionModifiers() (localctx ITypeProjectionModifiersContext) {
	localctx = NewTypeProjectionModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KotlinParserRULE_typeProjectionModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1745)
				p.TypeProjectionModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1748)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeProjectionModifierContext is an interface to support dynamic dispatch.
type ITypeProjectionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeProjectionModifierContext differentiates from other interfaces.
	IsTypeProjectionModifierContext()
}

type TypeProjectionModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifierContext() *TypeProjectionModifierContext {
	var p = new(TypeProjectionModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier
	return p
}

func (*TypeProjectionModifierContext) IsTypeProjectionModifierContext() {}

func NewTypeProjectionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifierContext {
	var p = new(TypeProjectionModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier

	return p
}

func (s *TypeProjectionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifierContext) VarianceModifier() IVarianceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarianceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarianceModifierContext)
}

func (s *TypeProjectionModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeProjectionModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeProjectionModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeProjectionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifier(s)
	}
}

func (s *TypeProjectionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifier(s)
	}
}

func (p *KotlinParser) TypeProjectionModifier() (localctx ITypeProjectionModifierContext) {
	localctx = NewTypeProjectionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KotlinParserRULE_typeProjectionModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1758)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIN, KotlinParserOUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1750)
			p.VarianceModifier()
		}
		p.SetState(1754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1751)
				p.Match(KotlinParserNL)
			}

			p.SetState(1756)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1757)
			p.Annotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionType
	return p
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FunctionTypeParameters() IFunctionTypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParametersContext)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *FunctionTypeContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionTypeContext) ReceiverType() IReceiverTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *FunctionTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (p *KotlinParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KotlinParserRULE_functionType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1760)
			p.ReceiverType()
		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1761)
				p.Match(KotlinParserNL)
			}

			p.SetState(1766)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1767)
			p.Match(KotlinParserDOT)
		}
		p.SetState(1771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1768)
				p.Match(KotlinParserNL)
			}

			p.SetState(1773)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1776)
		p.FunctionTypeParameters()
	}
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1777)
			p.Match(KotlinParserNL)
		}

		p.SetState(1782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1783)
		p.Match(KotlinParserARROW)
	}
	p.SetState(1787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1784)
			p.Match(KotlinParserNL)
		}

		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1790)
		p.DataType()
	}

	return localctx
}

// IFunctionTypeParametersContext is an interface to support dynamic dispatch.
type IFunctionTypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeParametersContext differentiates from other interfaces.
	IsFunctionTypeParametersContext()
}

type FunctionTypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParametersContext() *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionTypeParameters
	return p
}

func (*FunctionTypeParametersContext) IsFunctionTypeParametersContext() {}

func NewFunctionTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionTypeParameters

	return p
}

func (s *FunctionTypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionTypeParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionTypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeParametersContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionTypeParametersContext) AllDataType() []IDataTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeContext)(nil)).Elem())
	var tst = make([]IDataTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeContext)
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) DataType(i int) IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionTypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionTypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionTypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionTypeParameters(s)
	}
}

func (s *FunctionTypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionTypeParameters(s)
	}
}

func (p *KotlinParser) FunctionTypeParameters() (localctx IFunctionTypeParametersContext) {
	localctx = NewFunctionTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KotlinParserRULE_functionTypeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1792)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1796)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1793)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1798)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext())
	}
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1799)
			p.Parameter()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1800)
			p.DataType()
		}

	}
	p.SetState(1822)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 267, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1806)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1803)
					p.Match(KotlinParserNL)
				}

				p.SetState(1808)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1809)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1813)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1810)
					p.Match(KotlinParserNL)
				}

				p.SetState(1815)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1818)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1816)
					p.Parameter()
				}

			case 2:
				{
					p.SetState(1817)
					p.DataType()
				}

			}

		}
		p.SetState(1824)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 267, p.GetParserRuleContext())
	}
	p.SetState(1832)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 269, p.GetParserRuleContext()) == 1 {
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1825)
				p.Match(KotlinParserNL)
			}

			p.SetState(1830)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1831)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1834)
			p.Match(KotlinParserNL)
		}

		p.SetState(1839)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1840)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IParenthesizedTypeContext is an interface to support dynamic dispatch.
type IParenthesizedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedTypeContext differentiates from other interfaces.
	IsParenthesizedTypeContext()
}

type ParenthesizedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedTypeContext() *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedType
	return p
}

func (*ParenthesizedTypeContext) IsParenthesizedTypeContext() {}

func NewParenthesizedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedType

	return p
}

func (s *ParenthesizedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedTypeContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ParenthesizedTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedType(s)
	}
}

func (s *ParenthesizedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedType(s)
	}
}

func (p *KotlinParser) ParenthesizedType() (localctx IParenthesizedTypeContext) {
	localctx = NewParenthesizedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KotlinParserRULE_parenthesizedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1842)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1843)
			p.Match(KotlinParserNL)
		}

		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1849)
		p.DataType()
	}
	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1850)
			p.Match(KotlinParserNL)
		}

		p.SetState(1855)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1856)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IReceiverTypeContext is an interface to support dynamic dispatch.
type IReceiverTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiverTypeContext differentiates from other interfaces.
	IsReceiverTypeContext()
}

type ReceiverTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverTypeContext() *ReceiverTypeContext {
	var p = new(ReceiverTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_receiverType
	return p
}

func (*ReceiverTypeContext) IsReceiverTypeContext() {}

func NewReceiverTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverTypeContext {
	var p = new(ReceiverTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_receiverType

	return p
}

func (s *ReceiverTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *ReceiverTypeContext) NullableType() INullableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *ReceiverTypeContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ReceiverTypeContext) TypeModifiers() ITypeModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *ReceiverTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterReceiverType(s)
	}
}

func (s *ReceiverTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitReceiverType(s)
	}
}

func (p *KotlinParser) ReceiverType() (localctx IReceiverTypeContext) {
	localctx = NewReceiverTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, KotlinParserRULE_receiverType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1859)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1858)
			p.TypeModifiers()
		}

	}
	p.SetState(1864)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1861)
			p.ParenthesizedType()
		}

	case 2:
		{
			p.SetState(1862)
			p.NullableType()
		}

	case 3:
		{
			p.SetState(1863)
			p.TypeReference()
		}

	}

	return localctx
}

// IParenthesizedUserTypeContext is an interface to support dynamic dispatch.
type IParenthesizedUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedUserTypeContext differentiates from other interfaces.
	IsParenthesizedUserTypeContext()
}

type ParenthesizedUserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedUserTypeContext() *ParenthesizedUserTypeContext {
	var p = new(ParenthesizedUserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType
	return p
}

func (*ParenthesizedUserTypeContext) IsParenthesizedUserTypeContext() {}

func NewParenthesizedUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedUserTypeContext {
	var p = new(ParenthesizedUserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType

	return p
}

func (s *ParenthesizedUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedUserTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedUserTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedUserTypeContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ParenthesizedUserTypeContext) ParenthesizedUserType() IParenthesizedUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedUserTypeContext)
}

func (s *ParenthesizedUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedUserType(s)
	}
}

func (s *ParenthesizedUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedUserType(s)
	}
}

func (p *KotlinParser) ParenthesizedUserType() (localctx IParenthesizedUserTypeContext) {
	localctx = NewParenthesizedUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, KotlinParserRULE_parenthesizedUserType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1866)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1867)
			p.Match(KotlinParserNL)
		}

		p.SetState(1872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1875)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1873)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1874)
			p.ParenthesizedUserType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1877)
			p.Match(KotlinParserNL)
		}

		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1883)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSemis() []ISemisContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISemisContext)(nil)).Elem())
	var tst = make([]ISemisContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISemisContext)
		}
	}

	return tst
}

func (s *StatementsContext) Semis(i int) ISemisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemisContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *KotlinParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, KotlinParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL_WS)|(1<<KotlinParserEXCL_NO_WS))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(KotlinParserCOLONCOLON-37))|(1<<(KotlinParserAT_NO_WS-37))|(1<<(KotlinParserAT_PRE_WS-37))|(1<<(KotlinParserRETURN_AT-37))|(1<<(KotlinParserCONTINUE_AT-37))|(1<<(KotlinParserBREAK_AT-37))|(1<<(KotlinParserTHIS_AT-37))|(1<<(KotlinParserSUPER_AT-37))|(1<<(KotlinParserFILE-37))|(1<<(KotlinParserFIELD-37))|(1<<(KotlinParserPROPERTY-37))|(1<<(KotlinParserGET-37))|(1<<(KotlinParserSET-37))|(1<<(KotlinParserRECEIVER-37))|(1<<(KotlinParserPARAM-37))|(1<<(KotlinParserSETPARAM-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KotlinParserDELEGATE-69))|(1<<(KotlinParserIMPORT-69))|(1<<(KotlinParserCLASS-69))|(1<<(KotlinParserINTERFACE-69))|(1<<(KotlinParserFUN-69))|(1<<(KotlinParserOBJECT-69))|(1<<(KotlinParserVAL-69))|(1<<(KotlinParserVAR-69))|(1<<(KotlinParserTYPE_ALIAS-69))|(1<<(KotlinParserCONSTRUCTOR-69))|(1<<(KotlinParserBY-69))|(1<<(KotlinParserCOMPANION-69))|(1<<(KotlinParserINIT-69))|(1<<(KotlinParserTHIS-69))|(1<<(KotlinParserSUPER-69))|(1<<(KotlinParserWHERE-69))|(1<<(KotlinParserIF-69))|(1<<(KotlinParserWHEN-69))|(1<<(KotlinParserTRY-69))|(1<<(KotlinParserCATCH-69))|(1<<(KotlinParserFINALLY-69))|(1<<(KotlinParserFOR-69))|(1<<(KotlinParserDO-69))|(1<<(KotlinParserWHILE-69))|(1<<(KotlinParserTHROW-69))|(1<<(KotlinParserRETURN-69))|(1<<(KotlinParserCONTINUE-69))|(1<<(KotlinParserBREAK-69)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105))|(1<<(KotlinParserRealLiteral-105)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(KotlinParserIntegerLiteral-138))|(1<<(KotlinParserHexLiteral-138))|(1<<(KotlinParserBinLiteral-138))|(1<<(KotlinParserUnsignedLiteral-138))|(1<<(KotlinParserLongLiteral-138))|(1<<(KotlinParserBooleanLiteral-138))|(1<<(KotlinParserNullLiteral-138))|(1<<(KotlinParserCharacterLiteral-138))|(1<<(KotlinParserIdentifier-138))|(1<<(KotlinParserQUOTE_OPEN-138))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-138)))) != 0) {
		{
			p.SetState(1885)
			p.Statement()
		}
		p.SetState(1891)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 278, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1886)
					p.Semis()
				}
				{
					p.SetState(1887)
					p.Statement()
				}

			}
			p.SetState(1893)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 278, p.GetParserRuleContext())
		}

	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1896)
			p.Semis()
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) Assignment() IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) AllLabel() []ILabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabelContext)(nil)).Elem())
	var tst = make([]ILabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabelContext)
		}
	}

	return tst
}

func (s *StatementContext) Label(i int) ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *StatementContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *KotlinParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, KotlinParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1901)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
				{
					p.SetState(1899)
					p.Label()
				}

			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(1900)
					p.Annotation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext())
	}
	p.SetState(1910)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1906)
			p.Declaration()
		}

	case 2:
		{
			p.SetState(1907)
			p.Assignment()
		}

	case 3:
		{
			p.SetState(1908)
			p.LoopStatement()
		}

	case 4:
		{
			p.SetState(1909)
			p.Expression()
		}

	}

	return localctx
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_label
	return p
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *LabelContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *LabelContext) AT_POST_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_POST_WS, 0)
}

func (s *LabelContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LabelContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *KotlinParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, KotlinParserRULE_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1912)
		p.SimpleIdentifier()
	}
	{
		p.SetState(1913)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_POST_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1914)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1919)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext())
	}

	return localctx
}

// IControlStructureBodyContext is an interface to support dynamic dispatch.
type IControlStructureBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControlStructureBodyContext differentiates from other interfaces.
	IsControlStructureBodyContext()
}

type ControlStructureBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlStructureBodyContext() *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_controlStructureBody
	return p
}

func (*ControlStructureBodyContext) IsControlStructureBodyContext() {}

func NewControlStructureBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_controlStructureBody

	return p
}

func (s *ControlStructureBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ControlStructureBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ControlStructureBodyContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ControlStructureBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ControlStructureBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ControlStructureBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterControlStructureBody(s)
	}
}

func (s *ControlStructureBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitControlStructureBody(s)
	}
}

func (p *KotlinParser) ControlStructureBody() (localctx IControlStructureBodyContext) {
	localctx = NewControlStructureBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, KotlinParserRULE_controlStructureBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1922)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 285, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1920)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1921)
			p.Statement()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *BlockContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *BlockContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *BlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *BlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *KotlinParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, KotlinParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1924)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(1928)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 286, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1925)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1930)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 286, p.GetParserRuleContext())
	}
	{
		p.SetState(1931)
		p.Statements()
	}
	p.SetState(1935)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1932)
			p.Match(KotlinParserNL)
		}

		p.SetState(1937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1938)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_loopStatement
	return p
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) ForStatement() IForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *LoopStatementContext) WhileStatement() IWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *LoopStatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (p *KotlinParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, KotlinParserRULE_loopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1943)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1940)
			p.ForStatement()
		}

	case KotlinParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1941)
			p.WhileStatement()
		}

	case KotlinParserDO:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1942)
			p.DoWhileStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserFOR, 0)
}

func (s *ForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ForStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForStatementContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *ForStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ForStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ForStatementContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ForStatementContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ForStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *KotlinParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, KotlinParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1945)
		p.Match(KotlinParserFOR)
	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1946)
			p.Match(KotlinParserNL)
		}

		p.SetState(1951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1952)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1956)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1953)
				p.Annotation()
			}

		}
		p.SetState(1958)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1959)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1960)
			p.MultiVariableDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1963)
		p.Match(KotlinParserIN)
	}
	{
		p.SetState(1964)
		p.Expression()
	}
	{
		p.SetState(1965)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(1969)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1966)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1971)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())
	}
	p.SetState(1973)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1972)
			p.ControlStructureBody()
		}

	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhileStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhileStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *WhileStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhileStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *KotlinParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, KotlinParserRULE_whileStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		p.Match(KotlinParserWHILE)
	}
	p.SetState(1979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1976)
			p.Match(KotlinParserNL)
		}

		p.SetState(1981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1982)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(1983)
		p.Expression()
	}
	{
		p.SetState(1984)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(1988)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1985)
			p.Match(KotlinParserNL)
		}

		p.SetState(1990)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1993)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		{
			p.SetState(1991)
			p.ControlStructureBody()
		}

	case KotlinParserSEMICOLON:
		{
			p.SetState(1992)
			p.Match(KotlinParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(KotlinParserDO, 0)
}

func (s *DoWhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *DoWhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *DoWhileStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DoWhileStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DoWhileStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *KotlinParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, KotlinParserRULE_doWhileStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1995)
		p.Match(KotlinParserDO)
	}
	p.SetState(1999)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 297, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1996)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2001)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 297, p.GetParserRuleContext())
	}
	p.SetState(2003)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2002)
			p.ControlStructureBody()
		}

	}
	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2005)
			p.Match(KotlinParserNL)
		}

		p.SetState(2010)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2011)
		p.Match(KotlinParserWHILE)
	}
	p.SetState(2015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2012)
			p.Match(KotlinParserNL)
		}

		p.SetState(2017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2018)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(2019)
		p.Expression()
	}
	{
		p.SetState(2020)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) DirectlyAssignableExpression() IDirectlyAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectlyAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectlyAssignableExpressionContext)
}

func (s *AssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *AssignmentContext) AssignableExpression() IAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *AssignmentContext) AssignmentAndOperator() IAssignmentAndOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentAndOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentAndOperatorContext)
}

func (s *AssignmentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AssignmentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *KotlinParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, KotlinParserRULE_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2028)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 301, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2022)
			p.DirectlyAssignableExpression()
		}
		{
			p.SetState(2023)
			p.Match(KotlinParserASSIGNMENT)
		}

	case 2:
		{
			p.SetState(2025)
			p.AssignableExpression()
		}
		{
			p.SetState(2026)
			p.AssignmentAndOperator()
		}

	}
	p.SetState(2033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2030)
			p.Match(KotlinParserNL)
		}

		p.SetState(2035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2036)
		p.Expression()
	}

	return localctx
}

// ISemiContext is an interface to support dynamic dispatch.
type ISemiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSemiContext differentiates from other interfaces.
	IsSemiContext()
}

type SemiContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemiContext() *SemiContext {
	var p = new(SemiContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_semi
	return p
}

func (*SemiContext) IsSemiContext() {}

func NewSemiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemiContext {
	var p = new(SemiContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semi

	return p
}

func (s *SemiContext) GetParser() antlr.Parser { return s.parser }

func (s *SemiContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *SemiContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemiContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemiContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *SemiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemi(s)
	}
}

func (s *SemiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemi(s)
	}
}

func (p *KotlinParser) Semi() (localctx ISemiContext) {
	localctx = NewSemiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, KotlinParserRULE_semi)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2046)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserSEMICOLON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2038)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2039)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2044)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext())
		}

	case KotlinParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2045)
			p.Match(KotlinParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISemisContext is an interface to support dynamic dispatch.
type ISemisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSemisContext differentiates from other interfaces.
	IsSemisContext()
}

type SemisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemisContext() *SemisContext {
	var p = new(SemisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_semis
	return p
}

func (*SemisContext) IsSemisContext() {}

func NewSemisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemisContext {
	var p = new(SemisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semis

	return p
}

func (s *SemisContext) GetParser() antlr.Parser { return s.parser }

func (s *SemisContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSEMICOLON)
}

func (s *SemisContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, i)
}

func (s *SemisContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemisContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemisContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *SemisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemis(s)
	}
}

func (s *SemisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemis(s)
	}
}

func (p *KotlinParser) Semis() (localctx ISemisContext) {
	localctx = NewSemisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, KotlinParserRULE_semis)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2054)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserSEMICOLON:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2049)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2048)
					_la = p.GetTokenStream().LA(1)

					if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(2051)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext())
		}

	case KotlinParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2053)
			p.Match(KotlinParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Disjunction() IDisjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *KotlinParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, KotlinParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.Disjunction()
	}

	return localctx
}

// IDisjunctionContext is an interface to support dynamic dispatch.
type IDisjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisjunctionContext differentiates from other interfaces.
	IsDisjunctionContext()
}

type DisjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionContext() *DisjunctionContext {
	var p = new(DisjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_disjunction
	return p
}

func (*DisjunctionContext) IsDisjunctionContext() {}

func NewDisjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionContext {
	var p = new(DisjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_disjunction

	return p
}

func (s *DisjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionContext) AllConjunction() []IConjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConjunctionContext)(nil)).Elem())
	var tst = make([]IConjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConjunctionContext)
		}
	}

	return tst
}

func (s *DisjunctionContext) Conjunction(i int) IConjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *DisjunctionContext) AllDISJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDISJ)
}

func (s *DisjunctionContext) DISJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDISJ, i)
}

func (s *DisjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DisjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDisjunction(s)
	}
}

func (s *DisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDisjunction(s)
	}
}

func (p *KotlinParser) Disjunction() (localctx IDisjunctionContext) {
	localctx = NewDisjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, KotlinParserRULE_disjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2058)
		p.Conjunction()
	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 309, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2062)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2059)
					p.Match(KotlinParserNL)
				}

				p.SetState(2064)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2065)
				p.Match(KotlinParserDISJ)
			}
			p.SetState(2069)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2066)
					p.Match(KotlinParserNL)
				}

				p.SetState(2071)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2072)
				p.Conjunction()
			}

		}
		p.SetState(2077)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 309, p.GetParserRuleContext())
	}

	return localctx
}

// IConjunctionContext is an interface to support dynamic dispatch.
type IConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctionContext differentiates from other interfaces.
	IsConjunctionContext()
}

type ConjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionContext() *ConjunctionContext {
	var p = new(ConjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_conjunction
	return p
}

func (*ConjunctionContext) IsConjunctionContext() {}

func NewConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionContext {
	var p = new(ConjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_conjunction

	return p
}

func (s *ConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionContext) AllEquality() []IEqualityContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEqualityContext)(nil)).Elem())
	var tst = make([]IEqualityContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEqualityContext)
		}
	}

	return tst
}

func (s *ConjunctionContext) Equality(i int) IEqualityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEqualityContext)
}

func (s *ConjunctionContext) AllCONJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCONJ)
}

func (s *ConjunctionContext) CONJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCONJ, i)
}

func (s *ConjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConjunction(s)
	}
}

func (s *ConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConjunction(s)
	}
}

func (p *KotlinParser) Conjunction() (localctx IConjunctionContext) {
	localctx = NewConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, KotlinParserRULE_conjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2078)
		p.Equality()
	}
	p.SetState(2095)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2082)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2079)
					p.Match(KotlinParserNL)
				}

				p.SetState(2084)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2085)
				p.Match(KotlinParserCONJ)
			}
			p.SetState(2089)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2086)
					p.Match(KotlinParserNL)
				}

				p.SetState(2091)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2092)
				p.Equality()
			}

		}
		p.SetState(2097)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext())
	}

	return localctx
}

// IEqualityContext is an interface to support dynamic dispatch.
type IEqualityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityContext differentiates from other interfaces.
	IsEqualityContext()
}

type EqualityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityContext() *EqualityContext {
	var p = new(EqualityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_equality
	return p
}

func (*EqualityContext) IsEqualityContext() {}

func NewEqualityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityContext {
	var p = new(EqualityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equality

	return p
}

func (s *EqualityContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityContext) AllComparison() []IComparisonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComparisonContext)(nil)).Elem())
	var tst = make([]IComparisonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComparisonContext)
		}
	}

	return tst
}

func (s *EqualityContext) Comparison(i int) IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *EqualityContext) AllEqualityOperator() []IEqualityOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEqualityOperatorContext)(nil)).Elem())
	var tst = make([]IEqualityOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEqualityOperatorContext)
		}
	}

	return tst
}

func (s *EqualityContext) EqualityOperator(i int) IEqualityOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEqualityOperatorContext)
}

func (s *EqualityContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EqualityContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EqualityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEquality(s)
	}
}

func (s *EqualityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEquality(s)
	}
}

func (p *KotlinParser) Equality() (localctx IEqualityContext) {
	localctx = NewEqualityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, KotlinParserRULE_equality)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2098)
		p.Comparison()
	}
	p.SetState(2110)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2099)
				p.EqualityOperator()
			}
			p.SetState(2103)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2100)
					p.Match(KotlinParserNL)
				}

				p.SetState(2105)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2106)
				p.Comparison()
			}

		}
		p.SetState(2112)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext())
	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllGenericCallLikeComparison() []IGenericCallLikeComparisonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenericCallLikeComparisonContext)(nil)).Elem())
	var tst = make([]IGenericCallLikeComparisonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenericCallLikeComparisonContext)
		}
	}

	return tst
}

func (s *ComparisonContext) GenericCallLikeComparison(i int) IGenericCallLikeComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericCallLikeComparisonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenericCallLikeComparisonContext)
}

func (s *ComparisonContext) AllComparisonOperator() []IComparisonOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem())
	var tst = make([]IComparisonOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComparisonOperatorContext)
		}
	}

	return tst
}

func (s *ComparisonContext) ComparisonOperator(i int) IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ComparisonContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *KotlinParser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, KotlinParserRULE_comparison)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2113)
		p.GenericCallLikeComparison()
	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2114)
				p.ComparisonOperator()
			}
			p.SetState(2118)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2115)
					p.Match(KotlinParserNL)
				}

				p.SetState(2120)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2121)
				p.GenericCallLikeComparison()
			}

		}
		p.SetState(2127)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext())
	}

	return localctx
}

// IGenericCallLikeComparisonContext is an interface to support dynamic dispatch.
type IGenericCallLikeComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericCallLikeComparisonContext differentiates from other interfaces.
	IsGenericCallLikeComparisonContext()
}

type GenericCallLikeComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericCallLikeComparisonContext() *GenericCallLikeComparisonContext {
	var p = new(GenericCallLikeComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison
	return p
}

func (*GenericCallLikeComparisonContext) IsGenericCallLikeComparisonContext() {}

func NewGenericCallLikeComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericCallLikeComparisonContext {
	var p = new(GenericCallLikeComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison

	return p
}

func (s *GenericCallLikeComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericCallLikeComparisonContext) InfixOperation() IInfixOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfixOperationContext)
}

func (s *GenericCallLikeComparisonContext) AllCallSuffix() []ICallSuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallSuffixContext)(nil)).Elem())
	var tst = make([]ICallSuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallSuffixContext)
		}
	}

	return tst
}

func (s *GenericCallLikeComparisonContext) CallSuffix(i int) ICallSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallSuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *GenericCallLikeComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericCallLikeComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericCallLikeComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGenericCallLikeComparison(s)
	}
}

func (s *GenericCallLikeComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGenericCallLikeComparison(s)
	}
}

func (p *KotlinParser) GenericCallLikeComparison() (localctx IGenericCallLikeComparisonContext) {
	localctx = NewGenericCallLikeComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, KotlinParserRULE_genericCallLikeComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2128)
		p.InfixOperation()
	}
	p.SetState(2132)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 317, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2129)
				p.CallSuffix()
			}

		}
		p.SetState(2134)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 317, p.GetParserRuleContext())
	}

	return localctx
}

// IInfixOperationContext is an interface to support dynamic dispatch.
type IInfixOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfixOperationContext differentiates from other interfaces.
	IsInfixOperationContext()
}

type InfixOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixOperationContext() *InfixOperationContext {
	var p = new(InfixOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_infixOperation
	return p
}

func (*InfixOperationContext) IsInfixOperationContext() {}

func NewInfixOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixOperationContext {
	var p = new(InfixOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixOperation

	return p
}

func (s *InfixOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixOperationContext) AllElvisExpression() []IElvisExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElvisExpressionContext)(nil)).Elem())
	var tst = make([]IElvisExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElvisExpressionContext)
		}
	}

	return tst
}

func (s *InfixOperationContext) ElvisExpression(i int) IElvisExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElvisExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElvisExpressionContext)
}

func (s *InfixOperationContext) AllInOperator() []IInOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInOperatorContext)(nil)).Elem())
	var tst = make([]IInOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInOperatorContext)
		}
	}

	return tst
}

func (s *InfixOperationContext) InOperator(i int) IInOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *InfixOperationContext) AllIsOperator() []IIsOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIsOperatorContext)(nil)).Elem())
	var tst = make([]IIsOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIsOperatorContext)
		}
	}

	return tst
}

func (s *InfixOperationContext) IsOperator(i int) IIsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIsOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *InfixOperationContext) AllDataType() []IDataTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeContext)(nil)).Elem())
	var tst = make([]IDataTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeContext)
		}
	}

	return tst
}

func (s *InfixOperationContext) DataType(i int) IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *InfixOperationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixOperationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixOperation(s)
	}
}

func (s *InfixOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixOperation(s)
	}
}

func (p *KotlinParser) InfixOperation() (localctx IInfixOperationContext) {
	localctx = NewInfixOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, KotlinParserRULE_infixOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2135)
		p.ElvisExpression()
	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2154)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserIN, KotlinParserNOT_IN:
				{
					p.SetState(2136)
					p.InOperator()
				}
				p.SetState(2140)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2137)
						p.Match(KotlinParserNL)
					}

					p.SetState(2142)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2143)
					p.ElvisExpression()
				}

			case KotlinParserIS, KotlinParserNOT_IS:
				{
					p.SetState(2145)
					p.IsOperator()
				}
				p.SetState(2149)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2146)
						p.Match(KotlinParserNL)
					}

					p.SetState(2151)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2152)
					p.DataType()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(2158)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())
	}

	return localctx
}

// IElvisExpressionContext is an interface to support dynamic dispatch.
type IElvisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElvisExpressionContext differentiates from other interfaces.
	IsElvisExpressionContext()
}

type ElvisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisExpressionContext() *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_elvisExpression
	return p
}

func (*ElvisExpressionContext) IsElvisExpressionContext() {}

func NewElvisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvisExpression

	return p
}

func (s *ElvisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisExpressionContext) AllInfixFunctionCall() []IInfixFunctionCallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInfixFunctionCallContext)(nil)).Elem())
	var tst = make([]IInfixFunctionCallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInfixFunctionCallContext)
		}
	}

	return tst
}

func (s *ElvisExpressionContext) InfixFunctionCall(i int) IInfixFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixFunctionCallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInfixFunctionCallContext)
}

func (s *ElvisExpressionContext) AllElvis() []IElvisContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElvisContext)(nil)).Elem())
	var tst = make([]IElvisContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElvisContext)
		}
	}

	return tst
}

func (s *ElvisExpressionContext) Elvis(i int) IElvisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElvisContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElvisContext)
}

func (s *ElvisExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ElvisExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ElvisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvisExpression(s)
	}
}

func (s *ElvisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvisExpression(s)
	}
}

func (p *KotlinParser) ElvisExpression() (localctx IElvisExpressionContext) {
	localctx = NewElvisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, KotlinParserRULE_elvisExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2159)
		p.InfixFunctionCall()
	}
	p.SetState(2177)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 324, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2163)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2160)
					p.Match(KotlinParserNL)
				}

				p.SetState(2165)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2166)
				p.Elvis()
			}
			p.SetState(2170)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2167)
					p.Match(KotlinParserNL)
				}

				p.SetState(2172)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2173)
				p.InfixFunctionCall()
			}

		}
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 324, p.GetParserRuleContext())
	}

	return localctx
}

// IElvisContext is an interface to support dynamic dispatch.
type IElvisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElvisContext differentiates from other interfaces.
	IsElvisContext()
}

type ElvisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisContext() *ElvisContext {
	var p = new(ElvisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_elvis
	return p
}

func (*ElvisContext) IsElvisContext() {}

func NewElvisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisContext {
	var p = new(ElvisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvis

	return p
}

func (s *ElvisContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *ElvisContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ElvisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvis(s)
	}
}

func (s *ElvisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvis(s)
	}
}

func (p *KotlinParser) Elvis() (localctx IElvisContext) {
	localctx = NewElvisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, KotlinParserRULE_elvis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.Match(KotlinParserQUEST_NO_WS)
	}
	{
		p.SetState(2181)
		p.Match(KotlinParserCOLON)
	}

	return localctx
}

// IInfixFunctionCallContext is an interface to support dynamic dispatch.
type IInfixFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfixFunctionCallContext differentiates from other interfaces.
	IsInfixFunctionCallContext()
}

type InfixFunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixFunctionCallContext() *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_infixFunctionCall
	return p
}

func (*InfixFunctionCallContext) IsInfixFunctionCallContext() {}

func NewInfixFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixFunctionCall

	return p
}

func (s *InfixFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixFunctionCallContext) AllRangeExpression() []IRangeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRangeExpressionContext)(nil)).Elem())
	var tst = make([]IRangeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRangeExpressionContext)
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) RangeExpression(i int) IRangeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *InfixFunctionCallContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem())
	var tst = make([]ISimpleIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleIdentifierContext)
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *InfixFunctionCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixFunctionCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixFunctionCall(s)
	}
}

func (s *InfixFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixFunctionCall(s)
	}
}

func (p *KotlinParser) InfixFunctionCall() (localctx IInfixFunctionCallContext) {
	localctx = NewInfixFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, KotlinParserRULE_infixFunctionCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2183)
		p.RangeExpression()
	}
	p.SetState(2195)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2184)
				p.SimpleIdentifier()
			}
			p.SetState(2188)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2185)
					p.Match(KotlinParserNL)
				}

				p.SetState(2190)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2191)
				p.RangeExpression()
			}

		}
		p.SetState(2197)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())
	}

	return localctx
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeExpression
	return p
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem())
	var tst = make([]IAdditiveExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveExpressionContext)
		}
	}

	return tst
}

func (s *RangeExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *RangeExpressionContext) AllRANGE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserRANGE)
}

func (s *RangeExpressionContext) RANGE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGE, i)
}

func (s *RangeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (p *KotlinParser) RangeExpression() (localctx IRangeExpressionContext) {
	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, KotlinParserRULE_rangeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2198)
		p.AdditiveExpression()
	}
	p.SetState(2209)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2199)
				p.Match(KotlinParserRANGE)
			}
			p.SetState(2203)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2200)
					p.Match(KotlinParserNL)
				}

				p.SetState(2205)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2206)
				p.AdditiveExpression()
			}

		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext())
	}

	return localctx
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveExpression
	return p
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem())
	var tst = make([]IMultiplicativeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllAdditiveOperator() []IAdditiveOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem())
	var tst = make([]IAdditiveOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveOperatorContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) AdditiveOperator(i int) IAdditiveOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveOperatorContext)
}

func (s *AdditiveExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AdditiveExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *KotlinParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, KotlinParserRULE_additiveExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2212)
		p.MultiplicativeExpression()
	}
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2213)
				p.AdditiveOperator()
			}
			p.SetState(2217)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2214)
					p.Match(KotlinParserNL)
				}

				p.SetState(2219)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2220)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(2226)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression
	return p
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllAsExpression() []IAsExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAsExpressionContext)(nil)).Elem())
	var tst = make([]IAsExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAsExpressionContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) AsExpression(i int) IAsExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAsExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllMultiplicativeOperator() []IMultiplicativeOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeOperatorContext)(nil)).Elem())
	var tst = make([]IMultiplicativeOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeOperatorContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) MultiplicativeOperator(i int) IMultiplicativeOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeOperatorContext)
}

func (s *MultiplicativeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiplicativeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *KotlinParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, KotlinParserRULE_multiplicativeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2227)
		p.AsExpression()
	}
	p.SetState(2239)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2228)
				p.MultiplicativeOperator()
			}
			p.SetState(2232)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2229)
					p.Match(KotlinParserNL)
				}

				p.SetState(2234)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2235)
				p.AsExpression()
			}

		}
		p.SetState(2241)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
	}

	return localctx
}

// IAsExpressionContext is an interface to support dynamic dispatch.
type IAsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsExpressionContext differentiates from other interfaces.
	IsAsExpressionContext()
}

type AsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsExpressionContext() *AsExpressionContext {
	var p = new(AsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_asExpression
	return p
}

func (*AsExpressionContext) IsAsExpressionContext() {}

func NewAsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsExpressionContext {
	var p = new(AsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_asExpression

	return p
}

func (s *AsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsExpressionContext) PrefixUnaryExpression() IPrefixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *AsExpressionContext) AllAsOperator() []IAsOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAsOperatorContext)(nil)).Elem())
	var tst = make([]IAsOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAsOperatorContext)
		}
	}

	return tst
}

func (s *AsExpressionContext) AsOperator(i int) IAsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAsOperatorContext)
}

func (s *AsExpressionContext) AllDataType() []IDataTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeContext)(nil)).Elem())
	var tst = make([]IDataTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeContext)
		}
	}

	return tst
}

func (s *AsExpressionContext) DataType(i int) IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AsExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AsExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAsExpression(s)
	}
}

func (s *AsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAsExpression(s)
	}
}

func (p *KotlinParser) AsExpression() (localctx IAsExpressionContext) {
	localctx = NewAsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, KotlinParserRULE_asExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2242)
		p.PrefixUnaryExpression()
	}
	p.SetState(2260)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 335, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2246)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2243)
					p.Match(KotlinParserNL)
				}

				p.SetState(2248)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2249)
				p.AsOperator()
			}
			p.SetState(2253)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2250)
					p.Match(KotlinParserNL)
				}

				p.SetState(2255)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2256)
				p.DataType()
			}

		}
		p.SetState(2262)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 335, p.GetParserRuleContext())
	}

	return localctx
}

// IPrefixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPrefixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixUnaryExpressionContext differentiates from other interfaces.
	IsPrefixUnaryExpressionContext()
}

type PrefixUnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryExpressionContext() *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression
	return p
}

func (*PrefixUnaryExpressionContext) IsPrefixUnaryExpressionContext() {}

func NewPrefixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression

	return p
}

func (s *PrefixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *PrefixUnaryExpressionContext) AllUnaryPrefix() []IUnaryPrefixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnaryPrefixContext)(nil)).Elem())
	var tst = make([]IUnaryPrefixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnaryPrefixContext)
		}
	}

	return tst
}

func (s *PrefixUnaryExpressionContext) UnaryPrefix(i int) IUnaryPrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryPrefixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnaryPrefixContext)
}

func (s *PrefixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryExpression(s)
	}
}

func (s *PrefixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryExpression(s)
	}
}

func (p *KotlinParser) PrefixUnaryExpression() (localctx IPrefixUnaryExpressionContext) {
	localctx = NewPrefixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, KotlinParserRULE_prefixUnaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2266)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2263)
				p.UnaryPrefix()
			}

		}
		p.SetState(2268)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext())
	}
	{
		p.SetState(2269)
		p.PostfixUnaryExpression()
	}

	return localctx
}

// IUnaryPrefixContext is an interface to support dynamic dispatch.
type IUnaryPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryPrefixContext differentiates from other interfaces.
	IsUnaryPrefixContext()
}

type UnaryPrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryPrefixContext() *UnaryPrefixContext {
	var p = new(UnaryPrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_unaryPrefix
	return p
}

func (*UnaryPrefixContext) IsUnaryPrefixContext() {}

func NewUnaryPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryPrefixContext {
	var p = new(UnaryPrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unaryPrefix

	return p
}

func (s *UnaryPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryPrefixContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnaryPrefixContext) Label() ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *UnaryPrefixContext) PrefixUnaryOperator() IPrefixUnaryOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixUnaryOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryOperatorContext)
}

func (s *UnaryPrefixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UnaryPrefixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UnaryPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnaryPrefix(s)
	}
}

func (s *UnaryPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnaryPrefix(s)
	}
}

func (p *KotlinParser) UnaryPrefix() (localctx IUnaryPrefixContext) {
	localctx = NewUnaryPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, KotlinParserRULE_unaryPrefix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2280)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2271)
			p.Annotation()
		}

	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2272)
			p.Label()
		}

	case KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2273)
			p.PrefixUnaryOperator()
		}
		p.SetState(2277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2274)
				p.Match(KotlinParserNL)
			}

			p.SetState(2279)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPostfixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixUnaryExpressionContext differentiates from other interfaces.
	IsPostfixUnaryExpressionContext()
}

type PostfixUnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryExpressionContext() *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression
	return p
}

func (*PostfixUnaryExpressionContext) IsPostfixUnaryExpressionContext() {}

func NewPostfixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression

	return p
}

func (s *PostfixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixUnaryExpressionContext) AllPostfixUnarySuffix() []IPostfixUnarySuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostfixUnarySuffixContext)(nil)).Elem())
	var tst = make([]IPostfixUnarySuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostfixUnarySuffixContext)
		}
	}

	return tst
}

func (s *PostfixUnaryExpressionContext) PostfixUnarySuffix(i int) IPostfixUnarySuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnarySuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnarySuffixContext)
}

func (s *PostfixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryExpression(s)
	}
}

func (s *PostfixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryExpression(s)
	}
}

func (p *KotlinParser) PostfixUnaryExpression() (localctx IPostfixUnaryExpressionContext) {
	localctx = NewPostfixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, KotlinParserRULE_postfixUnaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2282)
		p.PrimaryExpression()
	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2283)
				p.PostfixUnarySuffix()
			}

		}
		p.SetState(2288)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext())
	}

	return localctx
}

// IPostfixUnarySuffixContext is an interface to support dynamic dispatch.
type IPostfixUnarySuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixUnarySuffixContext differentiates from other interfaces.
	IsPostfixUnarySuffixContext()
}

type PostfixUnarySuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnarySuffixContext() *PostfixUnarySuffixContext {
	var p = new(PostfixUnarySuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix
	return p
}

func (*PostfixUnarySuffixContext) IsPostfixUnarySuffixContext() {}

func NewPostfixUnarySuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnarySuffixContext {
	var p = new(PostfixUnarySuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix

	return p
}

func (s *PostfixUnarySuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnarySuffixContext) PostfixUnaryOperator() IPostfixUnaryOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnaryOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryOperatorContext)
}

func (s *PostfixUnarySuffixContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *PostfixUnarySuffixContext) CallSuffix() ICallSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *PostfixUnarySuffixContext) IndexingSuffix() IIndexingSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexingSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexingSuffixContext)
}

func (s *PostfixUnarySuffixContext) NavigationSuffix() INavigationSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INavigationSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INavigationSuffixContext)
}

func (s *PostfixUnarySuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnarySuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnarySuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnarySuffix(s)
	}
}

func (s *PostfixUnarySuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnarySuffix(s)
	}
}

func (p *KotlinParser) PostfixUnarySuffix() (localctx IPostfixUnarySuffixContext) {
	localctx = NewPostfixUnarySuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, KotlinParserRULE_postfixUnarySuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2294)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 340, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2289)
			p.PostfixUnaryOperator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2290)
			p.TypeArguments()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2291)
			p.CallSuffix()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2292)
			p.IndexingSuffix()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2293)
			p.NavigationSuffix()
		}

	}

	return localctx
}

// IDirectlyAssignableExpressionContext is an interface to support dynamic dispatch.
type IDirectlyAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectlyAssignableExpressionContext differentiates from other interfaces.
	IsDirectlyAssignableExpressionContext()
}

type DirectlyAssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectlyAssignableExpressionContext() *DirectlyAssignableExpressionContext {
	var p = new(DirectlyAssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression
	return p
}

func (*DirectlyAssignableExpressionContext) IsDirectlyAssignableExpressionContext() {}

func NewDirectlyAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectlyAssignableExpressionContext {
	var p = new(DirectlyAssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression

	return p
}

func (s *DirectlyAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectlyAssignableExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *DirectlyAssignableExpressionContext) AssignableSuffix() IAssignableSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableSuffixContext)
}

func (s *DirectlyAssignableExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *DirectlyAssignableExpressionContext) ParenthesizedDirectlyAssignableExpression() IParenthesizedDirectlyAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedDirectlyAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedDirectlyAssignableExpressionContext)
}

func (s *DirectlyAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectlyAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectlyAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDirectlyAssignableExpression(s)
	}
}

func (s *DirectlyAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDirectlyAssignableExpression(s)
	}
}

func (p *KotlinParser) DirectlyAssignableExpression() (localctx IDirectlyAssignableExpressionContext) {
	localctx = NewDirectlyAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, KotlinParserRULE_directlyAssignableExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2301)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 341, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2296)
			p.PostfixUnaryExpression()
		}
		{
			p.SetState(2297)
			p.AssignableSuffix()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2299)
			p.SimpleIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2300)
			p.ParenthesizedDirectlyAssignableExpression()
		}

	}

	return localctx
}

// IParenthesizedDirectlyAssignableExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedDirectlyAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedDirectlyAssignableExpressionContext differentiates from other interfaces.
	IsParenthesizedDirectlyAssignableExpressionContext()
}

type ParenthesizedDirectlyAssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedDirectlyAssignableExpressionContext() *ParenthesizedDirectlyAssignableExpressionContext {
	var p = new(ParenthesizedDirectlyAssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression
	return p
}

func (*ParenthesizedDirectlyAssignableExpressionContext) IsParenthesizedDirectlyAssignableExpressionContext() {
}

func NewParenthesizedDirectlyAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedDirectlyAssignableExpressionContext {
	var p = new(ParenthesizedDirectlyAssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression

	return p
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedDirectlyAssignableExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) DirectlyAssignableExpression() IDirectlyAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectlyAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectlyAssignableExpressionContext)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedDirectlyAssignableExpression(s)
	}
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedDirectlyAssignableExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedDirectlyAssignableExpression() (localctx IParenthesizedDirectlyAssignableExpressionContext) {
	localctx = NewParenthesizedDirectlyAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, KotlinParserRULE_parenthesizedDirectlyAssignableExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2303)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2304)
			p.Match(KotlinParserNL)
		}

		p.SetState(2309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2310)
		p.DirectlyAssignableExpression()
	}
	p.SetState(2314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2311)
			p.Match(KotlinParserNL)
		}

		p.SetState(2316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2317)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IAssignableExpressionContext is an interface to support dynamic dispatch.
type IAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableExpressionContext differentiates from other interfaces.
	IsAssignableExpressionContext()
}

type AssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableExpressionContext() *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableExpression
	return p
}

func (*AssignableExpressionContext) IsAssignableExpressionContext() {}

func NewAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignableExpression

	return p
}

func (s *AssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableExpressionContext) PrefixUnaryExpression() IPrefixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *AssignableExpressionContext) ParenthesizedAssignableExpression() IParenthesizedAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedAssignableExpressionContext)
}

func (s *AssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignableExpression(s)
	}
}

func (s *AssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignableExpression(s)
	}
}

func (p *KotlinParser) AssignableExpression() (localctx IAssignableExpressionContext) {
	localctx = NewAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, KotlinParserRULE_assignableExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2321)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2319)
			p.PrefixUnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2320)
			p.ParenthesizedAssignableExpression()
		}

	}

	return localctx
}

// IParenthesizedAssignableExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedAssignableExpressionContext differentiates from other interfaces.
	IsParenthesizedAssignableExpressionContext()
}

type ParenthesizedAssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedAssignableExpressionContext() *ParenthesizedAssignableExpressionContext {
	var p = new(ParenthesizedAssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression
	return p
}

func (*ParenthesizedAssignableExpressionContext) IsParenthesizedAssignableExpressionContext() {}

func NewParenthesizedAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedAssignableExpressionContext {
	var p = new(ParenthesizedAssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression

	return p
}

func (s *ParenthesizedAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedAssignableExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedAssignableExpressionContext) AssignableExpression() IAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *ParenthesizedAssignableExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedAssignableExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedAssignableExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedAssignableExpression(s)
	}
}

func (s *ParenthesizedAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedAssignableExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedAssignableExpression() (localctx IParenthesizedAssignableExpressionContext) {
	localctx = NewParenthesizedAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, KotlinParserRULE_parenthesizedAssignableExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2323)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2324)
			p.Match(KotlinParserNL)
		}

		p.SetState(2329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2330)
		p.AssignableExpression()
	}
	p.SetState(2334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2331)
			p.Match(KotlinParserNL)
		}

		p.SetState(2336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2337)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IAssignableSuffixContext is an interface to support dynamic dispatch.
type IAssignableSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableSuffixContext differentiates from other interfaces.
	IsAssignableSuffixContext()
}

type AssignableSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableSuffixContext() *AssignableSuffixContext {
	var p = new(AssignableSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableSuffix
	return p
}

func (*AssignableSuffixContext) IsAssignableSuffixContext() {}

func NewAssignableSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableSuffixContext {
	var p = new(AssignableSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignableSuffix

	return p
}

func (s *AssignableSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *AssignableSuffixContext) IndexingSuffix() IIndexingSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexingSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexingSuffixContext)
}

func (s *AssignableSuffixContext) NavigationSuffix() INavigationSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INavigationSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INavigationSuffixContext)
}

func (s *AssignableSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignableSuffix(s)
	}
}

func (s *AssignableSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignableSuffix(s)
	}
}

func (p *KotlinParser) AssignableSuffix() (localctx IAssignableSuffixContext) {
	localctx = NewAssignableSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, KotlinParserRULE_assignableSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2342)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLANGLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2339)
			p.TypeArguments()
		}

	case KotlinParserLSQUARE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2340)
			p.IndexingSuffix()
		}

	case KotlinParserNL, KotlinParserDOT, KotlinParserCOLONCOLON, KotlinParserQUEST_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2341)
			p.NavigationSuffix()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexingSuffixContext is an interface to support dynamic dispatch.
type IIndexingSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexingSuffixContext differentiates from other interfaces.
	IsIndexingSuffixContext()
}

type IndexingSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexingSuffixContext() *IndexingSuffixContext {
	var p = new(IndexingSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_indexingSuffix
	return p
}

func (*IndexingSuffixContext) IsIndexingSuffixContext() {}

func NewIndexingSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexingSuffixContext {
	var p = new(IndexingSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_indexingSuffix

	return p
}

func (s *IndexingSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexingSuffixContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *IndexingSuffixContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *IndexingSuffixContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexingSuffixContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *IndexingSuffixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IndexingSuffixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IndexingSuffixContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *IndexingSuffixContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *IndexingSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexingSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexingSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIndexingSuffix(s)
	}
}

func (s *IndexingSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIndexingSuffix(s)
	}
}

func (p *KotlinParser) IndexingSuffix() (localctx IIndexingSuffixContext) {
	localctx = NewIndexingSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, KotlinParserRULE_indexingSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2344)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(2348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2345)
			p.Match(KotlinParserNL)
		}

		p.SetState(2350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2351)
		p.Expression()
	}
	p.SetState(2368)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2355)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2352)
					p.Match(KotlinParserNL)
				}

				p.SetState(2357)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2358)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(2362)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2359)
					p.Match(KotlinParserNL)
				}

				p.SetState(2364)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2365)
				p.Expression()
			}

		}
		p.SetState(2370)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext())
	}
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 353, p.GetParserRuleContext()) == 1 {
		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2371)
				p.Match(KotlinParserNL)
			}

			p.SetState(2376)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2377)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2380)
			p.Match(KotlinParserNL)
		}

		p.SetState(2385)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2386)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// INavigationSuffixContext is an interface to support dynamic dispatch.
type INavigationSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNavigationSuffixContext differentiates from other interfaces.
	IsNavigationSuffixContext()
}

type NavigationSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNavigationSuffixContext() *NavigationSuffixContext {
	var p = new(NavigationSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_navigationSuffix
	return p
}

func (*NavigationSuffixContext) IsNavigationSuffixContext() {}

func NewNavigationSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NavigationSuffixContext {
	var p = new(NavigationSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_navigationSuffix

	return p
}

func (s *NavigationSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *NavigationSuffixContext) MemberAccessOperator() IMemberAccessOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberAccessOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberAccessOperatorContext)
}

func (s *NavigationSuffixContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *NavigationSuffixContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *NavigationSuffixContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *NavigationSuffixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NavigationSuffixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NavigationSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NavigationSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NavigationSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNavigationSuffix(s)
	}
}

func (s *NavigationSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNavigationSuffix(s)
	}
}

func (p *KotlinParser) NavigationSuffix() (localctx INavigationSuffixContext) {
	localctx = NewNavigationSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, KotlinParserRULE_navigationSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2388)
		p.MemberAccessOperator()
	}
	p.SetState(2392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2389)
			p.Match(KotlinParserNL)
		}

		p.SetState(2394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2398)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(2395)
			p.SimpleIdentifier()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(2396)
			p.ParenthesizedExpression()
		}

	case KotlinParserCLASS:
		{
			p.SetState(2397)
			p.Match(KotlinParserCLASS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallSuffixContext is an interface to support dynamic dispatch.
type ICallSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallSuffixContext differentiates from other interfaces.
	IsCallSuffixContext()
}

type CallSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallSuffixContext() *CallSuffixContext {
	var p = new(CallSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_callSuffix
	return p
}

func (*CallSuffixContext) IsCallSuffixContext() {}

func NewCallSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallSuffixContext {
	var p = new(CallSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callSuffix

	return p
}

func (s *CallSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *CallSuffixContext) AnnotatedLambda() IAnnotatedLambdaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotatedLambdaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotatedLambdaContext)
}

func (s *CallSuffixContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *CallSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *CallSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallSuffix(s)
	}
}

func (s *CallSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallSuffix(s)
	}
}

func (p *KotlinParser) CallSuffix() (localctx ICallSuffixContext) {
	localctx = NewCallSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, KotlinParserRULE_callSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLANGLE {
		{
			p.SetState(2400)
			p.TypeArguments()
		}

	}
	p.SetState(2408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserLPAREN {
			{
				p.SetState(2403)
				p.ValueArguments()
			}

		}
		{
			p.SetState(2406)
			p.AnnotatedLambda()
		}

	case 2:
		{
			p.SetState(2407)
			p.ValueArguments()
		}

	}

	return localctx
}

// IAnnotatedLambdaContext is an interface to support dynamic dispatch.
type IAnnotatedLambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotatedLambdaContext differentiates from other interfaces.
	IsAnnotatedLambdaContext()
}

type AnnotatedLambdaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedLambdaContext() *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedLambda
	return p
}

func (*AnnotatedLambdaContext) IsAnnotatedLambdaContext() {}

func NewAnnotatedLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedLambda

	return p
}

func (s *AnnotatedLambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedLambdaContext) LambdaLiteral() ILambdaLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaLiteralContext)
}

func (s *AnnotatedLambdaContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotatedLambdaContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotatedLambdaContext) Label() ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *AnnotatedLambdaContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedLambdaContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedLambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedLambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedLambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedLambda(s)
	}
}

func (s *AnnotatedLambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedLambda(s)
	}
}

func (p *KotlinParser) AnnotatedLambda() (localctx IAnnotatedLambdaContext) {
	localctx = NewAnnotatedLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, KotlinParserRULE_annotatedLambda)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(2410)
			p.Annotation()
		}

		p.SetState(2415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(KotlinParserFILE-61))|(1<<(KotlinParserFIELD-61))|(1<<(KotlinParserPROPERTY-61))|(1<<(KotlinParserGET-61))|(1<<(KotlinParserSET-61))|(1<<(KotlinParserRECEIVER-61))|(1<<(KotlinParserPARAM-61))|(1<<(KotlinParserSETPARAM-61))|(1<<(KotlinParserDELEGATE-61))|(1<<(KotlinParserIMPORT-61))|(1<<(KotlinParserCONSTRUCTOR-61))|(1<<(KotlinParserBY-61))|(1<<(KotlinParserCOMPANION-61))|(1<<(KotlinParserINIT-61))|(1<<(KotlinParserWHERE-61))|(1<<(KotlinParserCATCH-61))|(1<<(KotlinParserFINALLY-61)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105)))) != 0) || _la == KotlinParserIdentifier {
		{
			p.SetState(2416)
			p.Label()
		}

	}
	p.SetState(2422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2419)
			p.Match(KotlinParserNL)
		}

		p.SetState(2424)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2425)
		p.LambdaLiteral()
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeArgumentsContext) AllTypeProjection() []ITypeProjectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeProjectionContext)(nil)).Elem())
	var tst = make([]ITypeProjectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeProjectionContext)
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeProjection(i int) ITypeProjectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeProjectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionContext)
}

func (s *TypeArgumentsContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *KotlinParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, KotlinParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2427)
		p.Match(KotlinParserLANGLE)
	}
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2428)
			p.Match(KotlinParserNL)
		}

		p.SetState(2433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2434)
		p.TypeProjection()
	}
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 366, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2438)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2435)
					p.Match(KotlinParserNL)
				}

				p.SetState(2440)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2441)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(2445)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2442)
					p.Match(KotlinParserNL)
				}

				p.SetState(2447)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2448)
				p.TypeProjection()
			}

		}
		p.SetState(2453)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 366, p.GetParserRuleContext())
	}
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 368, p.GetParserRuleContext()) == 1 {
		p.SetState(2457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2454)
				p.Match(KotlinParserNL)
			}

			p.SetState(2459)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2460)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(2466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2463)
			p.Match(KotlinParserNL)
		}

		p.SetState(2468)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2469)
		p.Match(KotlinParserRANGLE)
	}

	return localctx
}

// IValueArgumentsContext is an interface to support dynamic dispatch.
type IValueArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueArgumentsContext differentiates from other interfaces.
	IsValueArgumentsContext()
}

type ValueArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentsContext() *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArguments
	return p
}

func (*ValueArgumentsContext) IsValueArgumentsContext() {}

func NewValueArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArguments

	return p
}

func (s *ValueArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ValueArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ValueArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentsContext) AllValueArgument() []IValueArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueArgumentContext)(nil)).Elem())
	var tst = make([]IValueArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueArgumentContext)
		}
	}

	return tst
}

func (s *ValueArgumentsContext) ValueArgument(i int) IValueArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentContext)
}

func (s *ValueArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ValueArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ValueArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArguments(s)
	}
}

func (s *ValueArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArguments(s)
	}
}

func (p *KotlinParser) ValueArguments() (localctx IValueArgumentsContext) {
	localctx = NewValueArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, KotlinParserRULE_valueArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2471)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2475)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2472)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2477)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext())
	}
	p.SetState(2513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserNL)|(1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserMULT)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL_WS)|(1<<KotlinParserEXCL_NO_WS))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(KotlinParserCOLONCOLON-37))|(1<<(KotlinParserAT_NO_WS-37))|(1<<(KotlinParserAT_PRE_WS-37))|(1<<(KotlinParserRETURN_AT-37))|(1<<(KotlinParserCONTINUE_AT-37))|(1<<(KotlinParserBREAK_AT-37))|(1<<(KotlinParserTHIS_AT-37))|(1<<(KotlinParserSUPER_AT-37))|(1<<(KotlinParserFILE-37))|(1<<(KotlinParserFIELD-37))|(1<<(KotlinParserPROPERTY-37))|(1<<(KotlinParserGET-37))|(1<<(KotlinParserSET-37))|(1<<(KotlinParserRECEIVER-37))|(1<<(KotlinParserPARAM-37))|(1<<(KotlinParserSETPARAM-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KotlinParserDELEGATE-69))|(1<<(KotlinParserIMPORT-69))|(1<<(KotlinParserFUN-69))|(1<<(KotlinParserOBJECT-69))|(1<<(KotlinParserCONSTRUCTOR-69))|(1<<(KotlinParserBY-69))|(1<<(KotlinParserCOMPANION-69))|(1<<(KotlinParserINIT-69))|(1<<(KotlinParserTHIS-69))|(1<<(KotlinParserSUPER-69))|(1<<(KotlinParserWHERE-69))|(1<<(KotlinParserIF-69))|(1<<(KotlinParserWHEN-69))|(1<<(KotlinParserTRY-69))|(1<<(KotlinParserCATCH-69))|(1<<(KotlinParserFINALLY-69))|(1<<(KotlinParserTHROW-69))|(1<<(KotlinParserRETURN-69))|(1<<(KotlinParserCONTINUE-69))|(1<<(KotlinParserBREAK-69)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105))|(1<<(KotlinParserRealLiteral-105)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(KotlinParserIntegerLiteral-138))|(1<<(KotlinParserHexLiteral-138))|(1<<(KotlinParserBinLiteral-138))|(1<<(KotlinParserUnsignedLiteral-138))|(1<<(KotlinParserLongLiteral-138))|(1<<(KotlinParserBooleanLiteral-138))|(1<<(KotlinParserNullLiteral-138))|(1<<(KotlinParserCharacterLiteral-138))|(1<<(KotlinParserIdentifier-138))|(1<<(KotlinParserQUOTE_OPEN-138))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-138)))) != 0) {
		{
			p.SetState(2478)
			p.ValueArgument()
		}
		p.SetState(2495)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2482)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2479)
						p.Match(KotlinParserNL)
					}

					p.SetState(2484)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2485)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(2489)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2486)
							p.Match(KotlinParserNL)
						}

					}
					p.SetState(2491)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext())
				}
				{
					p.SetState(2492)
					p.ValueArgument()
				}

			}
			p.SetState(2497)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext())
		}
		p.SetState(2505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
			p.SetState(2501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2498)
					p.Match(KotlinParserNL)
				}

				p.SetState(2503)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2504)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2507)
				p.Match(KotlinParserNL)
			}

			p.SetState(2512)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2515)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IValueArgumentContext is an interface to support dynamic dispatch.
type IValueArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueArgumentContext differentiates from other interfaces.
	IsValueArgumentContext()
}

type ValueArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentContext() *ValueArgumentContext {
	var p = new(ValueArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArgument
	return p
}

func (*ValueArgumentContext) IsValueArgumentContext() {}

func NewValueArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentContext {
	var p = new(ValueArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArgument

	return p
}

func (s *ValueArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValueArgumentContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ValueArgumentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ValueArgumentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ValueArgumentContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ValueArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArgument(s)
	}
}

func (s *ValueArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArgument(s)
	}
}

func (p *KotlinParser) ValueArgument() (localctx IValueArgumentContext) {
	localctx = NewValueArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, KotlinParserRULE_valueArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2517)
			p.Annotation()
		}

	}
	p.SetState(2523)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2520)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2525)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())
	}
	p.SetState(2540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2526)
			p.SimpleIdentifier()
		}
		p.SetState(2530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2527)
				p.Match(KotlinParserNL)
			}

			p.SetState(2532)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2533)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(2537)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2534)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2539)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext())
		}

	}
	p.SetState(2543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserMULT {
		{
			p.SetState(2542)
			p.Match(KotlinParserMULT)
		}

	}
	p.SetState(2548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2545)
			p.Match(KotlinParserNL)
		}

		p.SetState(2550)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2551)
		p.Expression()
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *PrimaryExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *PrimaryExpressionContext) LiteralConstant() ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) CallableReference() ICallableReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallableReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallableReferenceContext)
}

func (s *PrimaryExpressionContext) FunctionLiteral() IFunctionLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionLiteralContext)
}

func (s *PrimaryExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PrimaryExpressionContext) CollectionLiteral() ICollectionLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollectionLiteralContext)
}

func (s *PrimaryExpressionContext) ThisExpression() IThisExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThisExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThisExpressionContext)
}

func (s *PrimaryExpressionContext) SuperExpression() ISuperExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperExpressionContext)
}

func (s *PrimaryExpressionContext) IfExpression() IIfExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExpressionContext)
}

func (s *PrimaryExpressionContext) WhenExpression() IWhenExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *PrimaryExpressionContext) TryExpression() ITryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryExpressionContext)
}

func (s *PrimaryExpressionContext) JumpExpression() IJumpExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJumpExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJumpExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *KotlinParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, KotlinParserRULE_primaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2567)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2553)
			p.ParenthesizedExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2554)
			p.SimpleIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2555)
			p.LiteralConstant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2556)
			p.StringLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2557)
			p.CallableReference()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2558)
			p.FunctionLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2559)
			p.ObjectLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2560)
			p.CollectionLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2561)
			p.ThisExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2562)
			p.SuperExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2563)
			p.IfExpression()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2564)
			p.WhenExpression()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2565)
			p.TryExpression()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2566)
			p.JumpExpression()
		}

	}

	return localctx
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression
	return p
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, KotlinParserRULE_parenthesizedExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2569)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2570)
			p.Match(KotlinParserNL)
		}

		p.SetState(2575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2576)
		p.Expression()
	}
	p.SetState(2580)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2577)
			p.Match(KotlinParserNL)
		}

		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2583)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// ICollectionLiteralContext is an interface to support dynamic dispatch.
type ICollectionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionLiteralContext differentiates from other interfaces.
	IsCollectionLiteralContext()
}

type CollectionLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionLiteralContext() *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_collectionLiteral
	return p
}

func (*CollectionLiteralContext) IsCollectionLiteralContext() {}

func NewCollectionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_collectionLiteral

	return p
}

func (s *CollectionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionLiteralContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *CollectionLiteralContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *CollectionLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CollectionLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CollectionLiteralContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CollectionLiteralContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CollectionLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *CollectionLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *CollectionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCollectionLiteral(s)
	}
}

func (s *CollectionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCollectionLiteral(s)
	}
}

func (p *KotlinParser) CollectionLiteral() (localctx ICollectionLiteralContext) {
	localctx = NewCollectionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, KotlinParserRULE_collectionLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2585)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(2589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2586)
			p.Match(KotlinParserNL)
		}

		p.SetState(2591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2627)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL_WS)|(1<<KotlinParserEXCL_NO_WS))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(KotlinParserCOLONCOLON-37))|(1<<(KotlinParserAT_NO_WS-37))|(1<<(KotlinParserAT_PRE_WS-37))|(1<<(KotlinParserRETURN_AT-37))|(1<<(KotlinParserCONTINUE_AT-37))|(1<<(KotlinParserBREAK_AT-37))|(1<<(KotlinParserTHIS_AT-37))|(1<<(KotlinParserSUPER_AT-37))|(1<<(KotlinParserFILE-37))|(1<<(KotlinParserFIELD-37))|(1<<(KotlinParserPROPERTY-37))|(1<<(KotlinParserGET-37))|(1<<(KotlinParserSET-37))|(1<<(KotlinParserRECEIVER-37))|(1<<(KotlinParserPARAM-37))|(1<<(KotlinParserSETPARAM-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KotlinParserDELEGATE-69))|(1<<(KotlinParserIMPORT-69))|(1<<(KotlinParserFUN-69))|(1<<(KotlinParserOBJECT-69))|(1<<(KotlinParserCONSTRUCTOR-69))|(1<<(KotlinParserBY-69))|(1<<(KotlinParserCOMPANION-69))|(1<<(KotlinParserINIT-69))|(1<<(KotlinParserTHIS-69))|(1<<(KotlinParserSUPER-69))|(1<<(KotlinParserWHERE-69))|(1<<(KotlinParserIF-69))|(1<<(KotlinParserWHEN-69))|(1<<(KotlinParserTRY-69))|(1<<(KotlinParserCATCH-69))|(1<<(KotlinParserFINALLY-69))|(1<<(KotlinParserTHROW-69))|(1<<(KotlinParserRETURN-69))|(1<<(KotlinParserCONTINUE-69))|(1<<(KotlinParserBREAK-69)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105))|(1<<(KotlinParserRealLiteral-105)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(KotlinParserIntegerLiteral-138))|(1<<(KotlinParserHexLiteral-138))|(1<<(KotlinParserBinLiteral-138))|(1<<(KotlinParserUnsignedLiteral-138))|(1<<(KotlinParserLongLiteral-138))|(1<<(KotlinParserBooleanLiteral-138))|(1<<(KotlinParserNullLiteral-138))|(1<<(KotlinParserCharacterLiteral-138))|(1<<(KotlinParserIdentifier-138))|(1<<(KotlinParserQUOTE_OPEN-138))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-138)))) != 0) {
		{
			p.SetState(2592)
			p.Expression()
		}
		p.SetState(2609)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2596)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2593)
						p.Match(KotlinParserNL)
					}

					p.SetState(2598)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2599)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(2603)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2600)
						p.Match(KotlinParserNL)
					}

					p.SetState(2605)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2606)
					p.Expression()
				}

			}
			p.SetState(2611)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext())
		}
		p.SetState(2619)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
			p.SetState(2615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2612)
					p.Match(KotlinParserNL)
				}

				p.SetState(2617)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2618)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(2624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2621)
				p.Match(KotlinParserNL)
			}

			p.SetState(2626)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2629)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBooleanLiteral, 0)
}

func (s *LiteralConstantContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserIntegerLiteral, 0)
}

func (s *LiteralConstantContext) HexLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserHexLiteral, 0)
}

func (s *LiteralConstantContext) BinLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBinLiteral, 0)
}

func (s *LiteralConstantContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserCharacterLiteral, 0)
}

func (s *LiteralConstantContext) RealLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserRealLiteral, 0)
}

func (s *LiteralConstantContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserNullLiteral, 0)
}

func (s *LiteralConstantContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserLongLiteral, 0)
}

func (s *LiteralConstantContext) UnsignedLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserUnsignedLiteral, 0)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLiteralConstant(s)
	}
}

func (p *KotlinParser) LiteralConstant() (localctx ILiteralConstantContext) {
	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, KotlinParserRULE_literalConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2631)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(KotlinParserRealLiteral-135))|(1<<(KotlinParserIntegerLiteral-135))|(1<<(KotlinParserHexLiteral-135))|(1<<(KotlinParserBinLiteral-135))|(1<<(KotlinParserUnsignedLiteral-135))|(1<<(KotlinParserLongLiteral-135))|(1<<(KotlinParserBooleanLiteral-135))|(1<<(KotlinParserNullLiteral-135))|(1<<(KotlinParserCharacterLiteral-135)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) LineStringLiteral() ILineStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineStringLiteralContext)
}

func (s *StringLiteralContext) MultiLineStringLiteral() IMultiLineStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiLineStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringLiteralContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *KotlinParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, KotlinParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2635)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserQUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2633)
			p.LineStringLiteral()
		}

	case KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2634)
			p.MultiLineStringLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILineStringLiteralContext is an interface to support dynamic dispatch.
type ILineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStringLiteralContext differentiates from other interfaces.
	IsLineStringLiteralContext()
}

type LineStringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringLiteralContext() *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringLiteral
	return p
}

func (*LineStringLiteralContext) IsLineStringLiteralContext() {}

func NewLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringLiteral

	return p
}

func (s *LineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringLiteralContext) QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_OPEN, 0)
}

func (s *LineStringLiteralContext) QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_CLOSE, 0)
}

func (s *LineStringLiteralContext) AllLineStringContent() []ILineStringContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineStringContentContext)(nil)).Elem())
	var tst = make([]ILineStringContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineStringContentContext)
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringContent(i int) ILineStringContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineStringContentContext)
}

func (s *LineStringLiteralContext) AllLineStringExpression() []ILineStringExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineStringExpressionContext)(nil)).Elem())
	var tst = make([]ILineStringExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineStringExpressionContext)
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringExpression(i int) ILineStringExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineStringExpressionContext)
}

func (s *LineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringLiteral(s)
	}
}

func (s *LineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringLiteral(s)
	}
}

func (p *KotlinParser) LineStringLiteral() (localctx ILineStringLiteralContext) {
	localctx = NewLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, KotlinParserRULE_lineStringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2637)
		p.Match(KotlinParserQUOTE_OPEN)
	}
	p.SetState(2642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(KotlinParserLineStrRef-159))|(1<<(KotlinParserLineStrText-159))|(1<<(KotlinParserLineStrEscapedChar-159))|(1<<(KotlinParserLineStrExprStart-159)))) != 0 {
		p.SetState(2640)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLineStrRef, KotlinParserLineStrText, KotlinParserLineStrEscapedChar:
			{
				p.SetState(2638)
				p.LineStringContent()
			}

		case KotlinParserLineStrExprStart:
			{
				p.SetState(2639)
				p.LineStringExpression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2645)
		p.Match(KotlinParserQUOTE_CLOSE)
	}

	return localctx
}

// IMultiLineStringLiteralContext is an interface to support dynamic dispatch.
type IMultiLineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiLineStringLiteralContext differentiates from other interfaces.
	IsMultiLineStringLiteralContext()
}

type MultiLineStringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringLiteralContext() *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral
	return p
}

func (*MultiLineStringLiteralContext) IsMultiLineStringLiteralContext() {}

func NewMultiLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral

	return p
}

func (s *MultiLineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_OPEN, 0)
}

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_CLOSE, 0)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringContent() []IMultiLineStringContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiLineStringContentContext)(nil)).Elem())
	var tst = make([]IMultiLineStringContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiLineStringContentContext)
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringContent(i int) IMultiLineStringContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiLineStringContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringContentContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringExpression() []IMultiLineStringExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiLineStringExpressionContext)(nil)).Elem())
	var tst = make([]IMultiLineStringExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiLineStringExpressionContext)
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringExpression(i int) IMultiLineStringExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiLineStringExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringExpressionContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringQuote() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserMultiLineStringQuote)
}

func (s *MultiLineStringLiteralContext) MultiLineStringQuote(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, i)
}

func (s *MultiLineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringLiteral(s)
	}
}

func (s *MultiLineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringLiteral(s)
	}
}

func (p *KotlinParser) MultiLineStringLiteral() (localctx IMultiLineStringLiteralContext) {
	localctx = NewMultiLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, KotlinParserRULE_multiLineStringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2647)
		p.Match(KotlinParserTRIPLE_QUOTE_OPEN)
	}
	p.SetState(2653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(KotlinParserMultiLineStringQuote-164))|(1<<(KotlinParserMultiLineStrRef-164))|(1<<(KotlinParserMultiLineStrText-164))|(1<<(KotlinParserMultiLineStrExprStart-164)))) != 0 {
		p.SetState(2651)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2648)
				p.MultiLineStringContent()
			}

		case 2:
			{
				p.SetState(2649)
				p.MultiLineStringExpression()
			}

		case 3:
			{
				p.SetState(2650)
				p.Match(KotlinParserMultiLineStringQuote)
			}

		}

		p.SetState(2655)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2656)
		p.Match(KotlinParserTRIPLE_QUOTE_CLOSE)
	}

	return localctx
}

// ILineStringContentContext is an interface to support dynamic dispatch.
type ILineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStringContentContext differentiates from other interfaces.
	IsLineStringContentContext()
}

type LineStringContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringContentContext() *LineStringContentContext {
	var p = new(LineStringContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringContent
	return p
}

func (*LineStringContentContext) IsLineStringContentContext() {}

func NewLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringContentContext {
	var p = new(LineStringContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringContent

	return p
}

func (s *LineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringContentContext) LineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrText, 0)
}

func (s *LineStringContentContext) LineStrEscapedChar() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrEscapedChar, 0)
}

func (s *LineStringContentContext) LineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrRef, 0)
}

func (s *LineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringContent(s)
	}
}

func (s *LineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringContent(s)
	}
}

func (p *KotlinParser) LineStringContent() (localctx ILineStringContentContext) {
	localctx = NewLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, KotlinParserRULE_lineStringContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2658)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(KotlinParserLineStrRef-159))|(1<<(KotlinParserLineStrText-159))|(1<<(KotlinParserLineStrEscapedChar-159)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILineStringExpressionContext is an interface to support dynamic dispatch.
type ILineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStringExpressionContext differentiates from other interfaces.
	IsLineStringExpressionContext()
}

type LineStringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringExpressionContext() *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringExpression
	return p
}

func (*LineStringExpressionContext) IsLineStringExpressionContext() {}

func NewLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringExpression

	return p
}

func (s *LineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringExpressionContext) LineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrExprStart, 0)
}

func (s *LineStringExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LineStringExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LineStringExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringExpression(s)
	}
}

func (s *LineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringExpression(s)
	}
}

func (p *KotlinParser) LineStringExpression() (localctx ILineStringExpressionContext) {
	localctx = NewLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, KotlinParserRULE_lineStringExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2660)
		p.Match(KotlinParserLineStrExprStart)
	}
	p.SetState(2664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2661)
			p.Match(KotlinParserNL)
		}

		p.SetState(2666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2667)
		p.Expression()
	}
	p.SetState(2671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2668)
			p.Match(KotlinParserNL)
		}

		p.SetState(2673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2674)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IMultiLineStringContentContext is an interface to support dynamic dispatch.
type IMultiLineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiLineStringContentContext differentiates from other interfaces.
	IsMultiLineStringContentContext()
}

type MultiLineStringContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringContentContext() *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringContent
	return p
}

func (*MultiLineStringContentContext) IsMultiLineStringContentContext() {}

func NewMultiLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringContent

	return p
}

func (s *MultiLineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringContentContext) MultiLineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrText, 0)
}

func (s *MultiLineStringContentContext) MultiLineStringQuote() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, 0)
}

func (s *MultiLineStringContentContext) MultiLineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrRef, 0)
}

func (s *MultiLineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringContent(s)
	}
}

func (s *MultiLineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringContent(s)
	}
}

func (p *KotlinParser) MultiLineStringContent() (localctx IMultiLineStringContentContext) {
	localctx = NewMultiLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, KotlinParserRULE_multiLineStringContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2676)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(KotlinParserMultiLineStringQuote-164))|(1<<(KotlinParserMultiLineStrRef-164))|(1<<(KotlinParserMultiLineStrText-164)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiLineStringExpressionContext is an interface to support dynamic dispatch.
type IMultiLineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiLineStringExpressionContext differentiates from other interfaces.
	IsMultiLineStringExpressionContext()
}

type MultiLineStringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringExpressionContext() *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression
	return p
}

func (*MultiLineStringExpressionContext) IsMultiLineStringExpressionContext() {}

func NewMultiLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression

	return p
}

func (s *MultiLineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringExpressionContext) MultiLineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrExprStart, 0)
}

func (s *MultiLineStringExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiLineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *MultiLineStringExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiLineStringExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiLineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringExpression(s)
	}
}

func (s *MultiLineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringExpression(s)
	}
}

func (p *KotlinParser) MultiLineStringExpression() (localctx IMultiLineStringExpressionContext) {
	localctx = NewMultiLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, KotlinParserRULE_multiLineStringExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2678)
		p.Match(KotlinParserMultiLineStrExprStart)
	}
	p.SetState(2682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2679)
			p.Match(KotlinParserNL)
		}

		p.SetState(2684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2685)
		p.Expression()
	}
	p.SetState(2689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2686)
			p.Match(KotlinParserNL)
		}

		p.SetState(2691)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2692)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// ILambdaLiteralContext is an interface to support dynamic dispatch.
type ILambdaLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaLiteralContext differentiates from other interfaces.
	IsLambdaLiteralContext()
}

type LambdaLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLiteralContext() *LambdaLiteralContext {
	var p = new(LambdaLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaLiteral
	return p
}

func (*LambdaLiteralContext) IsLambdaLiteralContext() {}

func NewLambdaLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLiteralContext {
	var p = new(LambdaLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaLiteral

	return p
}

func (s *LambdaLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLiteralContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *LambdaLiteralContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *LambdaLiteralContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LambdaLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaLiteralContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *LambdaLiteralContext) LambdaParameters() ILambdaParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaLiteral(s)
	}
}

func (s *LambdaLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaLiteral(s)
	}
}

func (p *KotlinParser) LambdaLiteral() (localctx ILambdaLiteralContext) {
	localctx = NewLambdaLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, KotlinParserRULE_lambdaLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2694)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(2698)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2695)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2700)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext())
	}
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 409, p.GetParserRuleContext()) == 1 {
		p.SetState(2702)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2701)
				p.LambdaParameters()
			}

		}
		p.SetState(2707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2704)
				p.Match(KotlinParserNL)
			}

			p.SetState(2709)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2710)
			p.Match(KotlinParserARROW)
		}
		p.SetState(2714)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2711)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2716)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext())
		}

	}
	{
		p.SetState(2719)
		p.Statements()
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2720)
			p.Match(KotlinParserNL)
		}

		p.SetState(2725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2726)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) AllLambdaParameter() []ILambdaParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILambdaParameterContext)(nil)).Elem())
	var tst = make([]ILambdaParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILambdaParameterContext)
		}
	}

	return tst
}

func (s *LambdaParametersContext) LambdaParameter(i int) ILambdaParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterContext)
}

func (s *LambdaParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *LambdaParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *LambdaParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *KotlinParser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, KotlinParserRULE_lambdaParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2728)
		p.LambdaParameter()
	}
	p.SetState(2745)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 413, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2732)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2729)
					p.Match(KotlinParserNL)
				}

				p.SetState(2734)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2735)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(2739)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2736)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(2741)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext())
			}
			{
				p.SetState(2742)
				p.LambdaParameter()
			}

		}
		p.SetState(2747)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 413, p.GetParserRuleContext())
	}
	p.SetState(2755)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
		p.SetState(2751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2748)
				p.Match(KotlinParserNL)
			}

			p.SetState(2753)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2754)
			p.Match(KotlinParserCOMMA)
		}

	}

	return localctx
}

// ILambdaParameterContext is an interface to support dynamic dispatch.
type ILambdaParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParameterContext differentiates from other interfaces.
	IsLambdaParameterContext()
}

type LambdaParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterContext() *LambdaParameterContext {
	var p = new(LambdaParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameter
	return p
}

func (*LambdaParameterContext) IsLambdaParameterContext() {}

func NewLambdaParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterContext {
	var p = new(LambdaParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameter

	return p
}

func (s *LambdaParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LambdaParameterContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *LambdaParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *LambdaParameterContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *LambdaParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameter(s)
	}
}

func (s *LambdaParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameter(s)
	}
}

func (p *KotlinParser) LambdaParameter() (localctx ILambdaParameterContext) {
	localctx = NewLambdaParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, KotlinParserRULE_lambdaParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2775)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2757)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2758)
			p.MultiVariableDeclaration()
		}
		p.SetState(2773)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext()) == 1 {
			p.SetState(2762)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2759)
					p.Match(KotlinParserNL)
				}

				p.SetState(2764)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2765)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(2769)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2766)
					p.Match(KotlinParserNL)
				}

				p.SetState(2771)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2772)
				p.DataType()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnonymousFunctionContext is an interface to support dynamic dispatch.
type IAnonymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousFunctionContext differentiates from other interfaces.
	IsAnonymousFunctionContext()
}

type AnonymousFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousFunctionContext() *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousFunction
	return p
}

func (*AnonymousFunctionContext) IsAnonymousFunctionContext() {}

func NewAnonymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousFunction

	return p
}

func (s *AnonymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousFunctionContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *AnonymousFunctionContext) ParametersWithOptionalType() IParametersWithOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParametersWithOptionalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParametersWithOptionalTypeContext)
}

func (s *AnonymousFunctionContext) AllDataType() []IDataTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeContext)(nil)).Elem())
	var tst = make([]IDataTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeContext)
		}
	}

	return tst
}

func (s *AnonymousFunctionContext) DataType(i int) IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AnonymousFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *AnonymousFunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousFunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousFunctionContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnonymousFunctionContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *AnonymousFunctionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnonymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousFunction(s)
	}
}

func (s *AnonymousFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousFunction(s)
	}
}

func (p *KotlinParser) AnonymousFunction() (localctx IAnonymousFunctionContext) {
	localctx = NewAnonymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, KotlinParserRULE_anonymousFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2777)
		p.Match(KotlinParserFUN)
	}
	p.SetState(2793)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 422, p.GetParserRuleContext()) == 1 {
		p.SetState(2781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2778)
				p.Match(KotlinParserNL)
			}

			p.SetState(2783)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2784)
			p.DataType()
		}
		p.SetState(2788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2785)
				p.Match(KotlinParserNL)
			}

			p.SetState(2790)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2791)
			p.Match(KotlinParserDOT)
		}

	}
	p.SetState(2798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2795)
			p.Match(KotlinParserNL)
		}

		p.SetState(2800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2801)
		p.ParametersWithOptionalType()
	}
	p.SetState(2816)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 426, p.GetParserRuleContext()) == 1 {
		p.SetState(2805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2802)
				p.Match(KotlinParserNL)
			}

			p.SetState(2807)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2808)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(2812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2809)
				p.Match(KotlinParserNL)
			}

			p.SetState(2814)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2815)
			p.DataType()
		}

	}
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 428, p.GetParserRuleContext()) == 1 {
		p.SetState(2821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2818)
				p.Match(KotlinParserNL)
			}

			p.SetState(2823)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2824)
			p.TypeConstraints()
		}

	}
	p.SetState(2834)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2827)
				p.Match(KotlinParserNL)
			}

			p.SetState(2832)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2833)
			p.FunctionBody()
		}

	}

	return localctx
}

// IFunctionLiteralContext is an interface to support dynamic dispatch.
type IFunctionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionLiteralContext differentiates from other interfaces.
	IsFunctionLiteralContext()
}

type FunctionLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLiteralContext() *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionLiteral
	return p
}

func (*FunctionLiteralContext) IsFunctionLiteralContext() {}

func NewFunctionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionLiteral

	return p
}

func (s *FunctionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLiteralContext) LambdaLiteral() ILambdaLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaLiteralContext)
}

func (s *FunctionLiteralContext) AnonymousFunction() IAnonymousFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousFunctionContext)
}

func (s *FunctionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionLiteral(s)
	}
}

func (s *FunctionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionLiteral(s)
	}
}

func (p *KotlinParser) FunctionLiteral() (localctx IFunctionLiteralContext) {
	localctx = NewFunctionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, KotlinParserRULE_functionLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2838)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2836)
			p.LambdaLiteral()
		}

	case KotlinParserFUN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2837)
			p.AnonymousFunction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectLiteralContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectLiteralContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (p *KotlinParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, KotlinParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2840)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(2861)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 435, p.GetParserRuleContext()) == 1 {
		p.SetState(2844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2841)
				p.Match(KotlinParserNL)
			}

			p.SetState(2846)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2847)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(2851)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2848)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2853)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext())
		}
		{
			p.SetState(2854)
			p.DelegationSpecifiers()
		}
		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2855)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2860)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext())
		}

	}
	p.SetState(2870)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 437, p.GetParserRuleContext()) == 1 {
		p.SetState(2866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2863)
				p.Match(KotlinParserNL)
			}

			p.SetState(2868)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2869)
			p.ClassBody()
		}

	}

	return localctx
}

// IThisExpressionContext is an interface to support dynamic dispatch.
type IThisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThisExpressionContext differentiates from other interfaces.
	IsThisExpressionContext()
}

type ThisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisExpressionContext() *ThisExpressionContext {
	var p = new(ThisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_thisExpression
	return p
}

func (*ThisExpressionContext) IsThisExpressionContext() {}

func NewThisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_thisExpression

	return p
}

func (s *ThisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisExpressionContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ThisExpressionContext) THIS_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS_AT, 0)
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (p *KotlinParser) ThisExpression() (localctx IThisExpressionContext) {
	localctx = NewThisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, KotlinParserRULE_thisExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2872)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserTHIS_AT || _la == KotlinParserTHIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISuperExpressionContext is an interface to support dynamic dispatch.
type ISuperExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperExpressionContext differentiates from other interfaces.
	IsSuperExpressionContext()
}

type SuperExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperExpressionContext() *SuperExpressionContext {
	var p = new(SuperExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_superExpression
	return p
}

func (*SuperExpressionContext) IsSuperExpressionContext() {}

func NewSuperExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_superExpression

	return p
}

func (s *SuperExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperExpressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *SuperExpressionContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *SuperExpressionContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *SuperExpressionContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *SuperExpressionContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *SuperExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SuperExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SuperExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SuperExpressionContext) SUPER_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER_AT, 0)
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (p *KotlinParser) SuperExpression() (localctx ISuperExpressionContext) {
	localctx = NewSuperExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, KotlinParserRULE_superExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2898)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2874)
			p.Match(KotlinParserSUPER)
		}
		p.SetState(2891)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2875)
				p.Match(KotlinParserLANGLE)
			}
			p.SetState(2879)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2876)
					p.Match(KotlinParserNL)
				}

				p.SetState(2881)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2882)
				p.DataType()
			}
			p.SetState(2886)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2883)
					p.Match(KotlinParserNL)
				}

				p.SetState(2888)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2889)
				p.Match(KotlinParserRANGLE)
			}

		}
		p.SetState(2895)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2893)
				p.Match(KotlinParserAT_NO_WS)
			}
			{
				p.SetState(2894)
				p.SimpleIdentifier()
			}

		}

	case KotlinParserSUPER_AT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2897)
			p.Match(KotlinParserSUPER_AT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfExpressionContext is an interface to support dynamic dispatch.
type IIfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExpressionContext differentiates from other interfaces.
	IsIfExpressionContext()
}

type IfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExpressionContext() *IfExpressionContext {
	var p = new(IfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_ifExpression
	return p
}

func (*IfExpressionContext) IsIfExpressionContext() {}

func NewIfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExpressionContext {
	var p = new(IfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_ifExpression

	return p
}

func (s *IfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(KotlinParserIF, 0)
}

func (s *IfExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *IfExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *IfExpressionContext) AllControlStructureBody() []IControlStructureBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem())
	var tst = make([]IControlStructureBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControlStructureBodyContext)
		}
	}

	return tst
}

func (s *IfExpressionContext) ControlStructureBody(i int) IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *IfExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *IfExpressionContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSEMICOLON)
}

func (s *IfExpressionContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, i)
}

func (s *IfExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IfExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIfExpression(s)
	}
}

func (s *IfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIfExpression(s)
	}
}

func (p *KotlinParser) IfExpression() (localctx IIfExpressionContext) {
	localctx = NewIfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, KotlinParserRULE_ifExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2900)
		p.Match(KotlinParserIF)
	}
	p.SetState(2904)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2901)
			p.Match(KotlinParserNL)
		}

		p.SetState(2906)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2907)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2908)
			p.Match(KotlinParserNL)
		}

		p.SetState(2913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2914)
		p.Expression()
	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2915)
			p.Match(KotlinParserNL)
		}

		p.SetState(2920)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2921)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2925)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2922)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2927)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext())
	}
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 453, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2928)
			p.ControlStructureBody()
		}

	case 2:
		p.SetState(2930)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL_WS)|(1<<KotlinParserEXCL_NO_WS))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(KotlinParserCOLONCOLON-37))|(1<<(KotlinParserAT_NO_WS-37))|(1<<(KotlinParserAT_PRE_WS-37))|(1<<(KotlinParserRETURN_AT-37))|(1<<(KotlinParserCONTINUE_AT-37))|(1<<(KotlinParserBREAK_AT-37))|(1<<(KotlinParserTHIS_AT-37))|(1<<(KotlinParserSUPER_AT-37))|(1<<(KotlinParserFILE-37))|(1<<(KotlinParserFIELD-37))|(1<<(KotlinParserPROPERTY-37))|(1<<(KotlinParserGET-37))|(1<<(KotlinParserSET-37))|(1<<(KotlinParserRECEIVER-37))|(1<<(KotlinParserPARAM-37))|(1<<(KotlinParserSETPARAM-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KotlinParserDELEGATE-69))|(1<<(KotlinParserIMPORT-69))|(1<<(KotlinParserCLASS-69))|(1<<(KotlinParserINTERFACE-69))|(1<<(KotlinParserFUN-69))|(1<<(KotlinParserOBJECT-69))|(1<<(KotlinParserVAL-69))|(1<<(KotlinParserVAR-69))|(1<<(KotlinParserTYPE_ALIAS-69))|(1<<(KotlinParserCONSTRUCTOR-69))|(1<<(KotlinParserBY-69))|(1<<(KotlinParserCOMPANION-69))|(1<<(KotlinParserINIT-69))|(1<<(KotlinParserTHIS-69))|(1<<(KotlinParserSUPER-69))|(1<<(KotlinParserWHERE-69))|(1<<(KotlinParserIF-69))|(1<<(KotlinParserWHEN-69))|(1<<(KotlinParserTRY-69))|(1<<(KotlinParserCATCH-69))|(1<<(KotlinParserFINALLY-69))|(1<<(KotlinParserFOR-69))|(1<<(KotlinParserDO-69))|(1<<(KotlinParserWHILE-69))|(1<<(KotlinParserTHROW-69))|(1<<(KotlinParserRETURN-69))|(1<<(KotlinParserCONTINUE-69))|(1<<(KotlinParserBREAK-69)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105))|(1<<(KotlinParserRealLiteral-105)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(KotlinParserIntegerLiteral-138))|(1<<(KotlinParserHexLiteral-138))|(1<<(KotlinParserBinLiteral-138))|(1<<(KotlinParserUnsignedLiteral-138))|(1<<(KotlinParserLongLiteral-138))|(1<<(KotlinParserBooleanLiteral-138))|(1<<(KotlinParserNullLiteral-138))|(1<<(KotlinParserCharacterLiteral-138))|(1<<(KotlinParserIdentifier-138))|(1<<(KotlinParserQUOTE_OPEN-138))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-138)))) != 0) {
			{
				p.SetState(2929)
				p.ControlStructureBody()
			}

		}
		p.SetState(2935)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2932)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2937)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext())
		}
		p.SetState(2939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserSEMICOLON {
			{
				p.SetState(2938)
				p.Match(KotlinParserSEMICOLON)
			}

		}
		p.SetState(2944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2941)
				p.Match(KotlinParserNL)
			}

			p.SetState(2946)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2947)
			p.Match(KotlinParserELSE)
		}
		p.SetState(2951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2948)
				p.Match(KotlinParserNL)
			}

			p.SetState(2953)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2956)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
			{
				p.SetState(2954)
				p.ControlStructureBody()
			}

		case KotlinParserSEMICOLON:
			{
				p.SetState(2955)
				p.Match(KotlinParserSEMICOLON)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		{
			p.SetState(2958)
			p.Match(KotlinParserSEMICOLON)
		}

	}

	return localctx
}

// IWhenSubjectContext is an interface to support dynamic dispatch.
type IWhenSubjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenSubjectContext differentiates from other interfaces.
	IsWhenSubjectContext()
}

type WhenSubjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenSubjectContext() *WhenSubjectContext {
	var p = new(WhenSubjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenSubject
	return p
}

func (*WhenSubjectContext) IsWhenSubjectContext() {}

func NewWhenSubjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenSubjectContext {
	var p = new(WhenSubjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenSubject

	return p
}

func (s *WhenSubjectContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenSubjectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhenSubjectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenSubjectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhenSubjectContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *WhenSubjectContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *WhenSubjectContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *WhenSubjectContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *WhenSubjectContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *WhenSubjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenSubjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenSubjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenSubjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenSubjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenSubject(s)
	}
}

func (s *WhenSubjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenSubject(s)
	}
}

func (p *KotlinParser) WhenSubject() (localctx IWhenSubjectContext) {
	localctx = NewWhenSubjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, KotlinParserRULE_whenSubject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2961)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2995)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 459, p.GetParserRuleContext()) == 1 {
		p.SetState(2965)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
			{
				p.SetState(2962)
				p.Annotation()
			}

			p.SetState(2967)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2968)
				p.Match(KotlinParserNL)
			}

			p.SetState(2973)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2974)
			p.Match(KotlinParserVAL)
		}
		p.SetState(2978)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 456, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2975)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2980)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 456, p.GetParserRuleContext())
		}
		{
			p.SetState(2981)
			p.VariableDeclaration()
		}
		p.SetState(2985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2982)
				p.Match(KotlinParserNL)
			}

			p.SetState(2987)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2988)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(2992)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2989)
				p.Match(KotlinParserNL)
			}

			p.SetState(2994)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2997)
		p.Expression()
	}
	{
		p.SetState(2998)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenExpression
	return p
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHEN, 0)
}

func (s *WhenExpressionContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *WhenExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *WhenExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenExpressionContext) WhenSubject() IWhenSubjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenSubjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenSubjectContext)
}

func (s *WhenExpressionContext) AllWhenEntry() []IWhenEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenEntryContext)(nil)).Elem())
	var tst = make([]IWhenEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenEntryContext)
		}
	}

	return tst
}

func (s *WhenExpressionContext) WhenEntry(i int) IWhenEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenEntryContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (p *KotlinParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, KotlinParserRULE_whenExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3000)
		p.Match(KotlinParserWHEN)
	}
	p.SetState(3004)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3001)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3006)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext())
	}
	p.SetState(3008)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLPAREN {
		{
			p.SetState(3007)
			p.WhenSubject()
		}

	}
	p.SetState(3013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3010)
			p.Match(KotlinParserNL)
		}

		p.SetState(3015)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3016)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(3020)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 463, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3017)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3022)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 463, p.GetParserRuleContext())
	}
	p.SetState(3032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL_WS)|(1<<KotlinParserEXCL_NO_WS))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(KotlinParserCOLONCOLON-37))|(1<<(KotlinParserAT_NO_WS-37))|(1<<(KotlinParserAT_PRE_WS-37))|(1<<(KotlinParserRETURN_AT-37))|(1<<(KotlinParserCONTINUE_AT-37))|(1<<(KotlinParserBREAK_AT-37))|(1<<(KotlinParserTHIS_AT-37))|(1<<(KotlinParserSUPER_AT-37))|(1<<(KotlinParserFILE-37))|(1<<(KotlinParserFIELD-37))|(1<<(KotlinParserPROPERTY-37))|(1<<(KotlinParserGET-37))|(1<<(KotlinParserSET-37))|(1<<(KotlinParserRECEIVER-37))|(1<<(KotlinParserPARAM-37))|(1<<(KotlinParserSETPARAM-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KotlinParserDELEGATE-69))|(1<<(KotlinParserIMPORT-69))|(1<<(KotlinParserFUN-69))|(1<<(KotlinParserOBJECT-69))|(1<<(KotlinParserCONSTRUCTOR-69))|(1<<(KotlinParserBY-69))|(1<<(KotlinParserCOMPANION-69))|(1<<(KotlinParserINIT-69))|(1<<(KotlinParserTHIS-69))|(1<<(KotlinParserSUPER-69))|(1<<(KotlinParserWHERE-69))|(1<<(KotlinParserIF-69))|(1<<(KotlinParserELSE-69))|(1<<(KotlinParserWHEN-69))|(1<<(KotlinParserTRY-69))|(1<<(KotlinParserCATCH-69))|(1<<(KotlinParserFINALLY-69))|(1<<(KotlinParserTHROW-69))|(1<<(KotlinParserRETURN-69))|(1<<(KotlinParserCONTINUE-69))|(1<<(KotlinParserBREAK-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(KotlinParserIS-101))|(1<<(KotlinParserIN-101))|(1<<(KotlinParserNOT_IS-101))|(1<<(KotlinParserNOT_IN-101))|(1<<(KotlinParserOUT-101))|(1<<(KotlinParserDYNAMIC-101))|(1<<(KotlinParserPUBLIC-101))|(1<<(KotlinParserPRIVATE-101))|(1<<(KotlinParserPROTECTED-101))|(1<<(KotlinParserINTERNAL-101))|(1<<(KotlinParserENUM-101))|(1<<(KotlinParserSEALED-101))|(1<<(KotlinParserANNOTATION-101))|(1<<(KotlinParserDATA-101))|(1<<(KotlinParserINNER-101))|(1<<(KotlinParserVALUE-101))|(1<<(KotlinParserTAILREC-101))|(1<<(KotlinParserOPERATOR-101))|(1<<(KotlinParserINLINE-101))|(1<<(KotlinParserINFIX-101))|(1<<(KotlinParserEXTERNAL-101))|(1<<(KotlinParserSUSPEND-101))|(1<<(KotlinParserOVERRIDE-101))|(1<<(KotlinParserABSTRACT-101))|(1<<(KotlinParserFINAL-101))|(1<<(KotlinParserOPEN-101))|(1<<(KotlinParserCONST-101))|(1<<(KotlinParserLATEINIT-101))|(1<<(KotlinParserVARARG-101))|(1<<(KotlinParserNOINLINE-101))|(1<<(KotlinParserCROSSINLINE-101))|(1<<(KotlinParserREIFIED-101)))) != 0) || (((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(KotlinParserEXPECT-133))|(1<<(KotlinParserACTUAL-133))|(1<<(KotlinParserRealLiteral-133))|(1<<(KotlinParserIntegerLiteral-133))|(1<<(KotlinParserHexLiteral-133))|(1<<(KotlinParserBinLiteral-133))|(1<<(KotlinParserUnsignedLiteral-133))|(1<<(KotlinParserLongLiteral-133))|(1<<(KotlinParserBooleanLiteral-133))|(1<<(KotlinParserNullLiteral-133))|(1<<(KotlinParserCharacterLiteral-133))|(1<<(KotlinParserIdentifier-133))|(1<<(KotlinParserQUOTE_OPEN-133))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-133)))) != 0) {
		{
			p.SetState(3023)
			p.WhenEntry()
		}
		p.SetState(3027)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 464, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3024)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3029)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 464, p.GetParserRuleContext())
		}

		p.SetState(3034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3038)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3035)
			p.Match(KotlinParserNL)
		}

		p.SetState(3040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3041)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IWhenEntryContext is an interface to support dynamic dispatch.
type IWhenEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenEntryContext differentiates from other interfaces.
	IsWhenEntryContext()
}

type WhenEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenEntryContext() *WhenEntryContext {
	var p = new(WhenEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenEntry
	return p
}

func (*WhenEntryContext) IsWhenEntryContext() {}

func NewWhenEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenEntryContext {
	var p = new(WhenEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenEntry

	return p
}

func (s *WhenEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenEntryContext) AllWhenCondition() []IWhenConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem())
	var tst = make([]IWhenConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenConditionContext)
		}
	}

	return tst
}

func (s *WhenEntryContext) WhenCondition(i int) IWhenConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *WhenEntryContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *WhenEntryContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhenEntryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *WhenEntryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *WhenEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenEntryContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *WhenEntryContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *WhenEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenEntry(s)
	}
}

func (s *WhenEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenEntry(s)
	}
}

func (p *KotlinParser) WhenEntry() (localctx IWhenEntryContext) {
	localctx = NewWhenEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, KotlinParserRULE_whenEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3107)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserFUN, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserIS, KotlinParserIN, KotlinParserNOT_IS, KotlinParserNOT_IN, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3043)
			p.WhenCondition()
		}
		p.SetState(3060)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 469, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(3047)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3044)
						p.Match(KotlinParserNL)
					}

					p.SetState(3049)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3050)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(3054)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3051)
						p.Match(KotlinParserNL)
					}

					p.SetState(3056)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3057)
					p.WhenCondition()
				}

			}
			p.SetState(3062)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 469, p.GetParserRuleContext())
		}
		p.SetState(3070)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 471, p.GetParserRuleContext()) == 1 {
			p.SetState(3066)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3063)
					p.Match(KotlinParserNL)
				}

				p.SetState(3068)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3069)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(3075)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3072)
				p.Match(KotlinParserNL)
			}

			p.SetState(3077)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3078)
			p.Match(KotlinParserARROW)
		}
		p.SetState(3082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3079)
				p.Match(KotlinParserNL)
			}

			p.SetState(3084)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3085)
			p.ControlStructureBody()
		}
		p.SetState(3087)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 474, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3086)
				p.Semi()
			}

		}

	case KotlinParserELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3089)
			p.Match(KotlinParserELSE)
		}
		p.SetState(3093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3090)
				p.Match(KotlinParserNL)
			}

			p.SetState(3095)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3096)
			p.Match(KotlinParserARROW)
		}
		p.SetState(3100)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3097)
				p.Match(KotlinParserNL)
			}

			p.SetState(3102)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3103)
			p.ControlStructureBody()
		}
		p.SetState(3105)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 477, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3104)
				p.Semi()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenConditionContext is an interface to support dynamic dispatch.
type IWhenConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenConditionContext differentiates from other interfaces.
	IsWhenConditionContext()
}

type WhenConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenConditionContext() *WhenConditionContext {
	var p = new(WhenConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenCondition
	return p
}

func (*WhenConditionContext) IsWhenConditionContext() {}

func NewWhenConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenConditionContext {
	var p = new(WhenConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenCondition

	return p
}

func (s *WhenConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenConditionContext) RangeTest() IRangeTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRangeTestContext)
}

func (s *WhenConditionContext) TypeTest() ITypeTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTestContext)
}

func (s *WhenConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenCondition(s)
	}
}

func (s *WhenConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenCondition(s)
	}
}

func (p *KotlinParser) WhenCondition() (localctx IWhenConditionContext) {
	localctx = NewWhenConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, KotlinParserRULE_whenCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3112)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserFUN, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3109)
			p.Expression()
		}

	case KotlinParserIN, KotlinParserNOT_IN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3110)
			p.RangeTest()
		}

	case KotlinParserIS, KotlinParserNOT_IS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3111)
			p.TypeTest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRangeTestContext is an interface to support dynamic dispatch.
type IRangeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeTestContext differentiates from other interfaces.
	IsRangeTestContext()
}

type RangeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeTestContext() *RangeTestContext {
	var p = new(RangeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeTest
	return p
}

func (*RangeTestContext) IsRangeTestContext() {}

func NewRangeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeTestContext {
	var p = new(RangeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeTest

	return p
}

func (s *RangeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeTestContext) InOperator() IInOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *RangeTestContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeTest(s)
	}
}

func (s *RangeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeTest(s)
	}
}

func (p *KotlinParser) RangeTest() (localctx IRangeTestContext) {
	localctx = NewRangeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, KotlinParserRULE_rangeTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3114)
		p.InOperator()
	}
	p.SetState(3118)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3115)
			p.Match(KotlinParserNL)
		}

		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3121)
		p.Expression()
	}

	return localctx
}

// ITypeTestContext is an interface to support dynamic dispatch.
type ITypeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTestContext differentiates from other interfaces.
	IsTypeTestContext()
}

type TypeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTestContext() *TypeTestContext {
	var p = new(TypeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeTest
	return p
}

func (*TypeTestContext) IsTypeTestContext() {}

func NewTypeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTestContext {
	var p = new(TypeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeTest

	return p
}

func (s *TypeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTestContext) IsOperator() IIsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIsOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *TypeTestContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeTest(s)
	}
}

func (s *TypeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeTest(s)
	}
}

func (p *KotlinParser) TypeTest() (localctx ITypeTestContext) {
	localctx = NewTypeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, KotlinParserRULE_typeTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3123)
		p.IsOperator()
	}
	p.SetState(3127)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3124)
			p.Match(KotlinParserNL)
		}

		p.SetState(3129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3130)
		p.DataType()
	}

	return localctx
}

// ITryExpressionContext is an interface to support dynamic dispatch.
type ITryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryExpressionContext differentiates from other interfaces.
	IsTryExpressionContext()
}

type TryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExpressionContext() *TryExpressionContext {
	var p = new(TryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_tryExpression
	return p
}

func (*TryExpressionContext) IsTryExpressionContext() {}

func NewTryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExpressionContext {
	var p = new(TryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_tryExpression

	return p
}

func (s *TryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExpressionContext) TRY() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRY, 0)
}

func (s *TryExpressionContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryExpressionContext) FinallyBlock() IFinallyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TryExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TryExpressionContext) AllCatchBlock() []ICatchBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchBlockContext)(nil)).Elem())
	var tst = make([]ICatchBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchBlockContext)
		}
	}

	return tst
}

func (s *TryExpressionContext) CatchBlock(i int) ICatchBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchBlockContext)
}

func (s *TryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTryExpression(s)
	}
}

func (s *TryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTryExpression(s)
	}
}

func (p *KotlinParser) TryExpression() (localctx ITryExpressionContext) {
	localctx = NewTryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, KotlinParserRULE_tryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3132)
		p.Match(KotlinParserTRY)
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3133)
			p.Match(KotlinParserNL)
		}

		p.SetState(3138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3139)
		p.Block()
	}
	p.SetState(3167)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 488, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3147)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(3143)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3140)
						p.Match(KotlinParserNL)
					}

					p.SetState(3145)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3146)
					p.CatchBlock()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3149)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 484, p.GetParserRuleContext())
		}
		p.SetState(3158)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 486, p.GetParserRuleContext()) == 1 {
			p.SetState(3154)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3151)
					p.Match(KotlinParserNL)
				}

				p.SetState(3156)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3157)
				p.FinallyBlock()
			}

		}

	case 2:
		p.SetState(3163)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3160)
				p.Match(KotlinParserNL)
			}

			p.SetState(3165)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3166)
			p.FinallyBlock()
		}

	}

	return localctx
}

// ICatchBlockContext is an interface to support dynamic dispatch.
type ICatchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchBlockContext differentiates from other interfaces.
	IsCatchBlockContext()
}

type CatchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchBlockContext() *CatchBlockContext {
	var p = new(CatchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_catchBlock
	return p
}

func (*CatchBlockContext) IsCatchBlockContext() {}

func NewCatchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchBlockContext {
	var p = new(CatchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_catchBlock

	return p
}

func (s *CatchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchBlockContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *CatchBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *CatchBlockContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CatchBlockContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CatchBlockContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CatchBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *CatchBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CatchBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CatchBlockContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *CatchBlockContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *CatchBlockContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *CatchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCatchBlock(s)
	}
}

func (s *CatchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCatchBlock(s)
	}
}

func (p *KotlinParser) CatchBlock() (localctx ICatchBlockContext) {
	localctx = NewCatchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, KotlinParserRULE_catchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3169)
		p.Match(KotlinParserCATCH)
	}
	p.SetState(3173)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3170)
			p.Match(KotlinParserNL)
		}

		p.SetState(3175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3176)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(3180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(3177)
			p.Annotation()
		}

		p.SetState(3182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3183)
		p.SimpleIdentifier()
	}
	{
		p.SetState(3184)
		p.Match(KotlinParserCOLON)
	}
	{
		p.SetState(3185)
		p.DataType()
	}
	p.SetState(3193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserNL || _la == KotlinParserCOMMA {
		p.SetState(3189)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3186)
				p.Match(KotlinParserNL)
			}

			p.SetState(3191)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3192)
			p.Match(KotlinParserCOMMA)
		}

	}
	{
		p.SetState(3195)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(3199)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3196)
			p.Match(KotlinParserNL)
		}

		p.SetState(3201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3202)
		p.Block()
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FinallyBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *KotlinParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, KotlinParserRULE_finallyBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3204)
		p.Match(KotlinParserFINALLY)
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3205)
			p.Match(KotlinParserNL)
		}

		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3211)
		p.Block()
	}

	return localctx
}

// IJumpExpressionContext is an interface to support dynamic dispatch.
type IJumpExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJumpExpressionContext differentiates from other interfaces.
	IsJumpExpressionContext()
}

type JumpExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpExpressionContext() *JumpExpressionContext {
	var p = new(JumpExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_jumpExpression
	return p
}

func (*JumpExpressionContext) IsJumpExpressionContext() {}

func NewJumpExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpExpressionContext {
	var p = new(JumpExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_jumpExpression

	return p
}

func (s *JumpExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpExpressionContext) THROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHROW, 0)
}

func (s *JumpExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *JumpExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *JumpExpressionContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN, 0)
}

func (s *JumpExpressionContext) RETURN_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN_AT, 0)
}

func (s *JumpExpressionContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE, 0)
}

func (s *JumpExpressionContext) CONTINUE_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE_AT, 0)
}

func (s *JumpExpressionContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK, 0)
}

func (s *JumpExpressionContext) BREAK_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK_AT, 0)
}

func (s *JumpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterJumpExpression(s)
	}
}

func (s *JumpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitJumpExpression(s)
	}
}

func (p *KotlinParser) JumpExpression() (localctx IJumpExpressionContext) {
	localctx = NewJumpExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, KotlinParserRULE_jumpExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3229)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserTHROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3213)
			p.Match(KotlinParserTHROW)
		}
		p.SetState(3217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3214)
				p.Match(KotlinParserNL)
			}

			p.SetState(3219)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3220)
			p.Expression()
		}

	case KotlinParserRETURN_AT, KotlinParserRETURN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3221)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserRETURN_AT || _la == KotlinParserRETURN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3223)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3222)
				p.Expression()
			}

		}

	case KotlinParserCONTINUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3225)
			p.Match(KotlinParserCONTINUE)
		}

	case KotlinParserCONTINUE_AT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3226)
			p.Match(KotlinParserCONTINUE_AT)
		}

	case KotlinParserBREAK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3227)
			p.Match(KotlinParserBREAK)
		}

	case KotlinParserBREAK_AT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3228)
			p.Match(KotlinParserBREAK_AT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallableReferenceContext is an interface to support dynamic dispatch.
type ICallableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallableReferenceContext differentiates from other interfaces.
	IsCallableReferenceContext()
}

type CallableReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallableReferenceContext() *CallableReferenceContext {
	var p = new(CallableReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_callableReference
	return p
}

func (*CallableReferenceContext) IsCallableReferenceContext() {}

func NewCallableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallableReferenceContext {
	var p = new(CallableReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callableReference

	return p
}

func (s *CallableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallableReferenceContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *CallableReferenceContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CallableReferenceContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *CallableReferenceContext) ReceiverType() IReceiverTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *CallableReferenceContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CallableReferenceContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CallableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallableReference(s)
	}
}

func (s *CallableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallableReference(s)
	}
}

func (p *KotlinParser) CallableReference() (localctx ICallableReferenceContext) {
	localctx = NewCallableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, KotlinParserRULE_callableReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLPAREN || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT_NO_WS-40))|(1<<(KotlinParserAT_PRE_WS-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserFIELD-40))|(1<<(KotlinParserPROPERTY-40))|(1<<(KotlinParserGET-40))|(1<<(KotlinParserSET-40))|(1<<(KotlinParserRECEIVER-40))|(1<<(KotlinParserPARAM-40))|(1<<(KotlinParserSETPARAM-40))|(1<<(KotlinParserDELEGATE-40))|(1<<(KotlinParserIMPORT-40)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(KotlinParserCONSTRUCTOR-79))|(1<<(KotlinParserBY-79))|(1<<(KotlinParserCOMPANION-79))|(1<<(KotlinParserINIT-79))|(1<<(KotlinParserWHERE-79))|(1<<(KotlinParserCATCH-79))|(1<<(KotlinParserFINALLY-79))|(1<<(KotlinParserOUT-79))|(1<<(KotlinParserDYNAMIC-79))|(1<<(KotlinParserPUBLIC-79))|(1<<(KotlinParserPRIVATE-79))|(1<<(KotlinParserPROTECTED-79))|(1<<(KotlinParserINTERNAL-79)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(KotlinParserENUM-111))|(1<<(KotlinParserSEALED-111))|(1<<(KotlinParserANNOTATION-111))|(1<<(KotlinParserDATA-111))|(1<<(KotlinParserINNER-111))|(1<<(KotlinParserVALUE-111))|(1<<(KotlinParserTAILREC-111))|(1<<(KotlinParserOPERATOR-111))|(1<<(KotlinParserINLINE-111))|(1<<(KotlinParserINFIX-111))|(1<<(KotlinParserEXTERNAL-111))|(1<<(KotlinParserSUSPEND-111))|(1<<(KotlinParserOVERRIDE-111))|(1<<(KotlinParserABSTRACT-111))|(1<<(KotlinParserFINAL-111))|(1<<(KotlinParserOPEN-111))|(1<<(KotlinParserCONST-111))|(1<<(KotlinParserLATEINIT-111))|(1<<(KotlinParserVARARG-111))|(1<<(KotlinParserNOINLINE-111))|(1<<(KotlinParserCROSSINLINE-111))|(1<<(KotlinParserREIFIED-111))|(1<<(KotlinParserEXPECT-111))|(1<<(KotlinParserACTUAL-111)))) != 0) || _la == KotlinParserIdentifier {
		{
			p.SetState(3231)
			p.ReceiverType()
		}

	}
	{
		p.SetState(3234)
		p.Match(KotlinParserCOLONCOLON)
	}
	p.SetState(3238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3235)
			p.Match(KotlinParserNL)
		}

		p.SetState(3240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3243)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(3241)
			p.SimpleIdentifier()
		}

	case KotlinParserCLASS:
		{
			p.SetState(3242)
			p.Match(KotlinParserCLASS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentAndOperatorContext is an interface to support dynamic dispatch.
type IAssignmentAndOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentAndOperatorContext differentiates from other interfaces.
	IsAssignmentAndOperatorContext()
}

type AssignmentAndOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentAndOperatorContext() *AssignmentAndOperatorContext {
	var p = new(AssignmentAndOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator
	return p
}

func (*AssignmentAndOperatorContext) IsAssignmentAndOperatorContext() {}

func NewAssignmentAndOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentAndOperatorContext {
	var p = new(AssignmentAndOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator

	return p
}

func (s *AssignmentAndOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentAndOperatorContext) ADD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) SUB_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) MULT_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) DIV_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) MOD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentAndOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentAndOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignmentAndOperator(s)
	}
}

func (s *AssignmentAndOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignmentAndOperator(s)
	}
}

func (p *KotlinParser) AssignmentAndOperator() (localctx IAssignmentAndOperatorContext) {
	localctx = NewAssignmentAndOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, KotlinParserRULE_assignmentAndOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3245)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(KotlinParserADD_ASSIGNMENT-29))|(1<<(KotlinParserSUB_ASSIGNMENT-29))|(1<<(KotlinParserMULT_ASSIGNMENT-29))|(1<<(KotlinParserDIV_ASSIGNMENT-29))|(1<<(KotlinParserMOD_ASSIGNMENT-29)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEqualityOperatorContext is an interface to support dynamic dispatch.
type IEqualityOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityOperatorContext differentiates from other interfaces.
	IsEqualityOperatorContext()
}

type EqualityOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityOperatorContext() *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_equalityOperator
	return p
}

func (*EqualityOperatorContext) IsEqualityOperatorContext() {}

func NewEqualityOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equalityOperator

	return p
}

func (s *EqualityOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityOperatorContext) EXCL_EQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQ, 0)
}

func (s *EqualityOperatorContext) EXCL_EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQEQ, 0)
}

func (s *EqualityOperatorContext) EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQ, 0)
}

func (s *EqualityOperatorContext) EQEQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQEQ, 0)
}

func (s *EqualityOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEqualityOperator(s)
	}
}

func (s *EqualityOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEqualityOperator(s)
	}
}

func (p *KotlinParser) EqualityOperator() (localctx IEqualityOperatorContext) {
	localctx = NewEqualityOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, KotlinParserRULE_equalityOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3247)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(KotlinParserEXCL_EQ-50))|(1<<(KotlinParserEXCL_EQEQ-50))|(1<<(KotlinParserEQEQ-50))|(1<<(KotlinParserEQEQEQ-50)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *ComparisonOperatorContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *ComparisonOperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLE, 0)
}

func (s *ComparisonOperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(KotlinParserGE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *KotlinParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, KotlinParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3249)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(KotlinParserLANGLE-46))|(1<<(KotlinParserRANGLE-46))|(1<<(KotlinParserLE-46))|(1<<(KotlinParserGE-46)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInOperatorContext is an interface to support dynamic dispatch.
type IInOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInOperatorContext differentiates from other interfaces.
	IsInOperatorContext()
}

type InOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInOperatorContext() *InOperatorContext {
	var p = new(InOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_inOperator
	return p
}

func (*InOperatorContext) IsInOperatorContext() {}

func NewInOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InOperatorContext {
	var p = new(InOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inOperator

	return p
}

func (s *InOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *InOperatorContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IN, 0)
}

func (s *InOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInOperator(s)
	}
}

func (s *InOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInOperator(s)
	}
}

func (p *KotlinParser) InOperator() (localctx IInOperatorContext) {
	localctx = NewInOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, KotlinParserRULE_inOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3251)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserNOT_IN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIsOperatorContext is an interface to support dynamic dispatch.
type IIsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIsOperatorContext differentiates from other interfaces.
	IsIsOperatorContext()
}

type IsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsOperatorContext() *IsOperatorContext {
	var p = new(IsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_isOperator
	return p
}

func (*IsOperatorContext) IsIsOperatorContext() {}

func NewIsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsOperatorContext {
	var p = new(IsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_isOperator

	return p
}

func (s *IsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *IsOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserIS, 0)
}

func (s *IsOperatorContext) NOT_IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IS, 0)
}

func (s *IsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIsOperator(s)
	}
}

func (s *IsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIsOperator(s)
	}
}

func (p *KotlinParser) IsOperator() (localctx IIsOperatorContext) {
	localctx = NewIsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, KotlinParserRULE_isOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3253)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIS || _la == KotlinParserNOT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAdditiveOperatorContext is an interface to support dynamic dispatch.
type IAdditiveOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveOperatorContext differentiates from other interfaces.
	IsAdditiveOperatorContext()
}

type AdditiveOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveOperatorContext() *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveOperator
	return p
}

func (*AdditiveOperatorContext) IsAdditiveOperatorContext() {}

func NewAdditiveOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveOperator

	return p
}

func (s *AdditiveOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *AdditiveOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *AdditiveOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveOperator(s)
	}
}

func (s *AdditiveOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveOperator(s)
	}
}

func (p *KotlinParser) AdditiveOperator() (localctx IAdditiveOperatorContext) {
	localctx = NewAdditiveOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, KotlinParserRULE_additiveOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3255)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserADD || _la == KotlinParserSUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiplicativeOperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeOperatorContext differentiates from other interfaces.
	IsMultiplicativeOperatorContext()
}

type MultiplicativeOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeOperatorContext() *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator
	return p
}

func (*MultiplicativeOperatorContext) IsMultiplicativeOperatorContext() {}

func NewMultiplicativeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator

	return p
}

func (s *MultiplicativeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeOperatorContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *MultiplicativeOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV, 0)
}

func (s *MultiplicativeOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD, 0)
}

func (s *MultiplicativeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeOperator(s)
	}
}

func (s *MultiplicativeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeOperator(s)
	}
}

func (p *KotlinParser) MultiplicativeOperator() (localctx IMultiplicativeOperatorContext) {
	localctx = NewMultiplicativeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, KotlinParserRULE_multiplicativeOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3257)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserMULT)|(1<<KotlinParserMOD)|(1<<KotlinParserDIV))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAsOperatorContext is an interface to support dynamic dispatch.
type IAsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsOperatorContext differentiates from other interfaces.
	IsAsOperatorContext()
}

type AsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsOperatorContext() *AsOperatorContext {
	var p = new(AsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_asOperator
	return p
}

func (*AsOperatorContext) IsAsOperatorContext() {}

func NewAsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsOperatorContext {
	var p = new(AsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_asOperator

	return p
}

func (s *AsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AsOperatorContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *AsOperatorContext) AS_SAFE() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS_SAFE, 0)
}

func (s *AsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAsOperator(s)
	}
}

func (s *AsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAsOperator(s)
	}
}

func (p *KotlinParser) AsOperator() (localctx IAsOperatorContext) {
	localctx = NewAsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, KotlinParserRULE_asOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3259)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAS_SAFE || _la == KotlinParserAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrefixUnaryOperatorContext is an interface to support dynamic dispatch.
type IPrefixUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixUnaryOperatorContext differentiates from other interfaces.
	IsPrefixUnaryOperatorContext()
}

type PrefixUnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryOperatorContext() *PrefixUnaryOperatorContext {
	var p = new(PrefixUnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator
	return p
}

func (*PrefixUnaryOperatorContext) IsPrefixUnaryOperatorContext() {}

func NewPrefixUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryOperatorContext {
	var p = new(PrefixUnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator

	return p
}

func (s *PrefixUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryOperatorContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PrefixUnaryOperatorContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PrefixUnaryOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *PrefixUnaryOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *PrefixUnaryOperatorContext) Excl() IExclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclContext)
}

func (s *PrefixUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryOperator(s)
	}
}

func (s *PrefixUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryOperator(s)
	}
}

func (p *KotlinParser) PrefixUnaryOperator() (localctx IPrefixUnaryOperatorContext) {
	localctx = NewPrefixUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, KotlinParserRULE_prefixUnaryOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3266)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3261)
			p.Match(KotlinParserINCR)
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3262)
			p.Match(KotlinParserDECR)
		}

	case KotlinParserSUB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3263)
			p.Match(KotlinParserSUB)
		}

	case KotlinParserADD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3264)
			p.Match(KotlinParserADD)
		}

	case KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3265)
			p.Excl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixUnaryOperatorContext is an interface to support dynamic dispatch.
type IPostfixUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixUnaryOperatorContext differentiates from other interfaces.
	IsPostfixUnaryOperatorContext()
}

type PostfixUnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryOperatorContext() *PostfixUnaryOperatorContext {
	var p = new(PostfixUnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator
	return p
}

func (*PostfixUnaryOperatorContext) IsPostfixUnaryOperatorContext() {}

func NewPostfixUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryOperatorContext {
	var p = new(PostfixUnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator

	return p
}

func (s *PostfixUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryOperatorContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PostfixUnaryOperatorContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PostfixUnaryOperatorContext) EXCL_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_NO_WS, 0)
}

func (s *PostfixUnaryOperatorContext) Excl() IExclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclContext)
}

func (s *PostfixUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryOperator(s)
	}
}

func (s *PostfixUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryOperator(s)
	}
}

func (p *KotlinParser) PostfixUnaryOperator() (localctx IPostfixUnaryOperatorContext) {
	localctx = NewPostfixUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, KotlinParserRULE_postfixUnaryOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3272)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3268)
			p.Match(KotlinParserINCR)
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3269)
			p.Match(KotlinParserDECR)
		}

	case KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3270)
			p.Match(KotlinParserEXCL_NO_WS)
		}
		{
			p.SetState(3271)
			p.Excl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExclContext is an interface to support dynamic dispatch.
type IExclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclContext differentiates from other interfaces.
	IsExclContext()
}

type ExclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclContext() *ExclContext {
	var p = new(ExclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_excl
	return p
}

func (*ExclContext) IsExclContext() {}

func NewExclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclContext {
	var p = new(ExclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_excl

	return p
}

func (s *ExclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclContext) EXCL_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_NO_WS, 0)
}

func (s *ExclContext) EXCL_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_WS, 0)
}

func (s *ExclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExcl(s)
	}
}

func (s *ExclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExcl(s)
	}
}

func (p *KotlinParser) Excl() (localctx IExclContext) {
	localctx = NewExclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, KotlinParserRULE_excl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3274)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserEXCL_WS || _la == KotlinParserEXCL_NO_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberAccessOperatorContext is an interface to support dynamic dispatch.
type IMemberAccessOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberAccessOperatorContext differentiates from other interfaces.
	IsMemberAccessOperatorContext()
}

type MemberAccessOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessOperatorContext() *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_memberAccessOperator
	return p
}

func (*MemberAccessOperatorContext) IsMemberAccessOperatorContext() {}

func NewMemberAccessOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberAccessOperator

	return p
}

func (s *MemberAccessOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessOperatorContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *MemberAccessOperatorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MemberAccessOperatorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MemberAccessOperatorContext) SafeNav() ISafeNavContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISafeNavContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISafeNavContext)
}

func (s *MemberAccessOperatorContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *MemberAccessOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberAccessOperator(s)
	}
}

func (s *MemberAccessOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberAccessOperator(s)
	}
}

func (p *KotlinParser) MemberAccessOperator() (localctx IMemberAccessOperatorContext) {
	localctx = NewMemberAccessOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, KotlinParserRULE_memberAccessOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 505, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3276)
				p.Match(KotlinParserNL)
			}

			p.SetState(3281)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3282)
			p.Match(KotlinParserDOT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3283)
				p.Match(KotlinParserNL)
			}

			p.SetState(3288)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3289)
			p.SafeNav()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3290)
			p.Match(KotlinParserCOLONCOLON)
		}

	}

	return localctx
}

// ISafeNavContext is an interface to support dynamic dispatch.
type ISafeNavContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSafeNavContext differentiates from other interfaces.
	IsSafeNavContext()
}

type SafeNavContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySafeNavContext() *SafeNavContext {
	var p = new(SafeNavContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_safeNav
	return p
}

func (*SafeNavContext) IsSafeNavContext() {}

func NewSafeNavContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SafeNavContext {
	var p = new(SafeNavContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_safeNav

	return p
}

func (s *SafeNavContext) GetParser() antlr.Parser { return s.parser }

func (s *SafeNavContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *SafeNavContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *SafeNavContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SafeNavContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SafeNavContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSafeNav(s)
	}
}

func (s *SafeNavContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSafeNav(s)
	}
}

func (p *KotlinParser) SafeNav() (localctx ISafeNavContext) {
	localctx = NewSafeNavContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, KotlinParserRULE_safeNav)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3293)
		p.Match(KotlinParserQUEST_NO_WS)
	}
	{
		p.SetState(3294)
		p.Match(KotlinParserDOT)
	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ModifiersContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModifiersContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *ModifiersContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *KotlinParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, KotlinParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3298)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3298)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(3296)
					p.Annotation()
				}

			case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserEXPECT, KotlinParserACTUAL:
				{
					p.SetState(3297)
					p.Modifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3300)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterModifiersContext is an interface to support dynamic dispatch.
type IParameterModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterModifiersContext differentiates from other interfaces.
	IsParameterModifiersContext()
}

type ParameterModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifiersContext() *ParameterModifiersContext {
	var p = new(ParameterModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifiers
	return p
}

func (*ParameterModifiersContext) IsParameterModifiersContext() {}

func NewParameterModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifiersContext {
	var p = new(ParameterModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifiers

	return p
}

func (s *ParameterModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifiersContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ParameterModifiersContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ParameterModifiersContext) AllParameterModifier() []IParameterModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterModifierContext)(nil)).Elem())
	var tst = make([]IParameterModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterModifierContext)
		}
	}

	return tst
}

func (s *ParameterModifiersContext) ParameterModifier(i int) IParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ParameterModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifiers(s)
	}
}

func (s *ParameterModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifiers(s)
	}
}

func (p *KotlinParser) ParameterModifiers() (localctx IParameterModifiersContext) {
	localctx = NewParameterModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, KotlinParserRULE_parameterModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3304)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3304)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(3302)
					p.Annotation()
				}

			case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
				{
					p.SetState(3303)
					p.ParameterModifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3306)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext())
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassModifier() IClassModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *ModifierContext) MemberModifier() IMemberModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *ModifierContext) VisibilityModifier() IVisibilityModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityModifierContext)
}

func (s *ModifierContext) FunctionModifier() IFunctionModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *ModifierContext) PropertyModifier() IPropertyModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyModifierContext)
}

func (s *ModifierContext) InheritanceModifier() IInheritanceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritanceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritanceModifierContext)
}

func (s *ModifierContext) ParameterModifier() IParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ModifierContext) PlatformModifier() IPlatformModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlatformModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPlatformModifierContext)
}

func (s *ModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *KotlinParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, KotlinParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE:
		{
			p.SetState(3308)
			p.ClassModifier()
		}

	case KotlinParserOVERRIDE, KotlinParserLATEINIT:
		{
			p.SetState(3309)
			p.MemberModifier()
		}

	case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL:
		{
			p.SetState(3310)
			p.VisibilityModifier()
		}

	case KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND:
		{
			p.SetState(3311)
			p.FunctionModifier()
		}

	case KotlinParserCONST:
		{
			p.SetState(3312)
			p.PropertyModifier()
		}

	case KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN:
		{
			p.SetState(3313)
			p.InheritanceModifier()
		}

	case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
		{
			p.SetState(3314)
			p.ParameterModifier()
		}

	case KotlinParserEXPECT, KotlinParserACTUAL:
		{
			p.SetState(3315)
			p.PlatformModifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3321)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3318)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3323)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeModifiersContext is an interface to support dynamic dispatch.
type ITypeModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeModifiersContext differentiates from other interfaces.
	IsTypeModifiersContext()
}

type TypeModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifiersContext() *TypeModifiersContext {
	var p = new(TypeModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifiers
	return p
}

func (*TypeModifiersContext) IsTypeModifiersContext() {}

func NewTypeModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifiersContext {
	var p = new(TypeModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifiers

	return p
}

func (s *TypeModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifiersContext) AllTypeModifier() []ITypeModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeModifierContext)(nil)).Elem())
	var tst = make([]ITypeModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeModifierContext)
		}
	}

	return tst
}

func (s *TypeModifiersContext) TypeModifier(i int) ITypeModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeModifierContext)
}

func (s *TypeModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifiers(s)
	}
}

func (s *TypeModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifiers(s)
	}
}

func (p *KotlinParser) TypeModifiers() (localctx ITypeModifiersContext) {
	localctx = NewTypeModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, KotlinParserRULE_typeModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3325)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3324)
				p.TypeModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3327)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 512, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeModifierContext is an interface to support dynamic dispatch.
type ITypeModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeModifierContext differentiates from other interfaces.
	IsTypeModifierContext()
}

type TypeModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifierContext() *TypeModifierContext {
	var p = new(TypeModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifier
	return p
}

func (*TypeModifierContext) IsTypeModifierContext() {}

func NewTypeModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifierContext {
	var p = new(TypeModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifier

	return p
}

func (s *TypeModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *TypeModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifier(s)
	}
}

func (s *TypeModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifier(s)
	}
}

func (p *KotlinParser) TypeModifier() (localctx ITypeModifierContext) {
	localctx = NewTypeModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, KotlinParserRULE_typeModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3337)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3329)
			p.Annotation()
		}

	case KotlinParserSUSPEND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3330)
			p.Match(KotlinParserSUSPEND)
		}
		p.SetState(3334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3331)
				p.Match(KotlinParserNL)
			}

			p.SetState(3336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classModifier
	return p
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *ClassModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *ClassModifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *ClassModifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *ClassModifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *ClassModifierContext) VALUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserVALUE, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassModifier(s)
	}
}

func (s *ClassModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassModifier(s)
	}
}

func (p *KotlinParser) ClassModifier() (localctx IClassModifierContext) {
	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, KotlinParserRULE_classModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3339)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(KotlinParserENUM-111))|(1<<(KotlinParserSEALED-111))|(1<<(KotlinParserANNOTATION-111))|(1<<(KotlinParserDATA-111))|(1<<(KotlinParserINNER-111))|(1<<(KotlinParserVALUE-111)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_memberModifier
	return p
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *MemberModifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberModifier(s)
	}
}

func (s *MemberModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberModifier(s)
	}
}

func (p *KotlinParser) MemberModifier() (localctx IMemberModifierContext) {
	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, KotlinParserRULE_memberModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3341)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserOVERRIDE || _la == KotlinParserLATEINIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVisibilityModifierContext is an interface to support dynamic dispatch.
type IVisibilityModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVisibilityModifierContext differentiates from other interfaces.
	IsVisibilityModifierContext()
}

type VisibilityModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityModifierContext() *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_visibilityModifier
	return p
}

func (*VisibilityModifierContext) IsVisibilityModifierContext() {}

func NewVisibilityModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_visibilityModifier

	return p
}

func (s *VisibilityModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *VisibilityModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *VisibilityModifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *VisibilityModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *VisibilityModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVisibilityModifier(s)
	}
}

func (s *VisibilityModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVisibilityModifier(s)
	}
}

func (p *KotlinParser) VisibilityModifier() (localctx IVisibilityModifierContext) {
	localctx = NewVisibilityModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, KotlinParserRULE_visibilityModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3343)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(KotlinParserPUBLIC-107))|(1<<(KotlinParserPRIVATE-107))|(1<<(KotlinParserPROTECTED-107))|(1<<(KotlinParserINTERNAL-107)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVarianceModifierContext is an interface to support dynamic dispatch.
type IVarianceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarianceModifierContext differentiates from other interfaces.
	IsVarianceModifierContext()
}

type VarianceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarianceModifierContext() *VarianceModifierContext {
	var p = new(VarianceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_varianceModifier
	return p
}

func (*VarianceModifierContext) IsVarianceModifierContext() {}

func NewVarianceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarianceModifierContext {
	var p = new(VarianceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_varianceModifier

	return p
}

func (s *VarianceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarianceModifierContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *VarianceModifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *VarianceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarianceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarianceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVarianceModifier(s)
	}
}

func (s *VarianceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVarianceModifier(s)
	}
}

func (p *KotlinParser) VarianceModifier() (localctx IVarianceModifierContext) {
	localctx = NewVarianceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, KotlinParserRULE_varianceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3345)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeParameterModifiersContext is an interface to support dynamic dispatch.
type ITypeParameterModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterModifiersContext differentiates from other interfaces.
	IsTypeParameterModifiersContext()
}

type TypeParameterModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifiersContext() *TypeParameterModifiersContext {
	var p = new(TypeParameterModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers
	return p
}

func (*TypeParameterModifiersContext) IsTypeParameterModifiersContext() {}

func NewTypeParameterModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifiersContext {
	var p = new(TypeParameterModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers

	return p
}

func (s *TypeParameterModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifiersContext) AllTypeParameterModifier() []ITypeParameterModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterModifierContext)(nil)).Elem())
	var tst = make([]ITypeParameterModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterModifierContext)
		}
	}

	return tst
}

func (s *TypeParameterModifiersContext) TypeParameterModifier(i int) ITypeParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifierContext)
}

func (s *TypeParameterModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifiers(s)
	}
}

func (s *TypeParameterModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifiers(s)
	}
}

func (p *KotlinParser) TypeParameterModifiers() (localctx ITypeParameterModifiersContext) {
	localctx = NewTypeParameterModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, KotlinParserRULE_typeParameterModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3348)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3347)
				p.TypeParameterModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3350)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 515, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterModifierContext is an interface to support dynamic dispatch.
type ITypeParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterModifierContext differentiates from other interfaces.
	IsTypeParameterModifierContext()
}

type TypeParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifierContext() *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifier
	return p
}

func (*TypeParameterModifierContext) IsTypeParameterModifierContext() {}

func NewTypeParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifier

	return p
}

func (s *TypeParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifierContext) ReificationModifier() IReificationModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReificationModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReificationModifierContext)
}

func (s *TypeParameterModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterModifierContext) VarianceModifier() IVarianceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarianceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarianceModifierContext)
}

func (s *TypeParameterModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifier(s)
	}
}

func (p *KotlinParser) TypeParameterModifier() (localctx ITypeParameterModifierContext) {
	localctx = NewTypeParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, KotlinParserRULE_typeParameterModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3367)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserREIFIED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3352)
			p.ReificationModifier()
		}
		p.SetState(3356)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 516, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3353)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3358)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 516, p.GetParserRuleContext())
		}

	case KotlinParserIN, KotlinParserOUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3359)
			p.VarianceModifier()
		}
		p.SetState(3363)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3360)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3365)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext())
		}

	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3366)
			p.Annotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionModifierContext is an interface to support dynamic dispatch.
type IFunctionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionModifierContext differentiates from other interfaces.
	IsFunctionModifierContext()
}

type FunctionModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionModifierContext() *FunctionModifierContext {
	var p = new(FunctionModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionModifier
	return p
}

func (*FunctionModifierContext) IsFunctionModifierContext() {}

func NewFunctionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionModifierContext {
	var p = new(FunctionModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionModifier

	return p
}

func (s *FunctionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionModifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *FunctionModifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *FunctionModifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *FunctionModifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *FunctionModifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *FunctionModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *FunctionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionModifier(s)
	}
}

func (s *FunctionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionModifier(s)
	}
}

func (p *KotlinParser) FunctionModifier() (localctx IFunctionModifierContext) {
	localctx = NewFunctionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, KotlinParserRULE_functionModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3369)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(KotlinParserTAILREC-117))|(1<<(KotlinParserOPERATOR-117))|(1<<(KotlinParserINLINE-117))|(1<<(KotlinParserINFIX-117))|(1<<(KotlinParserEXTERNAL-117))|(1<<(KotlinParserSUSPEND-117)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPropertyModifierContext is an interface to support dynamic dispatch.
type IPropertyModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyModifierContext differentiates from other interfaces.
	IsPropertyModifierContext()
}

type PropertyModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifierContext() *PropertyModifierContext {
	var p = new(PropertyModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyModifier
	return p
}

func (*PropertyModifierContext) IsPropertyModifierContext() {}

func NewPropertyModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifierContext {
	var p = new(PropertyModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyModifier

	return p
}

func (s *PropertyModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *PropertyModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyModifier(s)
	}
}

func (s *PropertyModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyModifier(s)
	}
}

func (p *KotlinParser) PropertyModifier() (localctx IPropertyModifierContext) {
	localctx = NewPropertyModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, KotlinParserRULE_propertyModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3371)
		p.Match(KotlinParserCONST)
	}

	return localctx
}

// IInheritanceModifierContext is an interface to support dynamic dispatch.
type IInheritanceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritanceModifierContext differentiates from other interfaces.
	IsInheritanceModifierContext()
}

type InheritanceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceModifierContext() *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_inheritanceModifier
	return p
}

func (*InheritanceModifierContext) IsInheritanceModifierContext() {}

func NewInheritanceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inheritanceModifier

	return p
}

func (s *InheritanceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *InheritanceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *InheritanceModifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *InheritanceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInheritanceModifier(s)
	}
}

func (s *InheritanceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInheritanceModifier(s)
	}
}

func (p *KotlinParser) InheritanceModifier() (localctx IInheritanceModifierContext) {
	localctx = NewInheritanceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, KotlinParserRULE_inheritanceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3373)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserABSTRACT-124))|(1<<(KotlinParserFINAL-124))|(1<<(KotlinParserOPEN-124)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IParameterModifierContext is an interface to support dynamic dispatch.
type IParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterModifierContext differentiates from other interfaces.
	IsParameterModifierContext()
}

type ParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifierContext() *ParameterModifierContext {
	var p = new(ParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifier
	return p
}

func (*ParameterModifierContext) IsParameterModifierContext() {}

func NewParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifierContext {
	var p = new(ParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifier

	return p
}

func (s *ParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *ParameterModifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *ParameterModifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *ParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifier(s)
	}
}

func (s *ParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifier(s)
	}
}

func (p *KotlinParser) ParameterModifier() (localctx IParameterModifierContext) {
	localctx = NewParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, KotlinParserRULE_parameterModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3375)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(KotlinParserVARARG-129))|(1<<(KotlinParserNOINLINE-129))|(1<<(KotlinParserCROSSINLINE-129)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReificationModifierContext is an interface to support dynamic dispatch.
type IReificationModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReificationModifierContext differentiates from other interfaces.
	IsReificationModifierContext()
}

type ReificationModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReificationModifierContext() *ReificationModifierContext {
	var p = new(ReificationModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_reificationModifier
	return p
}

func (*ReificationModifierContext) IsReificationModifierContext() {}

func NewReificationModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReificationModifierContext {
	var p = new(ReificationModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_reificationModifier

	return p
}

func (s *ReificationModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReificationModifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *ReificationModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReificationModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReificationModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterReificationModifier(s)
	}
}

func (s *ReificationModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitReificationModifier(s)
	}
}

func (p *KotlinParser) ReificationModifier() (localctx IReificationModifierContext) {
	localctx = NewReificationModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, KotlinParserRULE_reificationModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3377)
		p.Match(KotlinParserREIFIED)
	}

	return localctx
}

// IPlatformModifierContext is an interface to support dynamic dispatch.
type IPlatformModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPlatformModifierContext differentiates from other interfaces.
	IsPlatformModifierContext()
}

type PlatformModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlatformModifierContext() *PlatformModifierContext {
	var p = new(PlatformModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_platformModifier
	return p
}

func (*PlatformModifierContext) IsPlatformModifierContext() {}

func NewPlatformModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlatformModifierContext {
	var p = new(PlatformModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_platformModifier

	return p
}

func (s *PlatformModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PlatformModifierContext) EXPECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXPECT, 0)
}

func (s *PlatformModifierContext) ACTUAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserACTUAL, 0)
}

func (s *PlatformModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlatformModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlatformModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPlatformModifier(s)
	}
}

func (s *PlatformModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPlatformModifier(s)
	}
}

func (p *KotlinParser) PlatformModifier() (localctx IPlatformModifierContext) {
	localctx = NewPlatformModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, KotlinParserRULE_platformModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3379)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserEXPECT || _la == KotlinParserACTUAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) SingleAnnotation() ISingleAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleAnnotationContext)
}

func (s *AnnotationContext) MultiAnnotation() IMultiAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiAnnotationContext)
}

func (s *AnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *KotlinParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, KotlinParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3381)
			p.SingleAnnotation()
		}

	case 2:
		{
			p.SetState(3382)
			p.MultiAnnotation()
		}

	}
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 520, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3385)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3390)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 520, p.GetParserRuleContext())
	}

	return localctx
}

// ISingleAnnotationContext is an interface to support dynamic dispatch.
type ISingleAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleAnnotationContext differentiates from other interfaces.
	IsSingleAnnotationContext()
}

type SingleAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleAnnotationContext() *SingleAnnotationContext {
	var p = new(SingleAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_singleAnnotation
	return p
}

func (*SingleAnnotationContext) IsSingleAnnotationContext() {}

func NewSingleAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleAnnotationContext {
	var p = new(SingleAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_singleAnnotation

	return p
}

func (s *SingleAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleAnnotationContext) UnescapedAnnotation() IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *SingleAnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationUseSiteTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *SingleAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *SingleAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *SingleAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SingleAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SingleAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSingleAnnotation(s)
	}
}

func (s *SingleAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSingleAnnotation(s)
	}
}

func (p *KotlinParser) SingleAnnotation() (localctx ISingleAnnotationContext) {
	localctx = NewSingleAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, KotlinParserRULE_singleAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3400)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 522, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3391)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(3395)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3392)
				p.Match(KotlinParserNL)
			}

			p.SetState(3397)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3398)
			p.Match(KotlinParserAT_NO_WS)
		}

	case 3:
		{
			p.SetState(3399)
			p.Match(KotlinParserAT_PRE_WS)
		}

	}
	{
		p.SetState(3402)
		p.UnescapedAnnotation()
	}

	return localctx
}

// IMultiAnnotationContext is an interface to support dynamic dispatch.
type IMultiAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiAnnotationContext differentiates from other interfaces.
	IsMultiAnnotationContext()
}

type MultiAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiAnnotationContext() *MultiAnnotationContext {
	var p = new(MultiAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiAnnotation
	return p
}

func (*MultiAnnotationContext) IsMultiAnnotationContext() {}

func NewMultiAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiAnnotationContext {
	var p = new(MultiAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiAnnotation

	return p
}

func (s *MultiAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiAnnotationContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *MultiAnnotationContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *MultiAnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationUseSiteTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *MultiAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *MultiAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *MultiAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem())
	var tst = make([]IUnescapedAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnescapedAnnotationContext)
		}
	}

	return tst
}

func (s *MultiAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *MultiAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiAnnotation(s)
	}
}

func (s *MultiAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiAnnotation(s)
	}
}

func (p *KotlinParser) MultiAnnotation() (localctx IMultiAnnotationContext) {
	localctx = NewMultiAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, KotlinParserRULE_multiAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3413)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3404)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(3408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3405)
				p.Match(KotlinParserNL)
			}

			p.SetState(3410)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3411)
			p.Match(KotlinParserAT_NO_WS)
		}

	case 3:
		{
			p.SetState(3412)
			p.Match(KotlinParserAT_PRE_WS)
		}

	}
	{
		p.SetState(3415)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(3417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(KotlinParserFILE-61))|(1<<(KotlinParserFIELD-61))|(1<<(KotlinParserPROPERTY-61))|(1<<(KotlinParserGET-61))|(1<<(KotlinParserSET-61))|(1<<(KotlinParserRECEIVER-61))|(1<<(KotlinParserPARAM-61))|(1<<(KotlinParserSETPARAM-61))|(1<<(KotlinParserDELEGATE-61))|(1<<(KotlinParserIMPORT-61))|(1<<(KotlinParserCONSTRUCTOR-61))|(1<<(KotlinParserBY-61))|(1<<(KotlinParserCOMPANION-61))|(1<<(KotlinParserINIT-61))|(1<<(KotlinParserWHERE-61))|(1<<(KotlinParserCATCH-61))|(1<<(KotlinParserFINALLY-61)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105)))) != 0) || _la == KotlinParserIdentifier {
		{
			p.SetState(3416)
			p.UnescapedAnnotation()
		}

		p.SetState(3419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3421)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// IAnnotationUseSiteTargetContext is an interface to support dynamic dispatch.
type IAnnotationUseSiteTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationUseSiteTargetContext differentiates from other interfaces.
	IsAnnotationUseSiteTargetContext()
}

type AnnotationUseSiteTargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationUseSiteTargetContext() *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget
	return p
}

func (*AnnotationUseSiteTargetContext) IsAnnotationUseSiteTargetContext() {}

func NewAnnotationUseSiteTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget

	return p
}

func (s *AnnotationUseSiteTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationUseSiteTargetContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnnotationUseSiteTargetContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *AnnotationUseSiteTargetContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *AnnotationUseSiteTargetContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *AnnotationUseSiteTargetContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *AnnotationUseSiteTargetContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *AnnotationUseSiteTargetContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *AnnotationUseSiteTargetContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *AnnotationUseSiteTargetContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *AnnotationUseSiteTargetContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationUseSiteTargetContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationUseSiteTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationUseSiteTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationUseSiteTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotationUseSiteTarget(s)
	}
}

func (s *AnnotationUseSiteTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotationUseSiteTarget(s)
	}
}

func (p *KotlinParser) AnnotationUseSiteTarget() (localctx IAnnotationUseSiteTargetContext) {
	localctx = NewAnnotationUseSiteTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, KotlinParserRULE_annotationUseSiteTarget)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3423)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3424)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(KotlinParserFIELD-62))|(1<<(KotlinParserPROPERTY-62))|(1<<(KotlinParserGET-62))|(1<<(KotlinParserSET-62))|(1<<(KotlinParserRECEIVER-62))|(1<<(KotlinParserPARAM-62))|(1<<(KotlinParserSETPARAM-62))|(1<<(KotlinParserDELEGATE-62)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3425)
			p.Match(KotlinParserNL)
		}

		p.SetState(3430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3431)
		p.Match(KotlinParserCOLON)
	}

	return localctx
}

// IUnescapedAnnotationContext is an interface to support dynamic dispatch.
type IUnescapedAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnescapedAnnotationContext differentiates from other interfaces.
	IsUnescapedAnnotationContext()
}

type UnescapedAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnescapedAnnotationContext() *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation
	return p
}

func (*UnescapedAnnotationContext) IsUnescapedAnnotationContext() {}

func NewUnescapedAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation

	return p
}

func (s *UnescapedAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnescapedAnnotationContext) ConstructorInvocation() IConstructorInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *UnescapedAnnotationContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *UnescapedAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnescapedAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnescapedAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnescapedAnnotation(s)
	}
}

func (s *UnescapedAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnescapedAnnotation(s)
	}
}

func (p *KotlinParser) UnescapedAnnotation() (localctx IUnescapedAnnotationContext) {
	localctx = NewUnescapedAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, KotlinParserRULE_unescapedAnnotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3435)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 527, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3433)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3434)
			p.UserType()
		}

	}

	return localctx
}

// ISimpleIdentifierContext is an interface to support dynamic dispatch.
type ISimpleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleIdentifierContext differentiates from other interfaces.
	IsSimpleIdentifierContext()
}

type SimpleIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdentifierContext() *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleIdentifier
	return p
}

func (*SimpleIdentifierContext) IsSimpleIdentifierContext() {}

func NewSimpleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleIdentifier

	return p
}

func (s *SimpleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(KotlinParserIdentifier, 0)
}

func (s *SimpleIdentifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *SimpleIdentifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *SimpleIdentifierContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *SimpleIdentifierContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *SimpleIdentifierContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *SimpleIdentifierContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SimpleIdentifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *SimpleIdentifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *SimpleIdentifierContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *SimpleIdentifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *SimpleIdentifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *SimpleIdentifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *SimpleIdentifierContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *SimpleIdentifierContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *SimpleIdentifierContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *SimpleIdentifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *SimpleIdentifierContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *SimpleIdentifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *SimpleIdentifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *SimpleIdentifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *SimpleIdentifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *SimpleIdentifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *SimpleIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *SimpleIdentifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *SimpleIdentifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *SimpleIdentifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *SimpleIdentifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *SimpleIdentifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *SimpleIdentifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *SimpleIdentifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *SimpleIdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *SimpleIdentifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *SimpleIdentifierContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *SimpleIdentifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *SimpleIdentifierContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *SimpleIdentifierContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *SimpleIdentifierContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *SimpleIdentifierContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *SimpleIdentifierContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *SimpleIdentifierContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *SimpleIdentifierContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *SimpleIdentifierContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *SimpleIdentifierContext) EXPECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXPECT, 0)
}

func (s *SimpleIdentifierContext) ACTUAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserACTUAL, 0)
}

func (s *SimpleIdentifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *SimpleIdentifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *SimpleIdentifierContext) VALUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserVALUE, 0)
}

func (s *SimpleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleIdentifier(s)
	}
}

func (p *KotlinParser) SimpleIdentifier() (localctx ISimpleIdentifierContext) {
	localctx = NewSimpleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, KotlinParserRULE_simpleIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3437)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(KotlinParserFILE-61))|(1<<(KotlinParserFIELD-61))|(1<<(KotlinParserPROPERTY-61))|(1<<(KotlinParserGET-61))|(1<<(KotlinParserSET-61))|(1<<(KotlinParserRECEIVER-61))|(1<<(KotlinParserPARAM-61))|(1<<(KotlinParserSETPARAM-61))|(1<<(KotlinParserDELEGATE-61))|(1<<(KotlinParserIMPORT-61))|(1<<(KotlinParserCONSTRUCTOR-61))|(1<<(KotlinParserBY-61))|(1<<(KotlinParserCOMPANION-61))|(1<<(KotlinParserINIT-61))|(1<<(KotlinParserWHERE-61))|(1<<(KotlinParserCATCH-61))|(1<<(KotlinParserFINALLY-61)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserOUT-105))|(1<<(KotlinParserDYNAMIC-105))|(1<<(KotlinParserPUBLIC-105))|(1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserVALUE-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105))|(1<<(KotlinParserEXPECT-105))|(1<<(KotlinParserACTUAL-105)))) != 0) || _la == KotlinParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem())
	var tst = make([]ISimpleIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleIdentifierContext)
		}
	}

	return tst
}

func (s *IdentifierContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *IdentifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IdentifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *KotlinParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, KotlinParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3439)
		p.SimpleIdentifier()
	}
	p.SetState(3450)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3443)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3440)
					p.Match(KotlinParserNL)
				}

				p.SetState(3445)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3446)
				p.Match(KotlinParserDOT)
			}
			{
				p.SetState(3447)
				p.SimpleIdentifier()
			}

		}
		p.SetState(3452)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext())
	}

	return localctx
}
